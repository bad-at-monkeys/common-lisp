----
EXERCISES
----
2.29 write a function UNARY-ADD1 that increases a unary number by one
   |x-->|CONS|---->
x ----->|____| |
   |___________|
2.30 what does the CDDR function do to unary numbers
it would subtract 2 unary numbers from its input

2.31 write a UNARY-ZEROP predicate
NULL is the unary ZEROP predicate

2.32 write a UNARY-GREATERP predicate, analogous to the > predicate on oridinary numbers
(x)   -->|LENGTH -|--> 1 -->|     |
         |--------|         |  > -| --> NIL
(x x) -->|LENGTH -|--> 2 -->|_____|
         |---------               |
         |________________________|

2.33 CAR can be viewed as a predicate on unary numbers. any non-NIL object is taken as true in lisp. CAR would return x or NIL. what question about a unary number does CAR answer
CAR returns a true value for any unary number greater than zero - it is the unary equivalent of PLUSP



----
2.17 NON-LIST CONS STRUCTURES
----
a proper list is a cons cell chain ending in NIL
there are cons cell structures that are not proper lists - they dont end in NIL

lisp prints a list in parenthesis notation beginning with a left parenthesis
followed by all the elements
separated by spaces
if the list ends in NIL
lisp prints right parenthesis

if the list doesnt end in NIL
lisp will print 'space period space atom right-parenthesis'
(A B C . D)
this is called a dotted list

a dotted pair is a single cons cell whose CDR is not NIL
A->|CONS|-> (A . B)
B->|____|

the dotted list (A B . C) contains two cons cells and is constructed this way
A---------->|CONS|----> (A B . C)
          ->|____|
   ______ |
B->|CONS|_|
C->|____|

the cons cell notation ends with C (not NIL)

LIST can only build proper lists
LIST always constructs a cons cell chain ending in NIL

CONS must be used to construct dotted lists


----
EXERCISES
----
2.34 write an expression involving cascaded calls to CONS to construct the dotted list (A B C . D)
A------------------->|CONS|----> (A B C . D)
                   ->|____|
             ____  |
B---------->|CONS|_|
          ->|____|
    ____  |
C->|CONS|_|
D->|____|

2.35 draw the dotted list ((A . B)(C . D))
see book



----
2.18 CIRCULAR LISTS
----
circular lists loop back into the first cons cell
several things can occur depending on certain configurations
the computer may enter an infinite loop
maybe only part of the list prints and ...
(A B C A B C A B C ...)
^^^^^^^^^^^^^^^^^^^^^^^                                                                                                                           
which is incorrect, printing a circular list this way would indicate that the list has more than ten elements while only really containing three (A B C)

sharp-equal notation is the correct way to print a circularly structured list
#1=(A B C . #1#)
if you input this into the REPL, it goes into some weird state i couldnt exit from
to write circular structures, we label the cons cell that refers back to the first cons cell (the cell that closes the loop) (the CDR of the third cons cell in the above example)
#n=( x y z . #n#)


----
EXERCISE
----
2.36 prove by contradiction that #1=(A B C . #1#) cannot be constructed using just CONS
(A) would have to had been CONSed after (B) and (C) which can't happen given the way the list is



----
2.19 LENGTH OF NONLIST CONS STRUCTURES
----
the length of a list is the number of top-level cons cells in the cons cell chain
(A B C . D) -> |LENGTH| -> 3
it is the same length as the chain...until the irregularity essentially...
(A B C . D) = (A B C . NIL)

if lisp is given a circular list, it will fuck up



----
3 EVAL Notation
----


----
3.1 INTRODUCTION
----
instead of boxes, which are easy to visualize and draw (but a pain in the ass to type), we will use EVAL notation (lists)
sophisticated ideas can be expressed in EVAL notation
EVAL notation is easy to type with a keyboard
EVAL notation represents functions as oridinary lists is mathematically elegant --- we can use the exact notation for functions as for data

in lisp functions ARE data

EVAL notation allows us to write functions that accept other functions as input
mastery of EVAL notation lets us actually begin conversing with hardware in LISP



----
3.2 THE EVAL FUNCTION
----
the EVAL function is the heart of lisp
the EVAL function evaluates lisp expressions to compute their inputs

most expressions consist of a
function
followed by a set of
inputs

most expressions consist of a function followed by a set of inputs

(+ 2 3) -> |EVAL| -> 5

instead of shitty boxes

(+ 2 3) => 5

verbosity could be adjusted through the use of 2or3-headed arrows as shown in the book

(* 3 (+ 1 6)) => 21

(/ (* 2 11) (+ 1 6)) => 22/7

titty biscuits



----
3.3 EVAL NOTATION CAN DO ANYTHING BOX NOTATION CAN DO
----
EVAL notation seems to read right-left
EVAL starts at the inner-most expression and works outward
it looks left-right, even in your head it may seem left-right

but its not

EVAL starts at the inner-most expression and works outward



----
3.4 EVALUATION RULES DEFINE THE BEHAVIOR OF EVAL
----
EVAL works by following a set of evaluation rules
numbers and other certain objects are self-evaluating
they evaluate to themselves
23 => 23
t => t
nil => nil
t and nil, our special symbols..they evaluate to themselves

CL-USER> (ODDP (+ 6 1))
T
starting from the inner-most list
6 evaluates to 6
1 evaluates to 1
+ is called on 6 and 1
7 is returned
7 is input to the function ODDP
which returns T

the first element of a list specifies a function to be called
the remaining elements are the unevaluated arguments to the function
these arguments are evaluated in left-right order
to determine the inputs to the function
the function handles the determined inputs according to the evaluation rules of the function
then returns a result

this is the fundamental process of evaluation in lisp

the evaltrace diagram reflects these exact fundamental steps EVAL goes through in order to compute its inputs

look at this one do
CL-USER> (EQUAL (+ 7 5) (* 2 8))
NIL

you were fuckin up the spacing in your nested parenthesis tee-double-yoo


----
EXERCISES
----
3.1 what does (NOT (EQUAL 3 (ABS -3))) evaluate to
NIL
>>>
-3 evaluates to -3
-3 is the input to ABS
3 is returned
>>>
3 evaluates to 3
3 evaluates to 3
3 and 3 are input to the function EQUAL
EQUAL returns T
>>>
T evaluates to T
T is input to NOT
NOT returns NIL
===> this is our evaluation

3.2 write an expression in EVAL notation to add 8 to 12 and divide the result by 2
(/ (+ 8 12) 2)
10

3.3 you can square a number by multiplying it by itself. write an expression in EVAL notation to add the square of 3 and the square of 4
(+ (* 3 3) (* 4 4))
25

3.4 draw an evaltrace diagram for each of the following expressions (just type out the steps)
(- 8 2)
8 evaluates to 8
2 evaluates to 2
8 and 2 are input to -
- returns 6

(not (oddp 4))
4 evaluates to 4
4 is input to oddp
oddp returns nil
nil is input to not
not returns t

(> (* 2 5) 9)
2 evaluates to 2
5 evaluates to 5
2 and 5 are input to *
* returns 10
10 evaluates to 10
9 evaluates to 9
10 and 9 are input to >
> returns T

(not (equal 5 (+ 1 4)))
1 evaluates to 1
4 evaluates to 4
4 and 1 are input to +
+ returns 5
5 evaluates to 5
5 evaluates to 5
5 and 5 are input to equal
equal returns t
t evaluates to t
t is input to not
not returns nil



----
3.5 DEFINING FUNCTIONS IN EVAL NOTATION
----
in EVAL notation we use lists to define functions
in eval notation we refer to the functions argument by giving it a name

lets define the funtion AVERAGE:
(defun average (x y)
  (/ (+ x y) 2.0))

note the floating point number in the definition of our AVERAGE function

DEFUN is a special kind of function
DEFUN is a macro function
DEFUN does not evaluate its arguments
DEFUN is a macro function

since DEFUN does not evaluate its arguments,
arguments do not have to be quoted

DEFUN is used to define other functions
DEFUN is used to define other functions
DEFUN is used to define other functions

the first input to DEFUN is the name of the function being defined
the second input to DEFUN is the argument list; it specifies the names the function will use to refer to its arguments
the remaining inputs to DEFUN define the body of the function; what is actually goin on inside the boxes
DEFUN stand for define function

fist is the name
second is the argument list
remaining is the body of the function

define average in your REPL session next-door
god dammit boy it worked

you just told the machine your definition of average through the language of lisp right now dude

we befeated today la

note: in order to use AVERAGE all-the-time we gotta save it

lets define another :)

define square:
(defun square (n) (* n n))

the correct way to read this function in our heads or aloud is
"DEFUN SQUARE of N, times N N."

almost any symbol except for T or NIL can be used as the name of an argument
x y n are commonly used (lets stick to these simple, common mathematical names as close as possible)
names with tangible meaning are more useful for well defined, specific type tasks
for example a function that computed the total cost of a merchandise order might name its arguments QUANTITY PRICE HANDLING-CHARGE
(defun total-cost (quantity price handling-charge)
  (+ (* quantity  price) handling-charge))

we are gonna break this one down so i know that i know that i understand this
the top portion of our definition is what our inputs will actually be in the REPL (total-cost (x y z)
the next portion is telling us what is actually happening in the first line --- add the product of x y with z

----
EXERCISES
----
3.5 write definitions for HALF CUBE ONEMOREP using DEFUN
HALF
(defun half (n)
  (/ n 2))

CUBE
(defun cube (n)
  (* n n n))

ONEMOREP
(defun onemorep (x y)
 (equal x (+ y 1)))


3.6 Define a function PYTHAG that takes two inputs, x and y, and returns the square root of x^2 + y^2 ... we knows this as pythagoras theorem, this formula results in the length of the hypotenuse of a right triangle given the lengths of the two other sides ... (PYTHAG 3 4) => 5.0 ... note the floating-point number
PYTHAG
(defun pythag (x y)
  (sqrt (+ (* x x) (* y y))))

3.7 define a function MILES-PER-GALLON that takes three inputs, called INITIAL-ODOMETER-READING FINAL-ODOMETER-READING GALLONS-CONSUMED and computes the number of miles traveled per gallon of gas
(defun miles-per-gallon
        (initial-odometer-reading
         final-odometer-reading
         gallons consumed)
  (/ (- final-odometer-reading
        initial-odometer-reading)
    gallons-consumed))

3.8 how would you define SQUARE in box notation
see book



----
3.6 VARIABLES
----
a variable is a place where data is stored

AVERAGE
(average 3 7)
         3 evaluates to 3
         7 evaluates to 7
     enter AVERAGE with inputs 3 and 7
       create variable x with value 3
       create variable y with value 7
         (/ (+ x y) 2.0)
           (+x y)
             x evaluates to 3
             y evaluates to 7
           10
           2.0 evaluates to 2.0
         5.0
       result of average is 5.0
we call average
lisp creates two new variables to hold the inputs for expression reference
these names are x and y

we need to make a clear distinction between variables and symbols
variables are not symbols
variables are named by symbols

functions are named by symbols as well

the value of a variable is the data it holds

blah

rough evaltrace notation
(function arg-1 arg-2 arg-3 ... arg-n)
    


----
3.7 EVALUATING SYMBOLS
----
the names a function uses for its arguments are independent of the names any other function uses

HALF and SQUARE both use n as an argument, but the n being used in HALF is not the same n as the one in SQUARE

evaluation rule for symbols
a symbol evaluates the value of the variable it refers to

outside of HALF and SQUARE --- n refers to the global variable named n or whochever other function it has been assigned

global variable
a variable not associated with any function
pi is a global variable built into common lisp

pi => 3.14159



----
3.8 USING SYMBOLS AND LISTS AS DATA
----
in EVAL notation symbols are used to name variables
(equal x y)

x and y arent assigned values, this fucntion call would give us an error
what we are really trying to do here is compare the symbols themselves
(equal 'x 'y) => nil

(equal 'x 'x) => t

we can tell lisp to treat x y z or whichever symbols as data by putting a quote before each one

without the 'quote lisp interprets the input symbols as variable references

T and NIL are used as data by default and do not need to  be quoted to be used as such
(list 'x t 'y nil 'z) => (X T Y NIL Z)

(defun riddle (x y)
  (list 'a 'b 'c x 'e 'f y))

(riddle 'd 'g) =>
  (a b c d e f g)
whether symbols are used as data in a function definition, or are passed as inputs when the function is called
the symbols must be quoted to prevent evaluation by lisp

lists also need to be quoted to be used as data
(first '(a b c d)) =>
  a

evaluation rule for quoted objects
a quoted object evaluates to the object itself without the quote

(cdr '(a b c d)) =>
  (b c d)

(+ 1 2) =>
  3
'(+ 1 2) =>
  (+ 1 2)



----
3.9 THE PROBLEM OF MISQUOTING
----
lisp will typically tell you when you messed quotes up

(list 'x 'y z) => error! Z unassigned variable
(list 'x 'y 'z) => (x y z)

(cons 'a (b c)) => error! B undefined function
(cons 'a '(b c)) => (a b c)

no shit
when we quote a list the quote must be placed outside of the list to prevent the list from being evaluated



----
3.10 THREE WAYS TO MAKE LISTS
----
we can write a list out directly, using a quote to prevent its evaluation
'(x y z) => (x y z)

we can use LIST or CONS to build a list from individual elements, quoting each argument to the function
(list 'x 'y 'z) => (x y z)
(cons 'x '(y z)) => (x y z)

when we build a list up in lisp
some of the list elements can be computed rather than specified directly
(list 33 'squared 'is (* 33 33))
  =>    (33 squared is 1089)

if we quote a list, nothing inside will get evaluated
'(a b c d) => (a b c d)

remember that you can be a dumbass

double-check quote usage when building lists


----
EXERCISES
----
3.9 the following expressions evaluate without any errors. write down the results.
  (cons 5 (list 6 7))
    =>  (5 6 7)
  
  (cons 5 '(list 6 7))
    =>  (5 LIST 6 7)
    
  (list 3 'from 9 'gives (- 9 3))
    =>  (3 FROM 9 GIVES 6)
    
  (+ (length '(1 foo 2 moo))
     (third '(1 foo 2 moo)))
    =>  6

  (rest '(cons is short for construct))
    =>  (is short for construct)

3.10 the following expressions all result in errors. write down the type of error that occurs, explain how the error arose (for example, missing quote, quote in wrong place . . .) and correct the expression by changing only the quotes
  (third (the quick brown fox))
    =>  error! list coontains unassigned variables

  (list 2 and 2 is 4)
    =>  error! the variable AND is unbound
    
  (+ 1 '(length (list t t t t)))
    =>  error! (length (list t t t t)) not a number - invalid variable

  (cons 'patrick (seymour Marvin))
    =>  marvin and seymour are unbound variables and cannot be evaluaed

  (cons 'patrick (list seymour marvin))
    =>  error! seymour is an unbound variable

3.11 define a perdicate called LONGER-THAN that takes twolists as input and returns T if the first list is linger than the second
LONGER-THAN:
(defun longer-than (x y)
  (> (length x) (length y)))

3.12 write a function ADDLENGTH that takes a list as input and returns a new list with the length of the input added onto the front of it. if the input is (MOO GOO GAI PAN) the output should be (4 MOO GOO GAI PAN) --- what is the result of (ADDLENGTH (ADDLENGTH '(A B C)))?
ADDLENGTH:
(defun addlength (x)
  (cons (length x) x))

(ADDLENGTH (ADDLENGTH '(A B C))) =>
  (4 3 A B C)
the function returns a new list with the lenght of the input added to the front

3.13 study this function definition:
  (defun call-up (caller callee)
    (list 'hello callee 'this 'is caller 'calling))
ok

  how many argumwnts does this function require? what are the names of the arguments?? what is the result of (CALL-UP 'FRED 'WANDA)?
2; caller callee; (CALL-UP 'FRED 'WANDA) => (HELLO WANDA THIS IS FRED CALLING)

3.14 here is a vaaariation on the CALL-UP function from the previous problem. what is the result of (CRANK-CALL 'WANDA 'FRED)?
  (defun crank-call (caller callee)
    '(hello callee this is caller calling))
the entire function body is quoted; this function makes no use of its inputs

----
3.11 FOUR WAYS TO MISDEFINE A FUNCTION
----
the first way
is to put something other than plain, unadorned symbols in the functions argument list

the second way


is to put parenthesis around variables where they appear in the body

the third way is to quote a variale

the fourth way
is to not quote something that should be quoted

----
3.12 MORE ABOUT VARIABLES
----
in lisp a function creates variables automatically when it is invoked
they usually go away when the function returns

(defun double (n) (* n 2))

(double 2) => 4

(defun quadruple (n)
  (double (double n)))


---
EXERCISES
---
3.15 consider the following function paying close attention to the quotes:
(defun scrabble (word)
  (list word 'is 'a 'word))

word is used as an input variable and a quoted variable, it works both ways in the body of this function, tested in the REPL.
(scrabble 'foo) => (FOO IS A WORD)
(scrabble 'aardvark) => (AARDVARK IS A WORD)
(scrabble 'word) => (WORD IS A WORD)

3.16 here is a real confuser:
(defun stooge (larry moe curly)
  (list larry (list 'moe curly) curly 'larry))
what does the following evaluate to? it will help to write down what each variable is bound to --- mind the quotes...
CL-USER> (defun stooge (larry moe curly)
           (list larry (list 'moe curly) curly 'larry))
; in: DEFUN STOOGE
;     (SB-INT:NAMED-LAMBDA STOOGE
;         (LARRY MOE CURLY)
;       (BLOCK STOOGE (LIST LARRY (LIST 'MOE CURLY) CURLY 'LARRY)))
; 
; caught STYLE-WARNING:
;   The variable MOE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
STOOGE

CL-USER> (stooge 'larry 'moe 'curly)
(LARRY (MOE CURLY) CURLY LARRY)
CL-USER>

so ... each name evaluates to itself

(stooge 'moe 'curly 'larry) =>
    (MOE (MOE LARRY) LARRY LARRY)

if it is truly worth it, break down the function into EVAL notation and follow each variable to their evaluation

3.17 why cant the special variables T or NIL be used as variables in a function definition?
T and NIL evaluate to themselves and are constant variables in lisp - they cannot be used to name variables that hold inputs to a function




----
SUMMARY
----
EVAL notation
allows expressions to be interpreted as lists


evaluation rules:

numbers are self-evaluating, meaning they evaluate to themselves --- so do the constant variables T and NIL

when we are evaluating a list
the first element specifies a function to call
the remaining elements specify its arguments
the arguments are evaluated from left to right to derive the inputs that are passed to the function

all symbols other than the first element of a list are interpreted as variable references
a symbol evaluates to the variable it names
exactly which variable a symbol is referring to depends on the context in which the symbol appears
variables that haven t been assigned values cause "unassigned variable" errors when the symbol is evaluated in the REPL

a quoted list or symbol evaluates to itself, without the quote


a list of form --- (DEFUN function-name (argument-list) (function-body) --- defines a function 



----
REVIEW EXERCISES
----
3.18 name two advantages of EVAL notation over box notation
EVAL notation is the true method of conversing with your computer in lisp and is easier to type than box notation

3.19 evaluate each of the following lists. if the list causes an error, tell what the error is. otherwise, write the result of the evaluation.
(cons 'grapes '(of wrath)) => (GRAPES OF WRATH)
(list t 'is 'not nil) => (T IS NOT NIL) --------------------------------->>>LOLOLOOLOLOL
(first '(list moose goose)) => LIST
(first (list 'moose 'goose)) => MOOSE
(cons 'home ('sweet 'home)) => caught ERROR: illegal function call; in - CONS 'HOME ('SWEET 'HOME)

3.20 here is a mystery function:
  (defun mystery (x)
    (list (second x) (first x)))
what result or error is produced by evaluating each of the following?
(mystery '(dancing bear)) => (BEAR DANCING)
(mystery 'dancing 'bear) => ERROR: invalid number of arguments
(mystery '(zowie)) => (NIL ZOWIE)
(mystery (list 'first 'second)) => (SECOND FIRST)

3.21 what is wrong with each of the following function definitions
(defun speak (x y) (list 'all 'x 'is 'y))
two style warnings of the same --- the variable x is defined but never used, the variable y is defined but never used

(defun speak (x) (y) (list 'all x 'is y))
y is fucking it up here --- y is an undefined variable and an undefined function is this function definition, it should be in the x list given the context of the function body

(defun speak ((x y)) (list all 'x is 'y))
unnecessary nested parenthesis around x y; in the function body all and is should be quoted, not x and y

---
FUNCTIONS COVERED IN THIS CHAPTER
---
EVAL - the list evaluator
DEFUN - macro function for defining new functions



----
LISP ON THE COMPUTER
----
been done

----
Lisp Toolkit: ED
----
as you can pleasantly tell, we are using emacs.



---
EXERCISE
---
3.22.a. done

b. (+ 3 5) => 8
(3 + 5) => ERROR: illegal function call
(+ 5 (5 6)) => ERROR: bad form; illegal function call
(+ 3 (* 5 6)) => 33
'(mornin noon night) => (MORNIN NOON NIGHT)
('morning 'noon 'night) => ERROR: peppering quotes throughout the function; bad form
(list 'mornin 'noon 'night) => (MORNIN NOON NIGHT)
(car nil) => NIL
(+ 3 foo) => ERROR: unbound variable in foo
(+ 3 'foo) => ERROR: input type 'foo is not a number - it is a symbol

c. here is MYFUN, a strange function of two inputs:
(myfun 'alpha 'beta) => ((ALPHA) BETA)
write MYFUN ... test its correctness
CL-USER> (defun myfun (x y)
           (list (list x) y))
MYFUN
CL-USER> (myfun 'alpha 'beta)
((ALPHA) BETA)
CL-USER>

d. write predicate FIRSTP that returns T if its first argument (a symbol) is equal to the first element of its second argument (a list). that is, (FIRSTP 'FOO '(FOO BAR BAZ)) should return T. (FIRSTP 'BOING '(FOO BAR BAZ)) should return NIL.
CL-USER> (defun firstp (x y)
           (equal x (first y)))
FIRSTP
CL-USER> (firstp 'foo '(foo bar baz))
T
CL-USER> (firstp 'boing '(foo bar baz))
NIL
CL-USER>

e. write MID-ADD1 that adds 1 to the middle element of a three-element list. for example, (MID-ADD1 '(TAKE 2 COOKIES)) should return the list (TAKE 3 COOKIES). note: you are not allowed to make MID-ADD1 a function of three inputs. it has to take a single input that is a list of three elements.
CL-USER> (defun mid-add1 (x)
           (list (first x)
                 (+ 1 (second x))
                 (third x)))
MID-ADD1
CL-USER> (mid-add1 '(take 2 cookies))
(TAKE 3 COOKIES)
CL-USER>

f. write F-TO-C that converts a temperature from fahrenheit to celsius. the formula for doing the conversion is C=[5x(F-32)]/9    F=(9/5xC)+32
CL-USER> (defun f-to-c (x)
           (/ (* (- x 32) 5) 9))
F-TO-C
CL-USER> (f-to-c 77)
25
CL-USER>

CL-USER> (defun c-to-f (x)
           (+ (* (/ 9 5) x) 32))
C-TO-F
CL-USER> (c-to-f 25)
77
CL-USER>

g. what is wrong with this function? what does (FOO 5) do?
(defun foo (x) (+ 1 (zerop x)))

first off zerop is a predicate and returns t or nil
so t or nil will be fed into the add function

(foo 5) => ERROR: NIL is not a number
basically poop happens




----
3 Advanced Topics
----

----
3.16 FUNCTIONS OF NO ARGUMENTS
----
a function that doesnt take any arguments will have an empty argument list when its definition is being written
that empty list evaluates to NIL
(defun test () (* 85 97))

(test) => 8245
(test 1) => ERROR: too many arguments

test is a function so we must put parenthesis around it to call it --- if we omit them, the symbol TEST is interpreted as a reference to a variable

(test)

...



----
3.17 THE QUOTE SPECIAL FUNCTION
----
QUOTE is a special function
its input does not get evaluated

the quote function returns its input

(quote foo) => FOO

CL-USER> (quote foo)
FOO
CL-USER>

CL-USER> (quote (hello world))
(HELLO WORLD)
CL-USER>

compare
CL-USER> (cons 'up '(down sideways))
(UP DOWN SIDEWAYS)
CL-USER> (cons (quote up) (quote (down sideways)))
(UP DOWN SIDEWAYS)
CL-USER>

using ' is much nicer in my opinion

regardless, internally lisp converts the shorthand apostrophe to QUOTE see ...
CL-USER> 'foo
FOO
CL-USER> ''foo
'FOO
CL-USER> (list 'quote 'foo)
'FOO
CL-USER> (first ''foo)
QUOTE
CL-USER> (rest ''foo)
(FOO)
CL-USER> (length ''foo)
2
CL-USER>

in our version of lisp ' and QUOTE are used in different contexts
...slick



----
3.18 INTERNAL STRUCTURE OF SYMBOLS
----
symbols in common lisp are composite objects
they have several parts to them

conceptually
a symbol is a block of five pointers

one of which points to the representation of the symbols name

"FRED" is a string

strings are sequences of characters

know that strings are used to store the names of symbols
a symbol and its name are actually two different things

CONS and + are used to name built-in lisp functions
the symbol CONS has a pointer in its function cell to a "compiled code object" that represents the machine language instructions for creating new cons cells

---
name ----> "FRED"
---

---
fucntion ----> %compiled CONS function% i.e. the compiled code object
---

---

---

(the thing above is going to represent our five pointer symbol block when we feel the need to visualize)

the compiled code object in the CONS five pointer symbol block represents machine language instructions for creating new cons cells

we can view the compiled code object using SYMBOL-NAME and SYMBOL-FUNCTION functions within lisp
CL-USER> (symbol-name 'equal)
"EQUAL"
CL-USER> (symbol-function 'equal)
#<FUNCTION EQUAL>
CL-USER>



----
3.19 LAMBDA NOTATION
----
; SLIME 2.24
CL-USER> (lambda (x) (+ 3 x))
#<FUNCTION (LAMBDA (X)) {1003CF1DBB}>
CL-USER>

LAMBDA is not a function
LAMBDA is a marker treated specially by EVAL

when creating a new function definition like HALF
there are two types of naming going on

the string "HALF" names the symbol
the symbol HALF names the function

the symbol HALF (the one that names the function) (aka HALFs function cell)
points to a function object that is the actual function

the actual function (the one the function object points to)
is ofcourse just a list constructed out of cons cells as with everything else in lisp

this list of cons cells is a lambda expression

the symbols within the lambda expression are each their own blocks of five pointers

see figure 3.1 p108 in the book for the cons cell representation with five-pointer blocks drawn out


---
EXERCISE
---
3.23 write each of the following functions in lambda notation
DOUBLE
lambdan. nx2

SQUARE
lambdan. nxn

ONEMOREP
lambda(x,y). x=(y+1)



----
3.20 SCOPE OF VARIABLES
----
the scope of a variable is the region it may be referenced

n has a scope local to HALF within the context of that function

global variables ... n the global variable ... have an unbound scope that may be referenced anywhere within lisp


---
EXERCISE
---
3.24 assume we have defined the following functions
(defun alpha (x)
  (brave (+ x 2) (charlie x 1)))

(defun bravo (y z) (* y z))

(defun charlie (y x) (- y x))

first we define charlie and bravo
then alpha
in the REPL

CL-USER> (defun charlie (y x) (- y x))
CHARLIE
CL-USER> (defun bravo (y z) (* y z))
BRAVO
CL-USER> (defun alpha (x)
           (bravo (+ x 2) (charlie x 1)))
WARNING: redefining COMMON-LISP-USER::ALPHA in DEFUN
ALPHA
CL-USER> (alpha 3)
10
CL-USER>

see book for evaltrace ...



----
3.21 EVAL AND APPLY
----
EVAL is a lisp primitive function
each use of EVAL gives one level of evaluation

CL-USER> '(+ 2 2)
(+ 2 2)
CL-USER> (eval '(+ 2 2))
4
CL-USER> '''boing
''BOING
CL-USER> (eval '''boing)
'BOING
CL-USER> (eval (eval '''boing))
BOING
CL-USER> (eval (eval (eval '''boing)))
; Evaluation aborted on #<UNBOUND-VARIABLE BOING {1004C70913}>.
CL-USER> 
; No value
CL-USER> '(list '* 9 6)
(LIST '* 9 6)
CL-USER> (eval '(list '*9 6))
(*9 6)
CL-USER> (eval (eval '(list '* 9 6)))
54
CL-USER>

we arent going to call EVAL in our programs
we just need to understand whats going on here

APPLY is also a lisp primitive function
APPLY takes a function and a list of objects as input

APPLY invokes the specified function with those objects as its inputs

the first argument to APPLY should be quoted with #' rather than an ordinary quote

#' is the proper way to quote functions supplied as inputs to other functions

CL-USER> (apply #'+ '(2 3))
5
CL-USER> (apply #'equal '(12 17))
NIL
CL-USER>

we see that APPLY can be used as a passive method when evaluating a function

CL-USER> (apply #'cons '(as (you like it)))
(AS YOU LIKE IT)
CL-USER>


---
EXERCISE
---
3.25 what do each of the following expressions evaluate to
CL-USER> (list 'cons t nil)
(CONS T NIL)
CL-USER> (eval (list 'cons t nil))
(T)
CL-USER> (eval (eval (list 'cons t nil)))
; in: T
;     (T)
; 
; caught WARNING:
;   The function T is undefined, and its name is reserved by ANSI CL so that even
;   if it were defined later, the code doing so would not be portable.
; 
; compilation unit finished
;   Undefined function:
;     T
;   caught 1 WARNING condition
; Evaluation aborted on #<UNDEFINED-FUNCTION T {100515C2A3}>.
CL-USER> (apply #'cons '(t nil))
(T)
CL-USER> (eval nil)
NIL
CL-USER> (list 'eval nil)
(EVAL NIL)
CL-USER> (eval (list 'eval nil))
NIL
CL-USER>


FUNCTIONS COVERED IN ADVANCED TOPICS
EVAL-related function: APPLY
EVAL (used explicitly)
special function: QUOTE



----
4 Conditionals
----

----
4.1 INTRODUCTION
----
all non-trivial programs make decisions

conditionals are special decision-making functions that choose their result from among a set of alternatives based on the value of one or more predicate expressions

a predicate expression is an expression whose value is interpreted as true or false --- no shit

conditionals allow functions to vary their behaviour for different sorts of inputs

we can construct our own predicate expressions to control conditionals then write functions that make arbitrarily complex decisiions



----
4.2 THE IF SPECIAL FUNCTION
----
IF is the simplest lisp conditional

conditionals are always macros or special functions
their arguments do not get evaluated automatically

oridinary functions like + and CONS always evaluate their arguments

the IF special function takes three arguments
test
true-part
false-part

if the test is true --- IF returns the value of the true part
if the test is false --- IF returns the value of the false part

CL-USER> (if (oddp 1) 'odd 'even)
ODD
CL-USER> (if (oddp 2) 'odd 'even)
EVEN
CL-USER> (if t 'test-was-true 'test-was-false)
TEST-WAS-TRUE
CL-USER> (if nil 'test-was-true 'test-was-false)
TEST-WAS-FALSE
CL-USER> (if (symbolp 'foo) (* 5 5) (+ 5 5))
25
CL-USER> (if (symbolp 1) (* 5 5) (+ 5 5))
10
CL-USER>

we can use IF to construct a function that takes the absolute value of a number

absolute values are always non-negative
for negative numbers the absolute value is the negation of the number
for positive numbers and zero the absolute value is the number itself

we want to stay out of lisps way as much as possible

lets call our absolute value function MY-ABS

CL-USER> (defun my-abs (x)
           (if (< x 0) (- x) x))
MY-ABS
CL-USER> (my-abs -5)    ; true-part takes the negation
5
CL-USER> (my-abs 5)    ; false-part returns the number unchanged
5
CL-USER>

lets create another decision-making function
SYMBOL-TEST returns a message telling whether or not its input is a symbol

(defun symbol-test (x)
  (if (symbolp x) (list 'yes x 'is 'a 'symbol)
      (list 'no x 'is 'not 'a 'symbol)))

when reading this function definition ...
"if symbolp of x then ... else ..."

CL-USER> (defun symbol-test (x)
           (if (symbolp x) (list 'yes x 'is 'a 'symbol)
               (list 'no x 'is 'not 'a 'symbol)))
SYMBOL-TEST
CL-USER> (symbol-test 'rutabaga)
(YES RUTABAGA IS A SYMBOL)
CL-USER> (symbol-test 1234)
(NO 1234 IS NOT A SYMBOL)
CL-USER>

IF can be given two inputs instead of three
in this context IF treats its third-input (false-part) as NIL

CL-USER> (if t 'happy)
HAPPY
CL-USER> (if nil 'happy)
NIL
CL-USER>


---
EXERCISES
---
4.1 write a function MAKE-EVEN that makes an odd number even by adding one to it. if the input to MAKE-EVEN is already even, it should be returned unchanged.
uncertain what the difference is...
yours truly defined make-even-a
the answer key provided make-even-b...
CL-USER> (defun make-even-a (n)
           (if (oddp n) (+ n 1) n))
MAKE-EVEN-A
CL-USER> (defun make-even-b (n)
           (if (evenp n) n
               (+ n 1)))
MAKE-EVEN-B
CL-USER> (make-even-a 3)
4
CL-USER> (make-even-b 3)
4
CL-USER> (make-even-a 2)
2
CL-USER> (make-even-b 2)
2
CL-USER> 

4.2 write a function FURTHER that makes a positive number by adding one to it, and a negative number smaller by subtracting one from it. what does your function do if given the number 0?
CL-USER> (defun further (n)
           (if (< n 0)
               (- n 1)
               (+ n 1)))
FURTHER
CL-USER> (further 3)
4
CL-USER> (further -3)
-4
CL-USER> (further 0)
1
CL-USER> (further -0)
1
CL-USER> 

4.3 recall the primitive function NOT: it returns NIL for a true input and T for a false one. suppose lisp didnt have a NOT primitive. show how to write NOT using just IF and constants (no other functions). call your function GNOT
CL-USER> (defun gnot (x)
           (if x nil t))
GNOT
CL-USER> 

4.4 write a function ORDERED that takes two numbers as input and makes a list of them in ascending order. (ORDERED 3 4) should return the list (3 4). (ORDERED 4 3) should also return (3 4).
CL-USER> (defun ordered (x y)
           (if (< x y)
               (list x y)
               (list y x)
ORDERED
CL-USER> (ordered 4 5)
(4 5)
CL-USER> (ordered 5 4)
(4 5)
CL-USER> (ordered 3 7)
(3 7)
CL-USER> (ordered 7 3)
(3 7)
CL-USER>



----
4.3 THE COND MACRO
----
COND is the calssic lisp conditional
its input consists of any number of test-and-consequent clauses
a simplified form of a COND expression:
(COND (test-1 consequent-1)
      (test-2 consequent-2)
      (test-3 consequent-3)
           ....
      (test-n consequent-n))

COND works like this:
COND works sequentially through the clauses
if the test-part of the clause evaluates to true -> COND evaluates the consequent part and returns its value
if the test evaluates to false -> COND skips the consequent part and examines the next clause
if all clauses return false values COND returns NIL

we can use COND to write a function COMPARE that will compare two numbers
if the numbers are equal, COMPARE will say "numbers are the same"
if the first number is less than the second, COMPARE will say "first is smaller"
if the first number is greater than the second, COMPARE will say "first is bigger"

CL-USER> (defun compare (x y)
           (cond ((equal x y) 'numbers-are-the-same)
                 ((< x y) 'first-is-smaller)
                 ((> x y) 'first-is-bigger)))
COMPARE
CL-USER>

this is a four element list --- the symbol COND being the first element --- test-and-conswequent clauses remain
the first clause is a two-element list whose first element is the expression (EQUAL X Y) --- this is the test-part of the clause
the second element (the consequent part) is the quoted symbol 'NUMBERS-ARE-THE-SAME

CL-USER> (compare 3 5)
FIRST-IS-SMALLER
CL-USER> (compare 7 2)
FIRST-IS-BIGGER
CL-USER> (compare 4 4)
NUMBERS-ARE-THE-SAME
CL-USER>


---
EXERCISE
---
4.5 for each of the following calls to COMPARE, write "1" "2" or "3" to indicate which clause will have a predicate that evaluates to TRUE
3 2 1 (see book)


COND and IF are similar functions
COND can be useful in some ways accepting any number of clauses
although IFs can be nested within functions to produce the same result



----
4.4 USING T AS A TEST
----
standard trick for using COND is to include a clause of form

(T consequent)

T is always true
we can put this clause at the end of a COND function definition to guarantee its evaluation

the following function returns the  country in which a given city is. if the function doesnt know a particular city, it returns the symbol UNKNOWN

CL-USER> (defun where-is (x)
           (cond ((equal x 'paris) 'france)
                 ((equal x 'london) 'england)
                 ((equal x 'beijing) 'china)
                 (t 'unknown))

(where-is 'london) => england
(where-is 'nutsackington) => unknown

remember the fundamental structure of IF:
(IF test true-part false-part)

we can translate any IF expression into a COND expression using two clauses:
(COND (test true-part)
      (T false-part)


---
EXERCISE
---
4.6 write a version of the absolute value function MY-ABS using COND instead of IF
MY-ABS-COND:
(defun my-abs-cond (n)
  (cond ((< n 0) (- n))
        (t n)))

CL-USER> (my-abs-cond -3)
3
CL-USER> (my-abs-cond 3)
3
CL-USER>



----
4.5 TWO MORE EXAMPLES OF COND
----
here is a function called EMPHASIZE that changes the first word of a phrase from good to great or from bad to awful and returns the modified phrase

(defun emphasize (x)
  (cond ((equal (first x) 'good) (cons 'great (rest x)))
        ((equal (first x) 'bad) (cons 'awful (rest x)))))

CL-USER> (emphasize '(good mystery story))
(GREAT MYSTERY STORY)
CL-USER>

EMPHASIZE takes (GOOD MYSTERY STORY) as x
the COND within the EMPHASIZE function definition body starts going through test-and-consequent clauses
two of them to be exactlyd

((equal (first x) 'good) (cons 'great (rest x)))

since (FIRST X) evaluates to GOOD, the test part of this clause is true
the consequent part then constructs a new list from the symbol GREAT and the REST of the input (which is X)
returninggggggg
CL-USER> (emphasize '(good mystery story))
(GREAT MYSTERY STORY)
CL-USER>

so what happens when we use a symbol outside what is defined in our function definition
CL-USER> (emphasize '(mediocre mystery story))
NIL
CL-USER>
... lossage

what if we want more than NIL returned to us when our function cant figure how to do its job from an input ...

... we simply use a T-as-test trick

(defun emphasizetoo (x)
  (cond ((equal (first x) 'good) (cons 'great (rest x)))
        ((equal (first x) 'bad) (cons 'awful (rest x)))
        (t x)))

if the COND reaches the last clause, the test is guaranteed to evaluate to true and the input x is returned

CL-USER> (emphasizetoo '(bad day))
(AWFUL DAY)
CL-USER> (emphasizetoo '(good day))
(GREAT DAY)
CL-USER> (emphasizetoo '(babygirl day))
(BABYGIRL DAY)

lets build a function COMPUTE that takes three inputs
the first input is the symbol SUM-OF --- the function returns the sum of the second and third inputs
if it is the symbol PRODUCT-OF --- the function returns the product of the second and third inputs
otherwise it returns the list (THAT DOES NOT COMPUTE)

(defun compute (op x y)
  (cond ((equal op 'sum-of) (+ x y))
        ((equal op 'product-of) (* x y))
        (t '(that does not compute))))

lets see the COMPUTE function we just built in action

CL-USER> (compute 'sum-of 3 7)
10
CL-USER> (compute 'product-of 2 4)
8
CL-USER> (compute 'stephen-of 3 1)
(THAT DOES NOT COMPUTE)



----
4.6 COND AND PARENTHESIS ERRORS
----
most COND clauses begin with exactly two parenthesis
the first parenthesis marks the beginning of the  clause
the second marks the beginning of the clauses test

if the test part of a clause is just a symbol and not a call to a function --- then the clause should begin with a single parenthesis


---
EXERCISES
---
4.7 for each of the following COND expressions, tell whether the parenthesization is correct or incorrect. explain the error if incorrect

incorrect --- not enough parenthesis
correct
incorrect --- too many parenthesis
incorrect --- too many parenthesis


4.8 write EMPHASIZETHREE, adding VERY onto the list of unemphasizeable variables

CL-USER> (defun emphasizethree (x)
           (cond ((equal (first x) 'good)
                  (cons 'great (rest x)))
                 ((equal (first x) 'bad)
                  (cons 'awful (rest x)))
                 (t (cons 'very x))))
EMPHASIZETHREE
CL-USER> (emphasizethree '(long day))
(VERY LONG DAY)
CL-USER> (emphasizethree '(very long day))
(VERY VERY LONG DAY)


4.9 type in the following suspicious function definition

(defun make-odd (x)
  (cond (t x)
        ((not (oddp x)) (+ x 1))))
what is wrong with this function
try the function with 3 4 -2
write it again until it works correctly

CL-USER> (defun make-odd (x)
           (cond ((not (oddp x)) (+ x 1))
                 (t x)))
MAKE-ODD
CL-USER> (make-odd 2)
3
CL-USER> (make-odd 3)
3


4.10 write CONSTRAIN --- takes three inputs called X MAX MIN
if X is less than MIN, it should return MIN
if X is greater than MAX, it should return MAX
if X is between MIN and MAX, it should return X
write another version using nested IFs

CL-USER> (defun constrain (x min max)
           (cond ((< x min) min)
                 ((> x max) max)
                 (t x)))
CONSTRAIN
CL-USER> (constrain 3 -50 50)
3
CL-USER> (constrain 92 -50 50)
50
CL-USER> (defun constraif (x min max)
           (if (< x min) min
               (if (> x max) max
                   x)))
CONSTRAIF
CL-USER> (constraif 3 -50 50)
3
CL-USER> (constraif 92 -50 50)
50


4.11 write FIRSTZERO that takes a list of three numbers as input and returns a word (one of "first" "second" "third" "none") indicating where the first zero appears in the list
what happens if you call FIRST zero with three separate numbers instead of a list with three numbers

CL-USER> (defun firstzero (x)
           (cond ((zerop (first x)) 'first)
                 ((zerop (second x)) 'second)
                 ((zerop (third x)) 'third)
                 (t 'none)))
FIRSTZERO

CL-USER> (firstzero '(0 1 2))
FIRST
CL-USER> (firstzero '(2 0 3))
SECOND
CL-USER> (firstzero '(3 4 0))
THIRD
CL-USER> (firstzero '(1 1 1))
NONE

CL-USER> (firstzero 0 1 2)
; Evaluation aborted on #<SB-INT:SIMPLE-PROGRAM-ERROR "invalid number of arguments: ~S" {1002A962F3}>.


4.12 write CYCLE --- cyclically counts from 1 to 99
CYCLE called with an input of 1 should return 2
... with an input of 2 -> 3
... with an input of 3 -> 4
with an input of 99 -> 1
... thats the cyclical part
dont try and solve this with 99 COND clauses

CL-USER> (defun cycle (n)
           (cond ((equal n 99) 1)
                 (t (+ n 1))))
CYCLE
CL-USER> (cycle 1)
2
CL-USER> (cycle 3)
4
CL-USER> (cycle 4)
5
CL-USER> (cycle 99)
1
CL-USER> (cycle 100)
101


4.13 write a function HOWCOMPUTE that is the inverse of COMPUTE
HOWCOMPUTE takes three numbers as input and returns the operation that would be used to determine the third number from the first twolists
extend this function

CL-USER> (defun howcompute (x y z)
           (cond ((equal (+ x y) z) 'sum-of)
                 ((equal (* x y) z) 'product-of)
                 (t '(beats me))))
WARNING: redefining COMMON-LISP-USER::HOWCOMPUTE in DEFUN
HOWCOMPUTE
CL-USER> (howcompute 5 5 10)
SUM-OF
CL-USER> (howcompute 5 5 25)
PRODUCT-OF


----
4.7 THE AND OR MACROS
----
SMALL-POSITIVE-ODDP takes a small two-digit number as input
this complex function should return T for an odd number and NIL for an even number
AND is a macro that can express the simple conditions of this function:
CL-USER> (defun small-positive-oddp (x)
           (and (< x 100)
                (> x 0)
                (oddp x)))
SMALL-POSITIVE-ODDP
CL-USER> (small-positive-oddp 63)
T
CL-USER> (small-positive-oddp 44)
NIL

AND and OR are macros that can be used to construct complex predicates from simple ones

OR is used for disjunctions
disjunctions are sets that take multiple arguments and return T if any one input returns T during evaluation

GTEST takes two numbers as input and returns T if either the first is greater than the second or if one of the inputs is zero:
(defun gtest (x y)
  (or (> x y)
      (zerop x)
      (zerop y)))



----
4.8 EVALUATING AND AND OR
----
the rule for evaluating AND:
evaluate the clauses one at a time
if a clause returns NIL
stop and return NIL
otherwise move to the next clause
if all clauses yield non-NIL results
return the value of the last clause

CL-USER> (and nil t t)
NIL
CL-USER> (and 'george nil 'harry)
NIL
CL-USER> (and 'george 'fred 'harry)
HARRY
CL-USER> (and 1 2 3 4 5)
5

the rule for evaluating OR:
evaluate the clauses one at a time
if a clause returns something other than NIL
stop and return that value
otherwise go on to the next clause
return NIL if no clauses remain

CL-USER> (or nil t t)
T
CL-USER> (or 'george nil 'harry)
GEORGE
CL-USER> (or 'george 'fred 'harry)
GEORGE
CL-USER> (or nil 'fred 'harry)
FRED


---
EXERCISE
---
see book

AND is NIL
OR isnt



----
4.9 BUILDING COMPLEX PREDICATES
----
HOW-ALIKE is a function that compares two numbers to determine similarities between them
HOW-ALIKE uses AND to construct complex predicates as part of a COND clause

CL-USER> (defun how-alike (a b)
           (cond ((equal a b) 'the-same)
                 ((and (oddp a) (oddp b)) 'both-odd)
                 ((and (not (oddp a)) (not (oddp b))) 'both-even)
                 ((and (< a 0) (< b 0)) 'both-negative)
                 (t 'not-alike)))
HOW-ALIKE
CL-USER> (how-alike 7 7)
THE-SAME
CL-USER> (how-alike 3 5)
BOTH-ODD
CL-USER> (how-alike -2 -3)
BOTH-NEGATIVE
CL-USER> (how-alike 5 8)
NOT-ALIKE

the SAME-SIGN predicate uses a combination of AND and OR to test if its two inputs have the same sign

CL-USER> (defun same-sign (x y)
           (or (and (zerop x) (zerop y))
               (and (< x 0) (< y 0))
               (and (> x 0) (> y 0))))
SAME-SIGN
CL-USER> (same-sign 0 0)
T
CL-USER> (same-sign -3 -4)
T
CL-USER> (same-sign 3 4)
T
CL-USER> (same-sign -3 4)
NIL


---
EXERCISES
---
4.15 write a predicate called GEQ that returns T if its first input is greater than or equal to its second input
GEQ:
(defun geq (x y)
  (or (> x y) (equal x y)))

4.16 write a function that squares a number if it is odd and positive, doubles it if it is odd and negative, and otherwise divides the number by twolists
CL-USER> (defun crunch (n)
           (cond ((and (oddp n) (> n 0)) (* n n))
                 ((and (oddp n) (< n 0)) (* n 2))
                 (t (/ n 2))))
CRUNCH

4.17 write a predicate that returns T if the first input is either BOY or GIRL and the second input is CHILD, or the first input is either MAN or WOMAN and the second input is ADULT
AGE:
(defun age (x y)
 (or (and (or (equal x 'boy) (equal x 'girl)) (equal y 'child))
     (and (or (equal x 'man) (equal x 'woman)) (equal y 'adult))))

********
4.18 write a function to act as a referee in the rock-paper-scissors game.
each player chooses one of rock paper or scissors
after selection each player reveals their choice to another
rock > scissors
scissors > paper
paper > rock
tie
the function PLAY should take two inputs
the two inputs could be rock paper or scissors each
FIRST-WINS SECOND-WINS TIE should be returned based on the given inputs

CL-USER> (defun play (x y)
           (cond ((equal x y) 'tie)
                 ((or (and (equal x 'rock)
                           (equal y 'scissors))
                      (and (equal x 'scissors)
                           (equal y 'paper))
                      (and (equal x 'paper)
                           (equal y 'rock)))
                  'first-wins)
                 (t 'second-wins)))
PLAY

lets break this function down and understand whats actually going on here:

*** note: if X returns T through EQUAL and Y returns F through EQUAL => SECOND-WINS ***

we are defining the function PLAY that takes two inputs
taking two conditional arguments
conditional argument one states that if X and Y return T from EQUAL --- TIE is returned
...
if not
...
conditional argument two calls OR with a combination of ANDs to make a desision
if the first AND returns T (X equals ROCK and Y equals SCISSORS) => FIRST-WINS is returned
if X returns NIL through EQUAL ...
move to the next AND
if the second AND returns T (X equals SCISSORS and Y equals PAPER) => FIRST-WINS is returned
if X returns NIL through EQUAL ...
move to the next AND
if the third AND returns T (X equals PAPER and Y equals ROCK) => FIRST-WINS is returned
if Y returns NIL from any of the nested AND clauses the function returns SECOND-WINS
********



----
4.10 WHY AND AND OR ARE CONDITIONALS
----
AND and OR are not required to evaluate every clause provided
AND and OR are conditionals because they are not required to evaluate all of the clauses provided to them

if any clause in an AND conditional returns NIL
the remaining clauses do not get evaluated

if any clause in an OR conditional returns non-NIL
the remaining clauses do not get evaluated

lisp programmers can use this property to avoid errors by halting evaluation ...

POSNUMP (correct):
CL-USER> (defun posnump (x)
           (and (numberp x) (plusp x)))
POSNUMP
CL-USER> (posnump 7)
T
CL-USER> (posnump -4)
NIL
CL-USER> (posnump 'abc)
NIL
...
BOGOSNUMP (incorrect POSNUMP):
CL-USER> (defun bogosnump (x)
           (and (plusp x) (numberp x)))
BOGOSNUMP
CL-USER> (bogosnump 7)
T
CL-USER> (bogosnump -4)
NIL
CL-USER> (bogosnump 'abc)
; Evaluation aborted on #<TYPE-ERROR expected-type: NUMBER datum: ABC>.


POSNUMP and BOGOSNUMP contain the same internal parts
the arrangement of their nested functions is inverted

POSNUMP invokes NUMBERP before PLUSP allowing the function to follow through with a return value
BOGOSNUMP invokes PLUSP before NUMBERP ... PLUSP is not equipped to handle symbols



----
4.11 CONDITIONALS ARE INTERCHANGEABLE
----
POSNUMP could be written with AND IF or COND

\\\\\
POSNUMPAND:
CL-USER> (defun posnumpand (x)
           (and (numberp x) (> x 0)))

POSNUMPAND test for a number first
if T
it tests if the number is greater than zero and returns T or NIL
\\\\\
POSNUMPIF:
CL-USER> (defun posnumpif (x)
           (if (numberp x) (> x 0) nil))

POSNUMPIF tests for a number first
if T
the true-part of the IF evaluates (> X 0)
if the number test fails
the false-part of IF is NIL
\\\\\
POSNUMPCOND:
CL-USER> (defun posnumpcond (x)
           (cond ((numberp x) (> x 0))
                 (t nil)))

POSNUMPCOND tests for a number
test if greater than zero
evaluates the resulting T or NIL with the remaining T and NIL arguments ...
which evaluate to themselves
/

\\\\\
WHERE-IS can be defined with CONDs IFs ORs ANDs

WHERE-COND:
CL-USER> (defun where-cond (x)
           (cond ((equal x 'paris) 'france)
                 ((equal x 'london) 'england)
                 ((equal x 'beijing) 'china)
                 (t 'unknown)))

WHERE-IF:
CL-USER> (defun where-if (x)
           (if (equal x 'paris) 'france
               (if (equal x 'london) 'england
                   (if (equal x 'beijing) 'china
                       'unknown))))

WHERE-OR:
CL-USER> (defun where-or (x)
           (or (and (equal x 'paris) 'france)
               (and (equal x 'london) 'england)
               (and (equal x 'beijing) 'china)))

WHERE-COND has four clauses
__
WHERE-IF has three nested IFs

WHERE-IF traced:
CL-USER> (trace where-if)
(WHERE-IF)
CL-USER> (where-if 'beijing)
  0: (WHERE-IF BEIJING)
  0: WHERE-IF returned CHINA
CHINA
CL-USER> (untrace where-if)
T

WHERE-IF fieldevaltrace:
(where-if 'beijing)
  enter WHERE-IF; input BEIJING
  X is BEIJING
    first IF clause
      NIL
      second IF clause
        NIL
        third IF clause
        (if (equal x 'beijing) 'china) 'unknown)
          (equal x 'beijing)
          T
          'china
          CHINA
        CHINA
      CHINA
    CHINA
  WHERE-IF returns CHINA
___
WHERE-OR only has two-levels; fieldevaltrace:
(where-or 'beijing)
  enter WHERE-OR; input BEIJING
  X is BEIJING
    OR
      first AND clause
        NIL
      second AND clause
        NIL
      third AND clause
      (and (equal x 'beijing) 'china) 'unknown)
        (equal x 'beijing)
        T
        'china
        CHINA
      CHINA
    CHINA
  WHERE-OR returns CHINA

IF COND AND/OR are interchangeable conditionals
IF is best for simpler functions
AND/OR are good for writing complex predicates
COND is useful for testing multiple clauses within the function definition


---
EXERCISES
---
4.19 write (AND X Y Z W) using COND and nested IFs instead of AND

(cond ((not x) nil)
      ((not y) nil)
      ((not z) nil)
      (t w))

(if x
  (if y
    (if z w)))

(or (and (x))
    (and (y)
     w))

4.20 write COMPARE with IF and AND/OR

COMPIF:
(defun compif (x y)
  (if (equal x y)
      'numbers-are-the-same
      (if (< x y)
          'first-is-smaller
          'first-is-bigger)))

COMPAND:
(defun compand (x y)
  (or (and (equal x y) 'numbers-are-the-same)
      (and (< x y) 'first-is-smaller)
      'first-is-bigger))

4.21 write GTEST with IF and COND

GTEST:
(defun getest (x y)
  (or (< x y)
      (zerop x)
      (zerop y)))

GIFTEST:
(defun giftest (x y)
  (if (> x y) t
      (if (zerop x) t
          (zerop y))))

GONDTEST:
(defun gondtest (x y)
  (cond ((> x y) t)
        ((zerop x) t)
        (t (zerop y))))

4.22 write BOILINGP with COND IF and AND/OR ... takes two inputs TEMP SCALE; returns T if above boiling point of water on scale; if fahrenheit (212 degrees) celsius (100)

F-TO-C:
(defun f-to-c (x)
  (/ (* (- x 32) 5) 9))

C-TO-F:
(defun c-to-f (x)
  (+ (* (/ 9 5) x) 32))

BOILINGP:
(defun boilingp (temp scale)
  (or (and (> temp 212)
           (equal scale 'fahrenheit))
      (and (> temp 100)
           (equal scale 'celsius))))

4.23 if WHERE-IS had eight COND clauses how many IFs would it need ... how many ORs would the new version need ...
7 IFs ... 1 OR 7 ANDs


---
SUMMARY
---
conditionals allow a computer to make decisions that control its behaviour

(IF condition true-part false-part)

COND accepts a set of test-and-consequent clauses as input and evaluates each clause until one returns T
COND returns the value of the T clause
if there is no T clause - NIL

AND evaluates one clause at a time until one returns NIL
AND returns NIL upon its discovery
if all clauses evaluate to T
AND returns the value of the last clause

OR evaluates clauses until a non-NIL value is found
OR returns the value of the non-NIL clause
if all clauses evaluate to NIL
NIL

AND and OR are not considered predicates because they are not ordinary functions

when writing COND expressions ...
place a list of form (t consequent) as the final clause

conditionals do not have to evaluate all of their inputs
this assists in error prevention and can act as a buffer between more sensitive expressions

conditionals can do the things they do because they are either macros or special functions

---
REVIEW EXERCISES
---
4.24 why are conditionals important
conditionals are not required to evaluate all of their inputs, this can be used to place buffers between other functions and other error prevention techiniques

4.25 what does IF do if given two inputs instead of three
IF will return the value of the second input

4.26 COND can accept any number of clauses, but IF takes at most three inputs. how can COND be rewritten in IFs
nested IFs

4.27 what does COND evaluate to
NIL

4.28 IF can usually be rewritten as a combination of AND plus OR -- replace (IF test true-part false-part) -> (OR (AND test true-part) false-part)
(IF (ODDP 5) (EVENP 7) 'FOO) fails evaluation, why ... rewrite IF as a combination of ANDs and ORs

once IF determines that the test part is true, it will always return the value of the true-part (even if NIL)
REWRIFEN:
(OR (AND test true-part)
    (AND (not test) false-part))

conditionals: IF COND AND OR
predicate: PLUSP



----
LISP TOOLKIT: STEP
----
STEP takes the programmer through an interactive evaluation of a lisp expression

look into it later ...



----
4 ADVANCED TOPICS
----
----
4.12 BOOLEAN FUNCTIONS
----
boolean functions take and return truth values (T NIL)
boolean logic is the modern way of describing the behaviour of computer circuits

another name for boolean functions -- logical function

true and false are logical values

-reminder-
AND evaluates one clause at a time until one returns NIL
AND returns NIL upon its discovery
if all clauses evaluate to T
AND returns the value of the last clause
- ... -

LOGICAL-AND:
CL-USER> (defun logical-and (x y) (and x y t))
LOGICAL-AND

this LOGICAL-AND fucntion differs from the AND macro
LOGICAL-AND takes exactly two inputs
LOGICAL-AND only returns the logical values T NIL

CL-USER> (logical-and 'tweet 'woof)
T
CL-USER> (and 'tweet 'woof)
WOOF

LOGICAL-AND is not a macro ...
it cannot control whether or not its arguments get evaluated

CL-USER> (and (numberp 'fred) (oddp 'fred))
NIL
CL-USER> (logical-and (numberp 'fred) (oddp 'fred))
; Evaluation aborted on #<TYPE-ERROR expected-type: INTEGER datum: FRED>.

AND returns the value of the first clause (NIL)
the second clause is never evaluated

LOGICAL-AND picks up an irregular data type input  error on second clause -- (oddp 'fred)
AND never evaluates (oddp 'fred), therefore AND doesn't pick up the error

boolean functions are simpler than conditionals

boolean functions in lisp directly correspond with boolean functions in electronics

boolean functions are the primitive logical operations from which computer circuitry is built


---
EXERCISES
---
(4.29) write versions of LOGICAL-AND using IF and COND instead of AND

LOGICAL-IF:
(defun logical-if (x y)
  (if x (if y t)))

LOGICAL-COND:
(defun logical-cond (x y)
  (cond (x (cond (y t)))))


(4.30) write LOGICAL-OR -- T NIL only return values

LOGICAL-OR:
(defun logical-or (x y)
  (cond (x t)
        (y t)
        (t nil)))


(4.31) is NOT a conditional ... is it a boolean function ... do we need to write a LOGICAL-NOT function

no, NOT always evaluates its input
yes, NOT returns T or NIL
no





----
4.13 TRUTH TABLES
----
truth tables are a convenient way to describe boolean funcitons

a truth table in lisp is a table of all possible combinations of T or NIL inputs and their return values within a function


---
EXERCISES
---
4.32 truth table for LOGICAL-OR

x  y  (LOGICAL-OR X Y)
T  T  T
T  N  T
N  T  T
N  N  M


4.33 write LOGICAL-IF that takes three inputs ... how many lines in the truth table

LOGICAL-IFFF:
(defun logical-ifff (x y z)
  (if x (if y (if z t))))

there will be 2^3 lines on LOGICAL-IFFFs truth table


4.34 write down the truth table for LOGICAL-IFFF

LOGICAL-IFFF:
X  Y  Z  (LOGICAL-IF x y z)
T  T  T  T
T  T  N  T
T  N  T  N
T  N  N  N
N  T  T  T
N  T  N  N
N  N  T  T
N  N  N  N





----
4.14 DEMORGANS THEOREM
----
demorgans theorem concerns the interchangeability of AND and OR
if you have either of these plus a NOT, the other conditional can be built (i.e. AND + NOT = OR ... OR + NOT = AND)

when we build our function ... each variable passed through the function shall have a NOT assigned to it

...

OR + NOT = AND

AND defined from OR and NOT:
(and x y) <=> (not (or (not x) (not y)))

if X and Y are true
then neither is X false nor is Y false

...

AND + NOT = OR

OR defined from AND and NOT:
(or x y) <=> (not (and (not x) (not y)))

if either X or Y is true
then X and Y cant both be false

...

CL-USER> (defun demorgan-and (x y)
           (not (or (not x) (not y))))
DEMORGAN-AND
CL-USER> (defun demorgan-or (x y)
           (not (and (not x) (not y))))
DEMORGAN-OR
CL-USER> (logical-and t t)
T
CL-USER> (demorgan-and t t)
T
CL-USER> (logical-and t nil)
NIL
CL-USER> (demorgan-and t nil)
NIL
CL-USER> (logical-or t nil)
T
CL-USER> (demorgan-or t nil)
T
CL-USER> (logical-or nil nil)
NIL
CL-USER> (demorgan-or nil nil)
NIL


demorgans theorem proved interchangeability of the *logical* AND and OR functions

demorgans theorem does not apply to lisps *conditional* AND and OR functions

... the double NOTs change arbitrary true inputs (i.e. 'a 'b 'c) are changed to T on output

CL-USER> (and 'a 'b)
B
CL-USER> (not (or (not 'a) (not 'b)))
T


demorgans theorem does preserve the conditional quality of AND and OR
clauses that (AND X Y) would evaluate ... would also be evaluated by (not (or (not x) (not y)))
clauses that AND would not evaluate ... would not be evaluated by (not (or (not x) (not y)))

CL-USER> (and (numberp 'a) (plusp 'a))
NIL
CL-USER> (not (or (not (numberp 'a))
                  (not (plusp 'a))))
NIL


demorgans theorem is useful for simplifying expressions involving complex combinations of predicates

(defun complicated-predicate (x y)
  (not (and (evenp x) (evenp y))))
  |
  --> (or (not (evenp x)) (not (evenp y)))
      |
      --> (or (oddp x) (oddp y)))



---
EXERCISES
---
4.35 build demorgan equations from three-input AND and OR




4.36 write the truth table for NAND

NAND:
(defun nand (x y) (not (and x y)))

x  y  (NAND X Y)
t  t  n
t  n  t
n  t  t
n  n  t


4.37 a logically complete function is one that can construct all other boolean functions built from various combinations of that function

NOT2:
(defun not2 (x) (nand x x))

construct versions of LOGICAL-AND and LOGICAL-OR by putting together BANDS

LOGICAL-NAND-AND:
(defun logical-nand-and (x y)
  (nand (nand x y) (nand x y)))

LOGICAL-NAND-OR:
(defun logical-nand-or (x y)
  (nand (nand x x) (nand y y)))


4.38 write NOR (not-OR) versions of NOT LOGICAL-AND NAND and LOGICAL-OR

NOT-OR:
(defun not-or (x)
  (nor x x)

LOGICAL-NOR-AND:
(defun logical-nor-and (x y)
  (nor (nor x x) (nor y y)))

LOGICAL-NOR-OR:
(defun logical-nor-or (x y)
  (nor (nor x y) (nor x y)))

NAND-NOR:
(defun nand (x y)
 (nor (nor (nor x x) (nor y y))
      (nor (nor x x) 

4.39 is LOGICAL-AND logically complete the way NAND and NOR are ...

LOGICAL-AND is not logically complete
NOT cannot be constructed through LOGICAL-AND combinations



----
5 Variables and Side Effects
----

---
5.1 INTRODUCTION
---

side effects are actions a function takes other than returning a value
changing the value of a variable is one kind of side effect


---
5.2 LOCAL AND GLOBAL VARIABLES
---

every variable has a scope

scope is the region in which a variable can be referenced

the only variables we have seen so far are the ones that appear within a functions argument list
these are called local variables
local variables scopes are restricted to the body of the function

DOUBLE:
(defun double (n) (* n 2))

whenever the DOUBLE function is called a new local variable N is created
inside the body of DOUBLE -- N refers to that variable
outside DOUBLE -- N cannot be referred to because it is outside of its scope; it is completely unknown to the world outside of DOUBLE

there can only be one global N ...

... but there can be many local Ns because each resides within a different lexical context


---
5.3 SETF ASSIGNS A VALUE TO A VARIABLE
---

DEFVAR declares a new global variable
CL-USER> (defvar vowels)
VOWELS

once a new global variable has been declared
we can assign a value to it with SETF

SETF is a macro function
SETF assigns a value to a variable
newly assigned values always replace the old ones

CL-USER> vowels
; Evaluation aborted on #<UNBOUND-VARIABLE VOWELS {1003EECD63}>.
CL-USER> (setf vowels '(a e i o u))
(A E I O U)
CL-USER> vowels
(A E I O U)
CL-USER> (length vowels)
5
CL-USER> (rest vowels)
(E I O U)
CL-USER> (setf vowels '(a e i o u and sometimes y))
(A E I O U AND SOMETIMES Y)
CL-USER> vowels
(A E I O U AND SOMETIMES Y)
CL-USER> (rest vowels)
(E I O U AND SOMETIMES Y)

we can assign a value to a global variable, then change it later

the first argument to SETF is the name of a variable
SETF does not evaluate this argument (because it is a macro function)
the second argument is the value for which the variable was set
SETF evaluates this argument
SETF returns the set value

global variables are useful for holding onto values to be used later
we can create variables out of other variables ...

CL-USER> (defvar long-list)
LONG-LIST
CL-USER> (setf long-list '(a b c d e f g h i))
(A B C D E F G H I)
CL-USER> (defvar head)
HEAD
CL-USER> (setf head (first long-list))
A
CL-USER> (defvar tail)
TAIL
CL-USER> (setf tail (rest long-list))
(B C D E F G H I)
CL-USER> (cons head tail)
(A B C D E F G H I)
CL-USER> (equal long-list (cons head tail))
T
CL-USER> (list head tail)
(A (B C D E F G H I))

...


---
5.4 SIDE EFFECTS
---

we have seen that functions + are useful because of the value they return

there are also functions that are useful primarily because of their side-effects
...
SETF has a side-effect of changing the value of a specified variable
the side-effect of SETF changing the value of a variable is the useful part of SETF, not its return value

DEFUN has a side-effect of defining a new function
the value of DEFUN is the name of the function it just defined ... pale comparison

RANDOM is common lisps random number generator
(RANDOM n) returns a number chosen at random from zero to (not including) n
if n is an integer -- RANDOM returns an integer
if n is a floating point number -- RANDOM returns a floating point number

CL-USER> (list (random 5) (random 5))
(4 3)
CL-USER> (list (random 5.0) (random 5.0))
(1.7118669 3.0191307)

RANDOMs side-effect is hidden
it changes the values of some variables inside the number generator, allowing it to produce a different random number each time it is called

it is in good lisp programming style to avoid changing the values of local variables
SETF will only be used on global variables in this book

see book for poor style


---
5.5 THE LET SPECIAL FUNCTION
---
the only local-variables we have worked with so far have been ones created by calling user-defined functions such as DOUBLE or AVERAGE

the LET special function is another way that we can create local variables in lisp

the average of two numbers is half of their sum
we can use a local-variable named SUM within our AVERAGE function
LET can be used to create the local-variable SUM and give it our desired initial value
in the body of the LET form we can compute the average:

CL-USER> (defun average (x y)
           (let ((sum (+ x y)))
             (list x y 'average 'is (/ sum 2.0))))
AVERAGE
CL-USER> (average 3 7)
(3 7 AVERAGE IS 5.0)

we read a LET form --

CL-USER> (let ((x 2)
               (y 'aardvark))
           (list x y))
(2 AARDVARK)

-- like "..let X be 2, and Y be AARDVARK; return (LIST X Y)."

the general syntax of LET:
(LET ((var-1 value-1)
      (var-2 value-2)
      ...
      (var-n value-n))
  body)


the first argument to LET is a list of variable-value pairs
the n value forms are evaluated
then the n local-variables are created to hold the results
finally the forms in the body of the LET are evaluated

looking at the AVERAGE function -- LET creates its own lexical context within the lexical context of AVERAGE

using LET to create two local-variables at once:

CL-USER> (defun switch-billing (x)
           (let ((star (first x))
                 (co-star (third x)))
             (list co-star 'accompanied 'by star)))
SWITCH-BILLING
CL-USER> (switch-billing '(fred and ginger))
(GINGER ACCOMPANIED BY FRED)

LET creates the local variables STAR and CO-STAR
the two value-forms (FIRST X) and (THIRD X) are both evaluated before any local-variables are created


---
EXERCISE
---
5.1 rewrite function POOR-STYLE to create a new local-variable Q using LET, instead of SETF to change P. call the new function GOOD-STYLE.

CL-USER> (defun good-style (q)
           (let ((q (+ q 5)))
             (list 'result 'is q)))
GOOD-STYLE
CL-USER> (good-style 3)
(RESULT IS 8)



----
5.6 THE LET* SPECIAL FUNCTION
----
the LET* special function is similar to LET, but LET* creates the local-variables one at a time instead of all at once

the first local-variable forms part of the lexical context in which the value of the second variable is computed, and so on ...

creating local-variables in this way is useful in assigning names to several intermediate steps within a long computation

CL-USER> (defun price-change (old new)
           (let* ((diff (- new old))
                  (proportion (/ diff old))
                  (percentage (* proportion 100.0)))
             (list 'widgets 'chenged 'by percentage 'percent)))
PRICE-CHANGE
CL-USER> (price-change 1.25 1.35)
(WIDGETS CHENGED BY 8.000002 PERCENT)

PRICE-CHANGE uses LET* to evaluate local-variables one at a time that lead to an ultimate solution
DIFF is evaluated first
PROPORTION is evaluated second
PERCENTAGE is evaluated third

the return value of PERCENTAGE is dependent on the return value of PROPORTION
the return value of PROPORTION is dependent on the return value of DIFF
OLD and NEW are input to DIFF by LET*

using LET instead of LET* when it is required is a common programming error.

CORRECT-SIZE-RANGE using LET* ...

CL-USER> (defun correct-size-range (x y z)
           (let* ((biggest (max x y z))
                  (smallest (min x y z))
                  (r (/ biggest smallest 1.0)))
             (list 'factor 'of r)))
CORRECT-SIZE-RANGE
CL-USER> (correct-size-range 35 87 4)
(FACTOR OF 21.75)


stylistically LET is better to use than *LET -- this indicates that there are no dependencies among the local-variables that are being created

programs with fewer dependencies are easier to understand



----
5.7 SIDE EFFECTS CAN CAUSE BUGS
----
best practice is to avoid using side effects in your program whenever possible

side effects of RANDOM causing a bug in the function COIN-WITH-A-BUG:
CL-USER> (defun coin-with-a-bug ()
           (cond ((< (random 101) 50) 'heads)
                 ((> (random 101) 50) 'tails)
                 ((equal (random 101) 50) 'edge)))
COIN-WITH-A-BUG
CL-USER> (coin-with-a-bug)
NIL
CL-USER> (coin-with-a-bug)
NIL
CL-USER> (coin-with-a-bug)
HEADS
CL-USER> (coin-with-a-bug)
HEADS

the bug is that we are evaluating the expression (RANDOM 101) as many as three times per function call ...

... suppose the first (RANDOM 101) returns 65; resulting in a false first test
... then the second (RANDOM 101) returns 35; resulting in a false second test
... then the third (RANDOM 101) returns any number other than 50; resulting in a false third test

this is why we see NIL being returned

in our theoretical situation COND has run out of test clauses so it returns NIL which isnt even a possible value of a coinflip

the bug fix FAIR-COIN:
CL-USER> (defun fair-coin ()
           (let ((toss (random 101)))
             (cond ((< toss 50) 'heads)
                   ((> toss 50) 'tails)
                   (t 'edge))))
FAIR-COIN
CL-USER> (fair-coin)
HEADS
CL-USER> (fair-coin)
TAILS
CL-USER> (fair-coin)
TAILS
CL-USER> (fair-coin)
TAILS

using LET to hold the value of (RANDOM 101) in a local-variable (TOSS)
in this way (RANDOM 101) is evaluated just once
we can also remove the EQUAL test -- if the first two tests fail, the result is exactly 50

SUMMARY
a variable is global to a function if it was not created by that function
local variables have scope limited to the form that created them

SETF is a macro function that assigns a value to a variable or changes an existing value
SETF is useful for its "assignment" side effect

when multiple expressions appear within a function body of LET or LET* -- the value of the last expression is returned, the other expressions are only useful for their side-effects


---
EXERCISES
---
5.2 what is a side effect

something a function does other than returning a value

5.3 what is the difference between a local and global variable

local variables scope only applies to the form it was created in
global variables apply to functions they were not created in

5.4 why must SETF be a macro function instead of a regular function

SETF is not a regular function because it does not evaluate its first argument

5.5 are LET and LET* equivalent when you are only creating one local variable

yes, the difference only applies when multiple local variables are being created


FUNCTIONS COVERED:
macro function - SETF
special functions - LET LET*



----
Lisp Toolkit: DOCUMENTATION and APROPOS
----
DOCUMENTATION is a function that provides access to online documentation for every lisp  function and variable, the documentation returned as a documentation string:

CL-USER> (documentation 'cons 'function)
"Return a list with SE1 as the CAR and SE2 as the CDR."
CL-USER> (documentation '*print-length* 'variable)
"How many elements at any level should be printed before abbreviating
  with \"...\"?"

we can include documentation strings in the functions we write, they are placed immediately after the argument list when calling DEFUN:

CL-USER> (defun average (x y)
           "Returns the mean (average value) of its two inputs."
           (/ (+ x y) 2.0))
AVERAGE
CL-USER> (documentation 'average 'function)
"Returns the mean (average value) of its two inputs."

providing documentation strings for the functions we write is good lisp practice and style
writing documentation strings and including them in our functions is not difficult either

CL-USER> (defun my-abs (x)
           "takes one integer as input and returns the absolute value"
           (if (< x 0) (- x) x))
MY-ABS
CL-USER> (documentation 'my-abs 'function)
"takes one integer as input and returns the absolute value"

are we understanding closely ... :)]

we can provide another form of documentation in our programs through the use of comments
in lisp, comments are prefaced with semicolon(s)

whenever lisp encounters a semicolon while loading a program -- everything from the semicolon until the next carriage return is discarded

comments benefit humans that are attempting to understand a lisp program
comments are ignored by lisp and do not form part of the online documentation

although comments arent necessarily official documentation, they can provide more context and detail in regard to a particular part of the program trying to be understood

CL-USER> (defun einstein (m)
           (let ((c 300000.0)) ; speed of light in km/sec.
             ;; E is energy
             ;; m is mass
             (* m c c)))
EINSTEIN

another useful source of documentation is APROPOS
APROPOS tells the names of all symbols containing a specified string

lets find all the built-in functions and variables containing the word 'TOTAL' in their names:

CL-USER> (apropos "TOTAL" "CL-USER")
ARRAY-TOTAL-SIZE (fbound)
ARRAY-TOTAL-SIZE-LIMIT (bound)
; No value

check that.
common-lisp provides us with a function ARRAY-TOTAL-SIZE and a built-in constant ARRAY-TOTAL-SIZE-LIMIT

a constant is a variable we are not allowed to change within lisp ... like the constant variable pi

the second argument to APROPOS is called a package name

"CL-USER" should always be used for the second argument, otherwise APROPOS will include stuff we dont particularly car about with respect to this text


(KEYBOARD-EXERCISE)
5.6 this keyboard exercise is about dice ... we will start with a function to throw one die and end up with a program to play craps ... be sure to include a documentation string for each function you write ...

a) write a function THROW-DIE that returns a random number from 1-6 (inclusive) ... (RANDOM 6) will pick numbers 0-5 ... THROW-DIE doesnt need any inputs ... THROW-DIE should have NIL as its argument list ...

THROW-DIE:
CL-USER> (defun throw-die ()
           "function, requires no arguments, returns a random integer from 1-6 (inclusive)"
           (+ 1 (random 6)))
THROW-DIE
CL-USER> (throw-die)
3
CL-USER> (throw-die)
2
CL-USER> (throw-die)
4

b) write a function THROW-DICE that throws two dice and returns a list of two numbers (the value of the first die and the value of the second die ... we can call this list a "throw" ... THROW-DICE might return the "throw" (3 5) ...

THROW-DICE:
CL-USER> (defun throw-dice ()
           "function, requires no arguments, returns two random integers 1-6 (inclusive) as a list first and second"
           (list (throw-die) (throw-die)))
THROW-DICE
CL-USER> (throw-dice)
(2 1)
CL-USER> (throw-dice)
(5 1)
CL-USER> (throw-dice)
(4 4)


c) throwing two ones is called "snake-eyes" ... throwing two sixes is called "cob-cars" ... write SNAKE-EYES-P and BOXCARS-P that take a throw as input and return T if the throw is equal to (1 1) or (6 6) ...

SNAKE-EYES-P:
CL-USER> (defun snake-eyes-p (throw)
           "function, takes one input as throw -- returns t if two ones result, nil otherwise ..."
           (equal throw '(1 1)))
SNAKE-EYES-P

BOXCARS-P:
CL-USER> (defun boxcars-p (throw)
           "function, takes one input as throw -- returns t if two sixes return, nil otherwise ..."
           (equal throw '(6 6)))
BOXCARS-P


d) the resulting pair of the first throw is crucial in craps ... a throw of 7 or 11 is an instant win ... (in america) a throw of 2 3 or 12 is considered an instant loss ... write predicates INSTANT-WIN-P and INSTANT-LOSS-P to detect when these conditions have occurred ... each condition should take a throw as input ...

THROW-VALUE:
CL-USER> (defun throw-value (throw)
           "function (helper), used by several of the functions in the CRAPS program, returns the sum of a throw ..."
           (+ (first throw) (second throw)))
THROW-VALUE

INSTANT-WIN-P:
CL-USER> (defun instant-win-p (throw)
           "function (predicate), relevant to CRAPS ... takes a throw as input returns t if 7 or 11 ..."
           (member (throw-value throw) '(7 11)))
INSTANT-WIN-P

INSTANT-LOSS-P:
CL-USER> (defun instant-loss-p (throw)
           "function (predicate), relevant to CRAPS ... takes a throw as input ... returns t if 2 3 or 12 ..."
           (member (throw-value throw) '(2 3 12)))
INSTANT-LOSS-P


e) write a function SAY-THROW that takes throw as input and returns either the sum of the two dice or the symbol SNAKE-EYES or BOXCARS if the sum is 2 or 12 ... (SAY-THROW '(3 4)) should return 7 ... (SAY-THROW '(6 6)) should return BOXCARS ...

SAY-THROW:
CL-USER> (defun say-throw (throw)
           "function, takes a throw as input -- returns the sum SNAKE-EYES or BOX-CARS ... (CRAPS) ..."
           (cond ((snake-eyes-p throw) 'snake-eyes)
                 ((boxcars-p throw) 'boxcars)
                 (t (throw-value throw))))
SAY-THROW


f) if you dont win or lose on the first throw of the dice, the value you threw becomes your "point" ... write a function (CRAPS) that produces the following sort of behaviour ... your solution should make use of the functions you wrote in previous steps ...

CRAPS:
CL-USER> (defun craps ()
           (let ((throw (throw-dice)))
             (append
              (list 'throw (first throw)
                    'and (second throw)
                    '--
                    (say-throw throw)
                    '--)
              (cond ((instant-win-p throw) '(you win))
                    ((instant-loss-p throw) '(you lose))
                    (t (list 'your 'point 'is
                             (throw-value throw)))))))
CRAPS


g) once a point has been established, continue throwing until you either win by making the point again or lose by throwing a 7 ... write the function TRY-FOR-POINT that simulates this part of the game ...

TRY-FOR-POINT:
CL-USER> (defun try-for-point (point)
           (let* ((throw (throw-dice))
                  (val (throw-value throw)))
             (append
              (list 'throw (first throw)
                    'and (second throw)
                    '--
                    (say-throw throw)
                    '--)
              (cond ((equal val point) '(you win))
                    ((equal val 7) '(you lose))
                    (t '(throw again))))))
TRY-FOR-POINT

CL-USER> (craps)
(THROW 5 AND 1 -- 6 -- YOUR POINT IS 6)
CL-USER> (try-for-point 6)
(THROW 6 AND 4 -- 10 -- THROW AGAIN)
CL-USER> (try-for-point 6)
(THROW 1 AND 2 -- 3 -- THROW AGAIN)
CL-USER> (try-for-point 6)
(THROW 1 AND 5 -- 6 -- YOU WIN)



//////
5 Advanced Topics
//////

---
5.8 SYMBOLS AND VALUE CELLS
---

internally a symbol is composed of five components

two we have seen -- name, function-cell

a third component of every symbol is the value cell

value cell
points to the global variable named by that symbol

(see book for images)

...

if the global-variable TOTAL has a value of 12, the internal cell structure of the symbol TOTAL would look similar to:
________
name:---|--> "TOTAL"
value:--|--> 12
###:    |
###:    |
###:    |
________|

if the global-variable FISH has the value TROUT, the internal cell structure would look like:

_________
name:---|--> "FISH"
value:--|------
###:    |     |           _________
###:    |     ----------->|name:---|--> "TROUT"
###:    |                 |--------|
________|                 |--------|
                          |--------|
                          |--------|
                          |________|

the value cells within the internal cell structure of T and NIL involve circularity and point in a loop back to themselves

this is why T and NIL evaluate to themselves


a symbol can be used to name many variables, but only one of them can be the global-variable

the value-cell in the internal cell structure of a symbol is reserved for this one permitted global-variable

all other variables would exist in a local lexical context, and their values would reside somewhere other than the symbols value cell

common-lisp doesnt specify where the values of local-variables are held ...
... those details are left to the implementation

because symbols have separate function and value cells, we can have a variable with the same name

(see book for function-cell)

if a symbol appears to be the first element of a list to be evaluated -- it is treated as a function name ... in other contexts it is treated as a variable name



---
5.9 DISTINGUISHING LOCAL FROM GLOBAL VARIABLES
---

symbols are not variables ... they serve as names for variables (as well as functions)

exactly which variable a symbol refers to depends on the context in which it appears

the global-variable-value will always evaluate over a locally defined variables value

we use SETF to assign global-variable-values

check this shit out:

CL-USER> (setf a 100)
(A)
CL-USER> (defun f (a)
           (list a (g (+ a 1))))
(F)
CL-USER> (defun g (b)
           (list a b))
(G)
CL-USER> (f 3)
(3 (100 4))

SETF creates the global-variable (A) with a global-variable-value of 100

DEFUN creates a local-variable (A) which is input to the function being defined (F), the value of the local-variable (A) should evaluate to its self

basically (F) uses the (A) it created and (G) uses (A) the global-variable that SETF created

"F binds a local-variable A to 3 ..."

---
5.10 BINDING SCOPING AND ASSIGNMENT
---

common-lisp evolved from older, less sophisticated forms of lisp

it has inherited terminology that doesnt quite fit in to todays standards

uses and misuses of some terminology can be cleared up now

binding
historically variables that have values are said to be bound, variables with no value being unbound
the process of creating a new variable and giving it a value is called "binding"
if the variable appears in a function argument list, it is said to be "lambda binding"
if it appears in the variable list of a LET or LET* form, we say it is "LET-binding"
"LET-binding" a variable to the value of (RANDOM 101) fixed the bug in the function COIN-WITH-A-BUG

while variables are lexically scoped by default, common-lisp provides another scoping discipline called dynamic-scoping

dynamic-scoping
capability for a variable to be bound but have no value



---
6 List Data Structures
---

---
6.1 INTRODUCTION
---

go back and read section 2.17 ... right now ...

2.17 NONLIST CONS STRUCTURES

a proper-list is a cons-cell-chain ending in NIL

in parenthesis notation, NIL is omitted from the end of a list

(A B C D)


one list that doesnt end in NIL is called a dotted list

(A B C . D)

if a list does not end in NIL, lisp prints a space, a period, a space, and then the atom that ends the chain


we can create a certain type of dotted-list with CONS, called a dotted-pair

CL-USER> (cons 'a 'b)
(A . B)
CL-USER> (cons '(a b c) 'd)
((A B C) . D)

and ...

CL-USER> (cons 'a (cons 'b 'c))
(A B . C)

LIST cannot build dotted-lists ... it only builds proper-lists that end in NIL


CONS must be used for dotted-lists



---
6.2 PARENTHESIS NOTATION VS CONS CELL NOTATION
---

CL-USER> (cons 'w '(x y z))
(W X Y Z)

cons creates a new cons cell whose CAR is W and CDR points to the existing list (X Y Z) ... this could also be wirtted (W . X Y Z)


CL-USER> (cons '(a b c) 'd)
((A B C) . D)

when we CONS (A B C) onto D its the CAR of the new cell that points to the old list (A B C) ... the CDR points to the symbol D

CONS is not direct way to add an element to the end of a list

more sophisticated techiniques must be used ...



---
6.3 THE APPEND FUNCTION
---

CL-USER> (documentation 'append 'function)
"Construct a new list by concatenating the list arguments"

append takes lists as input and returns a list containing all the elements of the first list followed by all the elements of the second ...

CL-USER> (append '(a b c) 'd)
(A B C . D)
CL-USER> (append '(a b c) '(d))
(A B C D)

CL-USER> (append '(1 2 3) '(4 5 6))
(1 2 3 4 5 6)
CL-USER> (append '(1 2 3) '4 '5 '6)
; Evaluation aborted on #<TYPE-ERROR expected-type: LIST datum: 4>.
CL-USER> (append '(1 2 3) '(4) '(5) '(6))
(1 2 3 4 5 6)
CL-USER> (append '(1 2 3) '(4) '(5) '6)
(1 2 3 4 5 . 6)

... interesting


if one of the inputs to APPEND is the-empty-list NIL, the result is the other input
appending NIL to a list is like adding zero to a number ...

CL-USER> (append nil '(1 2 3))
(1 2 3)
CL-USER> (append '(1 2 3) nil)
(1 2 3)
CL-USER> (append '(1 2 3) nil '(4 5 6))
(1 2 3 4 5 6)
CL-USER> (append nil nil)
NIL

APPEND works for us in all sorts of ways

APPEND works on nested lists

CL-USER> (append '((a 1) (b 2)) '((c 3) (d 4)))
((A 1) (B 2) (C 3) (D 4))


APPEND does not change the value of any variable or modify any existing cons cells ...

for this reason APPEND is considered a nondestructive-function

CL-USER> (setf who '(only the good))
(ONLY THE GOOD)
CL-USER> (append who '(die young))
(ONLY THE GOOD DIE YOUNG)
CL-USER> who
(ONLY THE GOOD)

parenthesis notation makes it seem as if APPEND treats its inputs symmetrically

it doesnt

APPEND copies previous inputs but not the last ...
it makes the cdr of the last cell of the copy point to the second input
... then it returns a pointer to the copy

this explains why APPEND cannot accept a non-list as its first input ...

if the problem includes adding an element to the end of a list, APPEND can solve that issue if we first make a list of the element

CL-USER> (append '(a b c) '(d))
(A B C D)


ADD-TO-END:
CL-USER> (defun add-to-end (x e)
           "adds element E to the end of list X ..."
           (append x (list e)))
ADD-TO-END
CL-USER> (add-to-end '(a b c) 'd)
(A B C D)



---
6.4 COMPARING CONS LIST AND APPEND
---

CONS LIST APPEND ... these three functions can be used to create list structures, but they are useful in different ways

CONS:
creates one new cons cell ... often used to add an element to the front of a list

CL-USER> (documentation 'cons 'function)
"Return a list with SE1 as the CAR and SE2 as the CDR."


LIST:
makes new lists by accepting an arbitrary number of inputs and building a chain of cons cells ending in NIL ... the car of each cell pointing to the corresponding input

CL-USER> (documentation 'list 'function)
"Return constructs and returns a list of its arguments."


APPEND:
appends lists together by copying its first input and making the cdr of the last cell of the copy point to the second input ... the first input must be a list

CL-USER> (documentation 'append 'function)
"Construct a new list by concatenating the list arguments"


CL-USER> (cons 'a '(b c))
(A B C)
CL-USER> (list 'a '(b c))
(A (B C))
CL-USER> (append 'a '(b c))
; Evaluation aborted on #<TYPE-ERROR expected-type: LIST datum: A>.

CL-USER> (cons '(a b) '(c d))
((A B) C D)
CL-USER> (list '(a b) '(c d))
((A B) (C D))
CL-USER> (append '(a b) '(c d))
(A B C D)

CL-USER> (cons '(a b) 'c)
((A B) . C)
CL-USER> (list '(a b) 'c)
((A B) C)
CL-USER> (append '(a b) 'c)
(A B . C)


group them

CONS:
CL-USER> (cons 'a '(b c))
(A B C)
CL-USER> (cons '(a b) '(c d))
((A B) C D)
CL-USER> (cons '(a b) 'c)
((A B) . C)


LIST:
CL-USER> (list 'a '(b c))
(A (B C))
CL-USER> (list '(a b) '(c d))
((A B) (C D))
CL-USER> (list '(a b) 'c)
((A B) C)


APPEND:
CL-USER> (append 'a '(b c))
; Evaluation aborted on #<TYPE-ERROR expected-type: LIST datum: A>.
CL-USER> (append '(a b) '(c d))
(A B C D)
CL-USER> (append '(a b) 'c)
(A B . C)


for further investigation consult the tool SDRAW to assist in mapping the cons cell diagrams of given functions



---
6.5 MORE FUNCTIONS ON LISTS
---

... there are a shit ton, buckle up here are a few:

REVERSE NTH NTHCDR LAST REMOVE

remember these ...:
CONS LIST APPEND FIRST LENGTH CAR CDR


6.5.1 REVERSE
CL-USER> (documentation 'reverse 'function)
"Return a new sequence containing the same elements but in reverse order."

CL-USER> (reverse '(1 2 3 4 5))
(5 4 3 2 1)
CL-USER> (reverse '(one two three four five))
(FIVE FOUR THREE TWO ONE)
CL-USER> (reverse '(l i v e d))
(D E V I L)
CL-USER> (reverse 'lived)
; Evaluation aborted on #<TYPE-ERROR expected-type: SEQUENCE datum: LIVED>.
CL-USER> (reverse '((a)
                    (b)
                    (c)))
((C) (B) (A))
CL-USER> (reverse '(1 2 3 4 5) '(1 2 3 4 5) '(1 2 3 4 5))
; Evaluation aborted on #<SB-INT:SIMPLE-PROGRAM-ERROR "invalid number of arguments: ~S" {100534DA63}>.
CL-USER> (reverse '(1 (1 2 3) 2 (1 2 3) 3 (1 2 3)))
((1 2 3) 3 (1 2 3) 2 (1 2 3) 1)

CL-USER> (reverse '((a b c) 1 (d e f) 2 (g h i) 3))
(3 (G H I) 2 (D E F) 1 (A B C))
CL-USER> (reverse (reverse '((a b c) 1 (d e f) 2 (g h i) 3)))
((A B C) 1 (D E F) 2 (G H I) 3)


REVERSE only reverses the top-level of a list ... it does not reverse the underlying individual elements of lists of lists
REVERSE does not work on symbols
REVERSE is a nondestructive-function like APPEND, it copies an input rather than modifying it'

CL-USER> (setf vow '(to have and to hold))
(TO HAVE AND TO HOLD)
CL-USER> (reverse vow)
(HOLD TO AND HAVE TO)
CL-USER> vow
(TO HAVE AND TO HOLD)


we can use REVERSE to add an element to the end of a list ... in a sort-of roundabout way

CL-USER> (defun add-to-end (x y)
           (reverse (cons y (reverse x))))
WARNING: redefining COMMON-LISP-USER::ADD-TO-END in DEFUN
ADD-TO-END
CL-USER> (add-to-end '(a b c) 'd)
(A B C D)


now we can add an element to the end of a list two different ways through APPEND and REVERSE

the use of APPEND to add elements to the end of a list is considered good lisp style

REVERSE creates two copies of the list

APPEND is more efficient



6.5.2 NTH AND NTHCDR

CL-USER> (documentation 'nth 'function)
"Return the nth object in a list where the car is the zero-th element."

CL-USER> (documentation 'nthcdr 'function)
"Performs the cdr function n times on a list."


... the documentation strings are clear


CL-USER> (nthcdr 0 '(a b c))
(A B C)
CL-USER> (nthcdr 1 '(a b c))
(B C)
CL-USER> (nthcdr 2 '(a b c))
(C)
CL-USER> (nthcdr 3 '(a b c))
NIL

getting NIL for 3 is one of the consequences of making the cdr of NIL be NIL

... however, if the list ends in an atom other that NIL, going too far will cause error

CL-USER> (nthcdr 2 '(a b c . d))
(C . D)
CL-USER> (nthcdr 3 '(a b c . d))
D
CL-USER> (nthcdr 4 '(a b c . d))
; Evaluation aborted on #<TYPE-ERROR expected-type: LIST datum: D>.


the NTH function takes the CAR of the NTHCDR of a list

CL-USER> (nth 0 '(a b c))
A
CL-USER> (nth 1 '(a b c))
B
CL-USER> (nth 2 '(a b c))
C
CL-USER> (nth 3 '(a b c))
NIL


numbering from zero rather than one is a common convention in lisp and should be a well developed habit


--
EXERCISES
--
6.1 why is (NTH 4 '(A B C)) equal to NIL

the cdr of this function is NIL ... NIL is the CAR and CDR of NIL


6.2 what is the value of (NTH 3 '(A B C . D))

CL-USER> (nth 3 '(a b c . d))
; Evaluation aborted on #<TYPE-ERROR expected-type: LIST datum: D>.

taking the third CAR of this list returns D ... D is not a list



6.5.3 LAST

CL-USER> (documentation 'last 'function)
"Return the last N conses (not the last element!) of a list."


LAST returns the last cons cell of a list (the cell that contains the last element of a list)

by definition, the cdr of this cell is an atom -- otherwise it wouldnt be the last cell of the list

if the list is empty ... last returns NIL

CL-USER> (last '(a b c d))
(D)
CL-USER> (last nil)
NIL
CL-USER> (last '(a b c . d))
(C . D)
CL-USER> (last 'a)
; Evaluation aborted on #<TYPE-ERROR expected-type: LIST datum: A>.


--
EXERCISES
--
6.3 what is the value of (LAST '(ROSEBUD))

CL-USER> (last '(rosebud))
(ROSEBUD)


6.4 what is the value of (LAST '((A B C)))

CL-USER> (last '((A B C)))
((A B C))

...because

CL-USER> (last '(nil (a b c)))
((A B C))



6.5.4 REMOVE

CL-USER> (documentation 'remove 'function)
"Return a copy of SEQUENCE with elements satisfying the test (default is
   EQL) with ITEM removed."


CL-USER> (remove 'a '(b a n a n a))
(B N N)
CL-USER> (remove '1 '(1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 0))
(2 3 4 5 6 7 8 9 0)


REMOVE is a nondestructive-function, it does not change any variables or cons cells when removing elements from a list

REMOVE builds the result it returns out of newly created cons cells containing copies of part(s) of the input


CL-USER> (setf spell '(a b r a c a d a b r a))
(A B R A C A D A B R A)
CL-USER> (remove 'a spell)
(B R C D B R)
CL-USER> spell
(A B R A C A D A B R A)


--
EXERCISES
--
6.5 write an expression to set the global-variable LINE to the list (ROSES ARE RED)

CL-USER> (setf line '(roses are red))
(ROSES ARE RED)
CL-USER> (reverse line)
(RED ARE ROSES)
CL-USER> (first (last line))
RED
CL-USER> (nth 1 line)
ARE
CL-USER> (reverse (reverse line))
(ROSES ARE RED)
CL-USER> (append line (list (first line)))
(ROSES ARE RED ROSES)
CL-USER> (append (last line) line)
(RED ROSES ARE RED)
CL-USER> (list (first line) (last line))
(ROSES (RED))
CL-USER> (cons (last line) line)
((RED) ROSES ARE RED)
CL-USER> (remove 'are line)
(ROSES RED)
CL-USER> (append line '(violets are blue))
(ROSES ARE RED VIOLETS ARE BLUE)


6.6 use the LAST function to write a function called LAST-ELEMENT that returns the last element of a list instead of the last cons cell ... write another version of LAST-ELEMENT using REVERSE instead of LAST ... and others with NTH and LENGTH

CL-USER> (defun last-last-element (x)
           "LAST version, returns the last element of a list (not the last cell)"
           (first (last x)))
LAST-LAST-ELEMENT

CL-USER> (defun last-reverse-element (x)
           "REVERSE version, returns the last element of a list (not the last cell) ..."
           (first (reverse x)))
LAST-REVERSE-ELEMENT

CL-USER> (defun last-length-nth-element (x)
           "LENGTH NTH version, returns the last element of a list (not the last cell) ..."
           (and x ; to handle NIL correctly
                (nth (- (length x) 1) x)))
LAST-LENGTH-NTH-ELEMENT
CL-USER> (length '(a b c d))
4
CL-USER> (- 4 1)
3
CL-USER> (nth 3 '(a b c d))
D


6.7 use REVERSE to write a NEXT-TO-LAST function that returns the next-to-last element of a list ... write another using NTH

CL-USER> (defun next-reverse-to-last (x)
           "REVERSE version, returns the next to last element of a list ..."
           (second (reverse x)))
NEXT-REVERSE-TO-LAST
CL-USER> (defun next-nth-to-last (x)
           "NTH version, returns the next to last element of a list ..."
           (and (rest x) ; to handle short lists
                (nth (- (length x) 2) x)))
NEXT-NTH-TO-LAST


6.8 write MY-BUTLAST that returns a list with the element removed ... (MY-BUTLAST '(ROSES ARE RED)) should return the list (ROSES ARE) ... (MY-BUTLAST '(G A G A)) returns (G A G)

CL-USER> (defun my-butlast (x)
           "removes the last element from input and returns ..."
           (reverse (rest (reverse x))))
MY-BUTLAST


6.9 what primitive does the following reduce to ... (defun mystery (x) (first (last (reverse x))))

MYSTERY is the same as the primitive function FIRST


6.10 a palindrome is a sequence that reads the same forwards and backwards ... the list (A B C D C B A) is a palindrome ... write PALINDROMEP that returns T if a palindrome is input ...

CL-USER> (defun palindromep (x)
           "returns T if palindrome is input ..."
           (equal x (reverse x)))
PALINDROMEP
CL-USER> (palindromep '(1 2 3 2 1))
T
CL-USER> (palindromep '(1 2 3 3 2 1))
T
CL-USER> (palindromep '(3 2 1 3 2 1))
NIL


6.11 write function MAKE-PALINDROME that makes a palindrome out of a list ... (YOU AND ME) returns (YOU AND ME ME AND YOU) ...

CL-USER> (defun make-palindrome (x)
           "takes a list as input, returns the palindrome of input ..."
           (append x (reverse x)))
MAKE-PALINDROME



---
6.6 LISTS A SETS
---

set
an unordered collection of items

in a set, each item appears only once

typical-sets: days-of-the-week, the infinite set, and the set of people in hackensack new jersey that ate spaghetti for dinner last night

sets are one of the most useful data-structures we can build from lists

set operations include testing to see if an item is a member of a set; taking the union intersection set-difference(set-subtraction) of two sets; testing if one set is the subset of another


6.6.1 MEMBER

CL-USER> (documentation 'member 'function)
"Return the tail of LIST beginning with first element satisfying EQLity,
   :TEST, or :TEST-NOT with the given ITEM."

the MEMBER predicate checks to see whether an item is the member of a list

... if the item is found in the list, the sublist beginning with that item is returned; otherwise NIL

MEMBER never returns T -- it is traditionally considered as a predicate because the value it returns is non-NIL (T) if and only if the item is in the list

CL-USER> (setf ducks '(huey dewey louie))
(HUEY DEWEY LOUIE)
CL-USER> (member 'huey ducks)
(HUEY DEWEY LOUIE)
CL-USER> (member 'dewey ducks)
(DEWEY LOUIE)
CL-USER> (member 'louie ducks)
(LOUIE)
CL-USER> (member 'mickey ducks)
NIL


the usefulness of MEMBER:

CL-USER> (defun beforep (x y l)
           "returns T if X appears before Y in L ..."
           (member y (member x l)))
BEFOREP
CL-USER> (beforep 'not 'whom '(ask not for whom the bell tolls))
(WHOM THE BELL TOLLS)
CL-USER> (beforep 'thee 'tolls '(it tolls for thee))
NIL


--
EXERCISE
--
6.12 does MEMBER have to copy its input to produce its result ...

no, member points its first input to the second input and creates a new cons cell chain with the return value


6.6.2 INTERSECTION

CL-USER> (documentation 'intersection 'function)
"Return the intersection of LIST1 and LIST2."

INTERSECTION is a function that takes the intersection of two sets and returns a list of items appearing in both sets

the order of the returned elements is undefined within intersection ...

order doesnt apply to sets anyway ... only the elements themselves matter

CL-USER> (intersection '(1 2 3)
                       '(3 1 4))
(3 1)
CL-USER> (intersection '(a b c)
                       '(b c d))
(C B)
CL-USER> (intersection '(1 2 3)
                       '(4 5 6))
NIL


INTERSECTION and UNION are equipped to evaluate non-sets as input

CL-USER> (intersection '(1 2 2)
                       '(1 2 3))
(2 2 1)

sets do not contain repeating elements

the lisp implementation we are currently operating has INTERSECTION defined to return repeating elements in a non-set list


--
EXERCISES
--

6.13 what is the result of intersecting a set with NIL ...

CL-USER> (intersection '(1 2 3)
                       nil)
NIL


6.14 ... intersecting a set with itself ...

the inverse of the set is returned:
CL-USER> (intersection '(x y z)
                       '(x y z))
(Z Y X)
CL-USER> (intersection '(a b c 1 2 3 d e f)
                       '(a b c 1 2 3 d e f))
(F E D 3 2 1 C B A)


6.15 MEMBER can be used to write a predicate that returns a true value if a sentence contains the word "the" ...

CL-USER> (defun contains-the-p (sent)
           "T if a sentence contains /the/ ..."
           (member 'the sent))
CONTAINS-THE-P

well ... instead, we want a predicate CONTAINS-ARTICLE-P that returns a true value if a sentence contains any article (a the an ...) ... write it with INTERSECTION ... another with MEMBER and OR ... could this problem be solved with AND instead of OR ...

CL-USER> (defun contains-article-p (sent)
           "T if a sentence contains 'the' 'a' 'an' ..."
           (intersection sent '(the a an)))
CONTAINS-ARTICLE-P
CL-USER> (contains-article-p '(an ounce in the sand is a win))
(A THE AN)
CL-USER> (contains-article-p '(tan in the sand))
(THE)

CL-USER> (defun contains-article-or-member-p (sent)
           "returns instances of 'the' 'a' 'an' in SENT ..."
           (or (member 'the sent)
               (member 'an sent)
               (member 'a sent)))
CONTAINS-ARTICLE-OR-MEMBER-P

CL-USER> (defun contains-article-and-p (sent)
           "returns instances of ARTICLE in SENT ..."
           (not (and (not (member 'the sent))
                     (not (member 'an sent))
                     (not (member 'a sent)))))
CONTAINS-ARTICLE-AND-P



6.6.3 UNION

CL-USER> (documentation 'union 'function)
"Return the union of LIST1 and LIST2."

UNION takes LIST1 and LIST2 as input and returns a list of items that appear in either set:

CL-USER> (union '(a s d f g)
                '(v w s r a))
(G F D V W S R A)
CL-USER> (union '(finger hand arm)
                '(toe finger foot leg))
(LEG FOOT TOE FINGER HAND ARM)
CL-USER> (union '(fred john mary)
                '(sue mary fred))
(JOHN SUE MARY FRED)

note -- if an item appears in both sets, it will still be returned only once; the order in which the items are returned is undefined and irrelevant when working with sets

if a list contains multiple occurrences of an item, it is not a set

a set does not contain multiple occurrences of the same item


--
EXERCISES
--
6.16 what is the union of a set with NIL ...

the inverse of LIST1 is returned -- the union of a set with NIL is the set

CL-USER> (union '(a b c d e f)
                NIL)
(F E D C B A)
CL-USER> (union '(1 2 3 4 5 6)
                NIL)
(6 5 4 3 2 1)


6.17 what is the union of a set with itself ...

the union of a set with itself is the input

CL-USER> (union '(a b c)
                '(a b c))
(A B C)
CL-USER> (union '(1 2 3)
                '(1 2 3))
(1 2 3)


6.18 write a function ADD-VOWELS that takes a set of letters as input and adds the vowels (A E I O U) to the set ... (ADD-VOWELS '(X A E Z)) => (X A E Z I O U) ... ignoring order ...

CL-USER> (defun add-vowels (x)
           "adds standard vowels to LIST ..."
           (union x '(a e i o u)))
ADD-VOWELS



6.6.4 SET-DIFFERENCE

CL-USER> (documentation 'set-difference 'function)
"Return the elements of LIST1 which are not in LIST2."

SET-DIFFERENCE performs set subtraction, it returns all the elements that fall through LIST2

SET-DIFFERENCE returns the elements from LIST1 that do not match with LIST2

SET-DIFFERENCE returns what is left of the first set when the elements in the second set have been removed

the order of elements that is returned is undefined and irrelevant when working with sets


CL-USER> (set-difference '(alpha bravo charlie delta)
                         '(bravo charlie))
(DELTA ALPHA)
CL-USER> (set-difference '(alpha bravo charlie delta)
                         '(echo alpha foxtrot))
(DELTA CHARLIE BRAVO)
CL-USER> (set-difference '(alpha bravo) '(bravo alpha))
NIL

unlike UNION and INTERSECTION -- SET-DIFFERENCE is not a symmetric function
switching its first and second inputs usually results in a different set being produced as output ... compare to switching numbers and subtraction

CL-USER> (setf line1 '(all things in moderation))
(ALL THINGS IN MODERATION)
CL-USER> (setf line2 '(moderation in the defense of liberty is no virtue))
(MODERATION IN THE DEFENSE OF LIBERTY IS NO VIRTUE)
CL-USER> (set-difference line1 line2)
(THINGS ALL)
CL-USER> (set-difference line2 line1)
(VIRTUE NO IS LIBERTY OF DEFENSE THE)


--
EXERCISES
--
6.19 what is the return when NIL is an input to SET-DIFFERENCE ...

if NIL is the first input, NIL is returned
if NIL is the second input, the first input is returned

CL-USER> (set-difference '(1 2 3) nil)
(1 2 3)
CL-USER> (set-difference nil '(1 2 3))
NIL

(set-difference list nil) => (list)
(set-difference nil list) => nil


6.20 which of its two inputs does SET-DIFFERENCE need to copy ... which input never needs to be copied ...

CL-USER> (set-difference '(1 2 3) nil)
(1 2 3)
CL-USER> (set-difference nil '(1 2 3))
NIL

look at the NIL flip-flop
the first set shows up in both examples indicating that the first input is the one being copied
after the first set is copied, SET-DIFFERENCE sends a pointer to the second input
SET-DIFFERENCE then compares its copy to the set being pointed to
then returns all the items that the second input (set) doesnt have

none of the elements from the second input even show up in the returned result

only parts of the first input are actually copied ... likely the ones that are returned



6.6.5 SUBSETP

CL-USER> (documentation 'subsetp 'function)
"Return T if every element in LIST1 is also in LIST2."

making LIST1 the subset of LIST2

if every element of the first set is contained in the second set, then SUBSETP returns T

CL-USER> (subsetp '(1 3) '(1 2 3))
T
CL-USER> (subsetp '(1 4) '(1 2 3))
NIL


--
EXERCISE
--
6.21 if LIST1 is a subset of LIST2, then subtracting LIST2 from LIST1 should leave the empty set NIL ... write a version of SUBSETP called UNIONIZED-SUBSET that returns T if its first input is a subset of its second input ...

CL-USER> (defun my-subset (x y)
           "T if LIST1 is a subset of LIST2 ..."
           (null (set-difference x y)))
MY-SUBSET



--
GENERAL SET EXERCISES
--
6.22 suppose the global variable A is bound to the list (SOAP WATER) ... return each expression

CL-USER> (setf a '(soap water))
(SOAP WATER)
CL-USER> (union a '(no soap radio))
(RADIO NO SOAP WATER)
CL-USER> (intersection a (reverse a))
(WATER SOAP)
CL-USER> (set-difference a '(stop for water))
(SOAP)
CL-USER> (set-difference a a)
NIL
CL-USER> (member 'soap a)
(SOAP WATER)
CL-USER> (member 'water a)
(WATER)
CL-USER> (member 'washcloth a)
NIL


6.23 the cardinality of a set is the number of elements it contains ... what lisp primitive determines the cardinality of a set ...

LENGTH returns the cardinality of a set


6.24 sets are said to be equal if they contain exactly the same elements ... order does not matter in a set ... order does matter when using the calling EQUAL though ... EQUAL treats inputs as lists, not as sets ... write SET-EQUALP that returns T if two inputs are equal as sets ... if two subsets are equal, each is a subset of eachother ...

CL-USER> (defun set-equal (x y)
           (and (subsetp x y)
                (subsetp y x)))
SET-EQUAL


6.25 setx is a proper subset to sety if x is a subset of y, but not equal to y ... (A C) is a proper subset of (C A B) ... (A B C) is a subset of (C A B) but not a proper subset of (C A B) ... write PROPER-SUBSETP, which returns T if its first input is a proper subset of its second input ...

CL-USER> (defun proper-subsetp (x y)
           "T if LIST1 is a proper subset of LIST2 ..."
           (and (subsetp x y)
                (not (subsetp y x))))
PROPER-SUBSETP



----
6.7 PROGRAMMING WITH SETS
----

problem:
write a function that adds a title to a name, turning "john doe" into "mr. john doe" and "jane doe" into "ms. jane doe" ... if a name already has a title, the title should be kept ... adding titles to the input names would require a method in determining gender so that the title matches appropriately ...

to solve a problem like this we must break it down into smaller pieces ...

we can do like ...

piece1 we determine whether an input name has a title or not
piece2 we determine which gender a first name belongs to


determine whether an input name has a title or not:

CL-USER> (defun titledp (name)
           "determines whether NAME has a title already as input ..."
           (member (first name) '(mr ms miss mrs)))
TITLEDP
CL-USER> (titledp '(jane doe))
NIL
CL-USER> (titledp '(miss jane doe))
(MISS MRS)
CL-USER> (titledp '(ms jane doe))
(MS MISS MRS)
CL-USER> (titledp '(mr john doe))
(MR MS MISS MRS)


determine which gender a first name belongs to:

CL-USER> (setf male-first-names
               '(john kim richard fred george))
(JOHN KIM RICHARD FRED GEORGE)
CL-USER> (setf female-first-names
               '(jane mary wanda barbara kim))
(JANE MARY WANDA BARBARA KIM)
CL-USER> (defun malep (name)
           "T if first NAME belongs to the male gender ..."
           (and (member name male-first-names)
                (not (member name female-first-names))))
MALEP
CL-USER> (defun femalep (name)
           "T if first NAME belongs to the female gneder ..."
           (and (member name female-first-names)
                (not (member name male-first-names))))
FEMALEP
CL-USER> (malep 'richard)
T
CL-USER> (malep 'barbara)
NIL
CL-USER> (femalep 'barbara)
T
CL-USER> (femalep 'john)
NIL


now we write the GIVE-TITLE function:

CL-USER> (defun give-title (name)
           "adds appropriate title to NAME ..."
           (cond ((titledp name) name)
                 ((malep (first name)) (cons 'mr name))
                 ((femalep (first name)) (cons 'ms name))
                 (t (append '(mr or ms) name))))
GIVE-TITLE
CL-USER> (give-title '(miss jane adams))
(MISS JANE ADAMS)
CL-USER> (give-title '(john q public))
(MR JOHN Q PUBLIC)
CL-USER> (give-title '(barbara smith))
(MS BARBARA SMITH)
CL-USER> (give-title '(kim johnson))
(MR OR MS KIM JOHNSON)


we broke this problem down into simple little functions
we wrote and tested these functions one at a time
once TITLEDP MALEP FEMALEP were built, GIVE-TITLE turns into a fill-in-the-blank function

note the use of CONS to add the mr or ms title to NAME


decomposing a problem into subproblems is an important skill
lispers often see immediately how a problem breaks down into smaller logical-subdivisions

we are not there yet ... we need to keep brute-forcing our way through texts and practice until it clicks

we can do more things with the lists of names weve built:

CL-USER> (defun gender-ambiguous-names ()
           "out of the lists of names, the gender ambiguous will be returned ..."
           (intersection male-first-names female-first-names))
GENDER-AMBIGUOUS-NAMES
CL-USER> (gender-ambiguous-names)
(KIM)
CL-USER> (defun uniquely-male-names ()
           "out of the lists of name, the uniquely male will be returned ..."
           (set-difference male-first-names female-first-names))
UNIQUELY-MALE-NAMES
CL-USER> (uniquely-male-names)
(GEORGE FRED RICHARD JOHN)


so far, all the sets we have seen in this chapter have only contained symbols and numbers

we can also work with sets of lists ... keep going


--
MINI KEYBOARD EXERCISE
--
6.26 we are going to write a system that compares the descriptions of two objects and tells how many features they have in common ... the descriptions will be represented as a list of features, with the symbol -VS- separating the first object from the second ... thus:

(large red shiny cube -vs-
   small shiny red four-sided pyramid)
=> (2 COMMON FEATURES)

we will compose this program from several small functions that will be written and tested one at a time ...

6.26a write a function RIGHT-SIDE that returns all the features to the right of -VS- ... remember that MEMBER returns the entire sublist starting with the item for which you are searching ...

CL-USER> (defun right-side (x)
           "returns all fetures right of -VS- ..."
           (rest (member '-vs- x)))
RIGHT-SIDE
CL-USER> (right-side '(large red shiny cube -vs-
                       small shiny red four-sided pyramid))
(SMALL SHINY RED FOUR-SIDED PYRAMID)


6.26b write a function LEFT-SIDE that returns all features to the left of -VS- ... MEMBER cannot directly be used unless something is first done to the list ...

CL-USER> (defun left-side (x)
           "returns all the features to the left of -VS- ..."
           (right-side (reverse x)))
LEFT-SIDE
CL-USER> (left-side '(large red shiny cube -vs- small shiny red four-sided pyramid))
(CUBE SHINY RED LARGE)


6.26c write a function COUNT-COMMON that returns the number of features the left and right sides of the input have in common ...

CL-USER> (defun count-common (x)
           "returns the number of features shared between right-side and left-side of -VS- ..."
           (length (intersection (left-side x)
                                 (right-side x))))
COUNT-COMMON
CL-USER> (count-common '(large shiny red cube -vs-
                         small shiny red four-sided pyramid))
2


6.26d write the main function COMPARE that takes a list of features describing two objects (with a -VS- between) and reports the number of features they have in common ... COMPARE should return a list of form (n COMMON FEATURES) ...

CL-USER> (defun compare-vs-list (x)
           "compares a -VS- list and rertuns the number of shared features ..."
           (list (count-common x) 'common 'features))
COMPARE-VS-LIST
CL-USER> (compare-vs-list '(large red shiny cube -vs-
                            small shiny red four-sided pyramid))
(2 COMMON FEATURES)


6.26e CL-USER> (compare-vs-list '(small red metal cube -vs-
                            red plastic small cube))
(3 COMMON FEATURES)



----
6.8 LISTS AS TABLES
----

tables are a useful data-structure we can make from lists

a-lists
association lists are tables
tables are a-lists
association-lists are lists of lists
each list in an association list is called an entry
the car of each entry is the entry key

a table of five english words and their french equivalents, the keys are the english words:

CL-USER> (setf words
               '((one un)
                 (two deux)
                 (three trois)
                 (four quatre)
                 (five cinq)))
((ONE UN) (TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))



6.8.1 ASSOC

CL-USER> (documentation 'assoc 'function)
"Return the cons in ALIST whose car is equal (by a given test or EQL) to
   the ITEM."

ASSOC takes a key as input, looks up an entry in the given a-list (table), and returns the list that key belongs to in the a-list

CL-USER> (assoc 'three words)
(THREE TROIS)
CL-USER> (assoc 'four words)
(FOUR QUATRE)
CL-USER> (assoc 'six words)
NIL


ASSOC parses through the a-list one list at a time until it finds a key that matches the key for which it is searching, once hit then returned

NIL otherwise


ASSOC returns the entire list the given key belongs to within the a-list

we can tune ASSOC to our a-list by defining a new function TRANSLATE combining ASSOC and SECOND:

CL-USER> (defun translate (x)
           "returns the second element of list KEY in an a-list ..."
           (second (assoc x words)))
TRANSLATE
CL-USER> (translate 'one)
UN
CL-USER> (translate 'two)
DEUX
CL-USER> (translate 'three)
TROIS
CL-USER> (translate 'four)
QUATRE
CL-USER> (translate 'five)
CINQ
CL-USER> (translate 'six)
NIL


--
EXERCISE
--
6.27 should ASSOC be considered a predicate even though it never returns T ...

if the context falls on the same grounds as MEMBER being a predicate, then ASSOC should be considered a predicate



6.8.2 RASSOC

CL-USER> (documentation 'rassoc 'function)
"Return the cons in ALIST whose CDR is equal (by a given test or EQL) to
   the ITEM."

RASSOC is given a key, parses the cdr of each list within the given a-list and returns the cdr of the list containing the given key

RASSOC stands for reverse-ASSOC

RASSOC may work with symbols as keys, but the relevant list must be a dotted pair within the a-list:

CL-USER> (setf sounds
               '((cow . moo)
                 (pig . oink)
                 (cat . meow)
                 (dog . woof)
                 (bird . tweet)))
((COW . MOO) (PIG . OINK) (CAT . MEOW) (DOG . WOOF) (BIRD . TWEET))
CL-USER> (rassoc 'woof sounds)
(DOG . WOOF)
CL-USER> (assoc 'dog sounds)
(DOG . WOOF)

both RASSOC and ASSOC return as soon as they find the first matching table entry within the a-list
the rest of the rest of the a-list is not searched


--
EXERCISE
--
6.28 set the global variable PRODUCE, give the results:

CL-USER> (setf produce '((apple . fruit)
                         (celery . veggie)
                         (banana . fruit)
                         (lettuce . veggie)))
((APPLE . FRUIT) (CELERY . VEGGIE) (BANANA . FRUIT) (LETTUCE . VEGGIE))

CL-USER> (assoc 'banana produce)
(BANANA . FRUIT)
CL-USER> (rassoc 'fruit produce)
(APPLE . FRUIT)
CL-USER> (assoc 'lettuce produce)
(LETTUCE . VEGGIE)
CL-USER> (rassoc 'veggie produce)
(CELERY . VEGGIE)



----
6.9 PROGRAMMING WITH TABLES
----

lets use another example with ASSOC ...

create a table of objects and their descriptions, the descriptions will be similar to the mini-kb exercise
store the a-list table of descriptions in the global-variable THINGS:

CL-USER> (setf things '((object1 large green shiny cube)
                        (object2 small red dull metal cube)
                        (object3 red small dull plastic cube)
                        (object4 small dull blue metal cube)
                        (object5 small shiny red four-sided pyramid)
                        (object6 large shiny green sphere)))
((OBJECT1 LARGE GREEN SHINY CUBE) (OBJECT2 SMALL RED DULL METAL CUBE)
 (OBJECT3 RED SMALL DULL PLASTIC CUBE) (OBJECT4 SMALL DULL BLUE METAL CUBE)
 (OBJECT5 SMALL SHINY RED FOUR-SIDED PYRAMID)
 (OBJECT6 LARGE SHINY GREEN SPHERE))


we have an a-list THINGS as our table
... next we can construct functions that work with our a-list to return data

we will write a function returning to us how two objects differ

we can start building our function with blocks of smaller functions
each smaller function should be tested three times ...

DESCRIPTION:
CL-USER> (defun description (x)
           "called on KEY to retrieve the description of that object in the a-list ..."
           (rest (assoc x things)))
DESCRIPTION
CL-USER> (description 'object5)
(SMALL SHINY RED FOUR-SIDED PYRAMID)
CL-USER> (description 'object3)
(RED SMALL DULL PLASTIC CUBE)
CL-USER> (description 'object1)
(LARGE GREEN SHINY CUBE)

we can cross-reference the correctness of our function using ASSOC or RASSOC

CL-USER> (assoc 'object3 things)
(OBJECT3 RED SMALL DULL PLASTIC CUBE)

the differences between two objects are whatever properties appear in the description of the first but not the second, vice-versa
the lisp term for this is SET-EXCLUSIVE-OR:

CL-USER> (documentation 'set-exclusive-or 'function)
"Return new list of elements appearing exactly once in LIST1 and LIST2."

CL-USER> (defun differences (KEY1 KEY2)
           "called on KEY1 KEY2, returning how the two objects in the a-list differ ..."
           (set-exclusive-or (description KEY1)
                             (description KEY2)))
DIFFERENCES
CL-USER> (differences 'object1 'object3)
(PLASTIC DULL SMALL RED SHINY GREEN LARGE)
CL-USER> (differences 'object2 'object3)
(PLASTIC METAL)
CL-USER> (differences 'object5 'object6)
(SPHERE GREEN LARGE PYRAMID FOUR-SIDED RED SMALL)

all the differences in between object properties is returned


we can classify properties according to the type of quality to which they refer ...

here is an a-list (table) represented as a list of dotted-pairs:

CL-USER> (setf quality-table
               '((large . size)
                 (small . size)
                 (red . color)
                 (green . color)
                 (blue . color)
                 (shiny . luster)
                 (dull . luster)
                 (metal . material)
                 (plastic . material)
                 (cube . shape)
                 (sphere . shape)
                 (pyramid . shape)
                 (four-sided . shape)))
((LARGE . SIZE) (SMALL . SIZE) (RED . COLOR) (GREEN . COLOR) (BLUE . COLOR)
 (SHINY . LUSTER) (DULL . LUSTER) (METAL . MATERIAL) (PLASTIC . MATERIAL)
 (CUBE . SHAPE) (SPHERE . SHAPE) (PYRAMID . SHAPE) (FOUR-SIDED . SHAPE))

this table can be used as part the function QUALITY, that will return the quality a given property refers to:

CL-USER> (defun quality (KEY)
           "returns the quality KEY refers to in the a-list ..."
           (cdr (assoc KEY quality-table)))
QUALITY
CL-USER> (quality 'red)
COLOR
CL-USER> (quality 'large)
SIZE
CL-USER> (quality 'pyramid)
SHAPE

using DIFFERENCES and QUALITY we construct QUALITY-DIFFERENCE, a function that returns one quality that is different between a pair of objects:


CL-USER> (defun quality-differences (KEY1 KEY2)
           "called on KEY1 and KEY2, returns one quality difference between the two objects ..."
           (quality (first (differences KEY1 KEY2))))
QUALITY-DIFFERENCES
CL-USER> (quality-differences 'object1 'object2)
MATERIAL
CL-USER> (quality-differences 'object1 'object6)
SHAPE
CL-USER> (quality-differences 'object2 'object4)
COLOR


we can use SUBLIS to map a list of differences to a list of corresponding qualities:

CL-USER> (differences 'object3 'object4)
(METAL BLUE PLASTIC RED)
CL-USER> (sublis quality-table
                 (differences 'object3 'object4))
(MATERIAL COLOR MATERIAL COLOR)

eliminate duplicate return values:

CL-USER> (defun contrast (KEY1 KEY2)
           "removes duplicate differences between KEY1 and KEY2 from the a-list ..."
           (remove-duplicates
            (sublis quality-table (differences KEY1 KEY2))))
CONTRAST

CL-USER> (contrast 'object3 'object4)
(MATERIAL COLOR)
CL-USER> (contrast 'object1 'object5)
(SHAPE COLOR SIZE)
CL-USER> (contrast 'object2 'object3)
(MATERIAL)


--
EXERCISES
--
6.29 what lisp primitive returns the number of entries in a table ...

LENGTH returns the number of entries in an a-list(table)


6.30 make a table called BOOKS of five books and their authors ...

CL-USER> (setf books
               '((war-and-peace leo-tolstoy)
                 (oliver-twist charles-dickens)
                 (tom-sawyer mark-twain)
                 (kidnapped robert-louis-stevenson)
                 (candide voltaire)))
((WAR-AND-PEACE LEO-TOLSTOY) (OLIVER-TWIST CHARLES-DICKENS)
 (TOM-SAWYER MARK-TWAIN) (KIDNAPPED ROBERT-LOUIS-STEVENSON) (CANDIDE VOLTAIRE))


6.31 write the function WHO-WROTE that takes the name of a book as input and returns the book author ...

CL-USER> (defun who-wrote (KEY1)
           "returns the author associated with KEY1 in the a-list ..."
           (second (assoc KEY1 books)))
WHO-WROTE

CL-USER> (who-wrote 'war-and-peace)
LEO-TOLSTOY
CL-USER> (who-wrote 'kidnapped)
ROBERT-LOUIS-STEVENSON
CL-USER> (who-wrote 'oliver-twist)
CHARLES-DICKENS


6.32 if we (SETF BOOKS (REVERSE BOOKS)), what does WHO-WROTE do now ...

WHO-WROTE behaves the same:
CL-USER> (reverse books)
((CANDIDE VOLTAIRE) (KIDNAPPED ROBERT-LOUIS-STEVENSON) (TOM-SAWYER MARK-TWAIN)
 (OLIVER-TWIST CHARLES-DICKENS) (WAR-AND-PEACE LEO-TOLSTOY))

all reverse does is reverse the order of top level elements within the a-list
entry order is irrelevant as well because the given KEY1 is so specific and unique


6.33 can we use ASSOC to write WHAT-WROTE, that takes an authors name as input-key and returns the title of one of their books ... if not how ...

ASSOC cannot be utilized
rewriting the table with dotted pairs would allow us to achieve this with RASSOC:

CL-USER> (setf books
               '((war-and-peace . leo-tolstoy)
                 (oliver-twist . charles-dickens)
                 (tom-sawyer . mark-twain)
                 (kidnapped . robert-louis-stephenson)
                 (candide . voltaire)))
((WAR-AND-PEACE . LEO-TOLSTOY) (OLIVER-TWIST . CHARLES-DICKENS)
 (TOM-SAWYER . MARK-TWAIN) (KIDNAPPED . ROBERT-LOUIS-STEPHENSON)
 (CANDIDE . VOLTAIRE))

CL-USER> (defun what-wrote (KEY1)
           "called on KEY1, returns book title from list KEY1 in the a-list BOOKS ..."
           (first (rassoc KEY1 books)))
WHAT-WROTE
CL-USER> (what-wrote 'leo-tolstoy)
WAR-AND-PEACE
CL-USER> (what-wrote 'charles-dickens)
OLIVER-TWIST
CL-USER> (what-wrote 'voltaire)
CANDIDE


6.34 we want to find all the cities a given state contains ... ASSOC returns only the first entry with a matching key, not all of the entries ... ASSOC wont work for us here ... redesign the a-list(table) so that ASSOC does work ...

 redesigned a-list:
 CL-USER> (setf atlas
               '((pittsburgh pennsylvania)
                 (newark new-jersey)
                 (johnstown pennsylvania)
                 (colombus ohio)
                 (princeton new-jersey)
                 (trenton new-jersey)))
((PITTSBURGH PENNSYLVANIA) (NEWARK NEW-JERSEY) (JOHNSTOWN PENNSYLVANIA)
 (COLOMBUS OHIO) (PRINCETON NEW-JERSEY) (TRENTON NEW-JERSEY))



--
MINI KEYBOARD EXERCISE
--
6.35 create creature COMPUTERUS-HACKERUS, this creature only has five states -- sleeping eating stand-by programming debugging; the behavior is cyclic ... after debugging the creature goes to sleep for a while and the cycle is repeated ...


6.35a what type of data-structure would be most useful for representing the connection between a state and its successor ... write such a data-structure for the five-state cycle defined above, store in a global variable named NERD-STATES ...

this problem can be solved two ways ...

as a flat-list with MEMBER:

CL-USER> (setf nerd-states
                            '((eating sleeping)
                             (eating waiting)
                             (waiting programming)
                             (programming debugging)
                             (debugging sleeping)))
((EATING SLEEPING) (EATING WAITING) (WAITING PROGRAMMING)
 (PROGRAMMING DEBUGGING) (DEBUGGING SLEEPING))


or a table with ASSOC and dotted-pairs:

CL-USER> (setf nerd-states
               '((sleeping . eating)
                 (eating . waiting)
                 (waiting . programming)
                 (programming . debugging)
                 (debugging . sleeping)))
((SLEEPING . EATING) (EATING . WAITING) (WAITING . PROGRAMMING)
 (PROGRAMMING . DEBUGGING) (DEBUGGING . SLEEPING))


3.35b write NERDUS that takes the name of a state as input and uses the data-structure designed in 3.35a to determine the next state the creature will be in ... (NERDUS 'SLEEPING) => EATING  (NERDUS 'DEBUGGING) => SLEEPING ...

CL-USER> (defun nerdus (key)
           "returns the CDR of LIST containing input KEY in the a-list ..."
           (cdr (assoc key nerd-states)))
NERDUS

CL-USER> (nerdus 'sleeping)
EATING
CL-USER> (nerdus 'debugging)
SLEEPING
CL-USER> (nerdus 'eating)
WAITING


3.35c what is the result of ...

CL-USER> (nerdus 'playing-guitar)
NIL


3.35d when computerus hackerus ingests too many stimulants, it stops sleeping ... after completing debugging the hackerus skips the sleep step and continues to eating ... write SLEEPLESS-NERD that works just like NERDUS, except it never sleeps ...

CL-USER> (defun sleepless-nerd (x)
           "returns every state except SLEEPING in the NERD-STATES a-list ..."
           (let ((y (nerdus x)))
             (if (equal y 'sleeping)
                 (nerdus y)
                 y)))
WARNING: redefining COMMON-LISP-USER::SLEEPLESS-NERD in DEFUN
SLEEPLESS-NERD

CL-USER> (sleepless-nerd 'debugging)
EATING
CL-USER> (sleepless-nerd 'programming)
DEBUGGING
CL-USER> (sleepless-nerd 'sleeping)
EATING


3.35e hackerus has become addicted to stimulants and unusual behavior becomes habitual ... the creature now advances two states in the process ... write NERD-ON-CAFFEINE ...

CL-USER> (defun nerd-on-caffeine (x)
           "returns two state further than X in the NERD-STATES a-list ..."
           (nerdus (nerdus x)))
NERD-ON-CAFFEINE
CL-USER> (nerd-on-caffeine 'debugging)
EATING
CL-USER> (nerd-on-caffeine 'eating)
PROGRAMMING
CL-USER> (nerd-on-caffeine 'programming)
SLEEPING



--
SUMMARY
--
lists are an important data type ...
in lisp, lists ARE the data-type

it is essential to break your programming problem down into smaller blocks

we can make this process easier by writing and testing several simple functions, then combining them to produce a solution to the main problem ...


--
REVIEW EXERCISES
--

6.36 write a function to swap the first and last elements of any list ...

CL-USER> (defun swap-first-last (x)
           "swaps the first and last element of X ..."
           (let* ((a (reverse (rest x)))
                  (b (reverse (rest a))))
             (cons (first a)
                   (append b (list (first x))))))
SWAP-FIRST-LAST

CL-USER> (swap-first-last '(1 2 3 4))
(4 2 3 1)
CL-USER> (swap-first-last '(a b c d))
(D B C A)
CL-USER> (swap-first-last '(whale fish minnow))
(MINNOW FISH WHALE)

breaking this function down:

CL-USER> (defun swap-first-last (x)
           "swaps the first and last element of X ..."
           (let* ((a (reverse (rest x)))
                  (b (reverse (rest a))))
             (cons (first a)
                   (append b (list (first x))))))
SWAP-FIRST-LAST

evaluate the variables first

X = (1 2 3 4 5)
A = (5 4 3 2)
B = (2 3 4)

A:
CL-USER> (rest '(1 2 3 4 5))
(2 3 4 5)
CL-USER> (reverse '(2 3 4 5))
(5 4 3 2)

B:
CL-USER> (rest '(5 4 3 2))
(4 3 2)
CL-USER> (reverse '(4 3 2))
(2 3 4)

now that the local variables have been sequentially defined with LET* evaluate from (FIRST X) through the CONS argument:

CL-USER> (first '(1 2 3 4 5))
1
CL-USER> (list 1)
(1)
CL-USER> (append '(2 3 4) '(1))
(2 3 4 1)

with LIST, we create a new cons-cell to build on with what was returned by FIRST
and then APPEND the local-variable B (which is the list with the first and last elements missing)

finally

CL-USER> (first '(5 4 3 2))
5
CL-USER> (cons '5 '(2 3 4 1))
(5 2 3 4 1)

we get the FIRST from A ...
and CONS that on to our APPEND (2 3 4 1) return


6.37 ROTATE-LEFT and ROTATE-RIGHT are functions that rotate the elements of a list ... (ROTATE-LEFT '(A B C D E)) => (B C D E A) ... (ROTATE-RIGHT '(A B C D E)) => (E A B C D) ... write them ...

ROTATE-LEFT:
CL-USER> (defun rotate-left (x)
           "rotates the elements of a list left ..."
           (append (rest x) (list (first x))))
ROTATE-LEFT

broken-down:

establish variables
X = (1 2 3 4 5)

call FIRST then LIST on X:
CL-USER> (first '(1 2 3 4 5))
1
CL-USER> (list 1)
(1)

that evaluates to (1) ...
hang on to that

next part
call REST on X:
CL-USER> (rest '(1 2 3 4 5))
(2 3 4 5)

call append on (2 3 4 5) then (1):
CL-USER> (append '(2 3 4 5) '(1))
(2 3 4 5 1)

this is our final result

(2 3 4 5 1)

the elements in our list have shifted(rotated) left ...

next ...

ROTATE-RIGHT:    ; attempt to build this one without training wheels, then break it back down again ...
X = (1 2 3 4 5)
(reverse '(1 2 3 4 5))
(5 4 3 2 1)
(first '(5 4 3 2 1))
5
(list '5)
(5)
(append x

(append (list
        (first
        (reverse

SOOOOOOOOOOOOOOOOO WROOOOOOOOOONG

dont waste time

CL-USER> (defun rotate-right (x)
           "rotates the elements of a list left ..."
           (let ((r (reverse x)))
             (cons (first r)
                   (reverse (rest r)))))
ROTATE-RIGHT

break it down ...
first we establish what are variable definitions are
X = (1 2 3)
R = (3 2 1)

second, evaluate from bottom to top:
CL-USER> (rest '(3 2 1))
(2 1)

call REVERSE on the return value of REST (2 1):
CL-USER> (reverse '(2 1))
(1 2)

save that (1 2) ...

ascending

CL-USER> (first '(3 2 1))
3

now CONS 3 to (1 2):
CL-USER> (cons '3 '(1 2))
(3 1 2)

the return value of (ROTATE-RIGHT '(1 2 3)) is (3 1 2) ...

CL-USER> (rotate-right '(1 2 3))
(3 1 2)

testing our new functions ROTATE-LEFT and ROTATE-RIGHT -- all green

CL-USER> (rotate-left '(1 2 3))
(2 3 1)
CL-USER> (rotate-left '(2 3 1))
(3 1 2)
CL-USER> (rotate-left '(3 1 2))
(1 2 3)
CL-USER> (rotate-right '(1 2 3))
(3 1 2)
CL-USER> (rotate-right '(3 1 2))
(2 3 1)
CL-USER> (rotate-right '(2 3 1))
(1 2 3)


6.38 give an example of two sets X and Y such that (SET-DIFFERENCE X Y) equals (SET-DIFFERENCE Y X) ... also give an example in which the set differences are not equal ...

order is irrelevant when working with sets, and element repetition is disqualification ...

that being the case the SET-DIFFERENCE between sets (X Y) (Y X) is always equal as long as the sets are identical in the elements that set contains (including NIL) order is irrelevant ...

unequal results in SET-DIFFERENCE determine that sets X and Y are not equal sets (they do not contain the same total identical elements) ... X could be (A) and Y could be (A B) ... same keys, not the same list ...


6.39 recall the unary arithmetic system developed in the advanced topics section of c2 ... list the functions that perform unary addition ...

APPEND


6.40 show how to transform the list (A B C D) into a table so that the ASSOC function using the table gives the same result as MEMBER using the list ...

CL-USER> (setf bung-table
               '((a b c d)
                 (b c d)
                 (c d)
                 (d)))
((A B C D) (B C D) (C D) (D))



FUNCTIONS COVERED

list functions: APPEND REVERSE NTH NTHCDR LAST REMOVE
set functions: UNION INTERSECTION SET-DIFFERENCE SET-EXCLUSIVE-OR MEMBER SUBSETP REMOVE-DUPLICATES
table functions: ASSOC RASSOC



---
KEYBOARD EXERCISE
---

in this keyboard exercise we are gonna write routines for moving robbie the robot around in the house ...
look at the book or the ref docs for the map ...

robbie can move any of the four cardinal directions (north south east west)

the layout of the house can be described in the table(a-list) ROOMS, with one element per room ...

((living-room ...)
 (upstairs-bedroom ...)
 (dining-room ...)
 (kitchen ...)
 (pantry ...)
 (downstairs-bedroom ...)
 (back-stairs ...)
 (front-stairs ...)
 (library ...))

each entry in ROOMS is a table ...
... listing the directions robbie can take from his current location

using the four cardinal directions, robbie should be able reach every room in the house

CL-USER> (setf rooms
               '((living-room (north front-stairs)
                              (south dining-room)
                              (east kitchen))
                 (upstairs-bedroom (west library)
                                   (south front-stairs))
                 (dining-room (north living-room)
                              (east pantry)
                              (west downstairs-bedroom))
                 (kitchen (west living-room)
                          (south pantry))
                 (pantry (north kitchen)
                         (west dining-room))
                 (downstairs-bedroom (north back-stairs)
                                     (east dining-room))
                 (back-stairs (south downstairs-bedroom)
                              (north library))
                 (front-stairs (north upstairs-bedroom)
                               (south living-room))
                 (library (east upstairs-bedroom)
                          (south back-stairs))))
((LIVING-ROOM (NORTH FRONT-STAIRS) (SOUTH DINING-ROOM) (EAST KITCHEN))
 (UPSTAIRS-BEDROOM (WEST LIBRARY) (SOUTH FRONT-STAIRS))
 (DINING-ROOM (NORTH LIVING-ROOM) (EAST PANTRY) (WEST DOWNSTAIRS-BEDROOM))
 (KITCHEN (WEST LIVING-ROOM) (SOUTH PANTRY))
 (PANTRY (NORTH KITCHEN) (WEST DINING-ROOM))
 (DOWNSTAIRS-BEDROOM (NORTH BACK-STAIRS) (EAST DINING-ROOM))
 (BACK-STAIRS (SOUTH DOWNSTAIRS-BEDROOM) (NORTH LIBRARY))
 (FRONT-STAIRS (NORTH UPSTAIRS-BEDROOM) (SOUTH LIVING-ROOM))
 (LIBRARY (EAST UPSTAIRS-BEDROOM) (SOUTH BACK-STAIRS)))


--
EXERCISE
--
6.41 use the global-variable ROOMS as the a-list(table) for the following


6.41a write a function CHOICES that takes the name of a room as input and returns the table of permissible directions robbie may take from that room ... test for three rooms ...

CHOICES:
CL-USER> (defun choices (room)
           "input ROOM name from a-list ROOMS, returns permissible directions from ROOM ..."
           (rest (assoc room rooms)))
CHOICES
CL-USER> (choices 'pantry)
((NORTH KITCHEN) (WEST DINING-ROOM))
CL-USER> (choices 'back-stairs)
((SOUTH DOWNSTAIRS-BEDROOM) (NORTH LIBRARY))
CL-USER> (choices 'library)
((EAST UPSTAIRS-BEDROOM) (SOUTH BACK-STAIRS))


6.41b write function LOOK, two inputs, a direction and a room -- returns where robbie would end up if he moved in DIRECTION from ROOM ...

LOOK:
CL-USER> (defun look (dir room)
           "takes DIRECTION and ROOM from a-list ROOMS; returns destination from ROOM taking DIRECTION ..,"
           (second (assoc dir (choices room))))
LOOK
CL-USER> (look 'front-stairs 'south)
NIL
CL-USER> (look 'west 'pantry)
DINING-ROOM
CL-USER> (look 'south 'front-stairs)
LIVING-ROOM
CL-USER> (look 'east 'library)
UPSTAIRS-BEDROOM


6.41c LOC will be the global variable that holds robbies location ... type an expression to set his location to be the pantry ... use the following function to change robbies location ...

CL-USER> (defun set-robbie-location (place)
           "moves robbie to PLACE by setting the variable to LOC ..."
           (setf loc place))
SET-ROBBIE-LOCATION
CL-USER> (set-robbie-location 'pantry)
PANTRY


6.41d write function HOW-MANY-CHOICES that tells how many choices robbie has for where to move next ... LOC should be referred to ... if he is in the pantry, HOW-MANY-CHOICES should return 2 ...

HOW-MANY-CHOICES:
CL-USER> (defun how-many-choices ()
           "takes none; returns the number allowable directions from LOC ..."
           (length (choices loc)))
HOW-MANY-CHOICES
CL-USER> (how-many-choices)
2
CL-USER> (set-robbie-location 'living-room)
LIVING-ROOM
CL-USER> (how-many-choices)
3
CL-USER> (set-robbie-location 'kitchen)
KITCHEN
CL-USER> (how-many-choices)
2


6.41e write predicate UPSTAIRSP that returns T if input is an upstairs location (library upstairs-bedroom) ... write ONSTAIRSP, returns T if input is either FRONT-STAIRS or BACK-STAIRS ...

UPSTAIRSP:
CL-USER> (defun upstairsp (x)
           "takes X, returns T if X is upstairs from a-list ROOMS ..."
           (or (equal x 'library)
               (equal x 'upstairs-bedroom)))
UPSTAIRSP
CL-USER> (upstairsp 'kitchen)
NIL
CL-USER> (upstairsp 'library)
T
CL-USER> (upstairsp 'front-stairs)
NIL

ONSTAIRSP:
CL-USER> (defun onstairsp (x)
           "takes X, returns T if X is on the stairs from a-list ROOMS ..."
           (or (equal x 'back-stairs)
               (equal x 'front-stairs)))
ONSTAIRSP
CL-USER> (onstairsp 'kitchen)
NIL
CL-USER> (onstairsp 'front-stairs)
T
CL-USER> (onstairsp 'dining-room)
NIL


6.41f write function WHERE that tells where robbie is ...

WHERE:
CL-USER> (defun where ()
           "takes none; returns where robbie is from a-list ROOMS ..."
           (if (onstairsp loc)
               (list 'robbie 'is 'on 'the loc)
               (list 'robbie 'is
                     (if (upstairsp loc)
                         'upstairs
                         'downstairs)
                     'in 'the loc)))
WHERE
CL-USER> (where)
(ROBBIE IS ON THE FRONT-STAIRS)
CL-USER> (set-robbie-location 'front-stairs)
FRONT-STAIRS
CL-USER> (where)
(ROBBIE IS ON THE FRONT-STAIRS)
CL-USER> (set-robbie-location 'kitchen)
KITCHEN
CL-USER> (where)
(ROBBIE IS DOWNSTAIRS IN THE KITCHEN)
CL-USER> (set-robbie-location 'dining-room)
DINING-ROOM
CL-USER> (where)
(ROBBIE IS DOWNSTAIRS IN THE DINING-ROOM)


6.41g write MOVE, takes DIRECTION and moves robbie to LOC ... makes use of LOOK SET-ROBBIE-LOCATION ... if robbie cant move in that direction, a message should be returned ...

MOVE:
CL-USER> (defun move (dir)
           "takes DIR, then SET-ROBBIE-LOCATION to LOC in that DIR ..."
           (let ((new-loc (look dir loc)))
             (cond ((null new-loc)
                    '(ouch! robbie hit a wall))
                   (t (set-robbie-location new-loc)
                      (where)))))
MOVE
CL-USER> (set-robbie-location 'living-room)
LIVING-ROOM
CL-USER> (move 'east)
(ROBBIE IS DOWNSTAIRS IN THE KITCHEN)
CL-USER> (move 'north)
(OUCH! ROBBIE HIT A WALL)
CL-USER> (move 'south)
(ROBBIE IS DOWNSTAIRS IN THE PANTRY)
CL-USER> (move 'west)
(ROBBIE IS DOWNSTAIRS IN THE DINING-ROOM)


6.41h starting form PANTRY through LIBRARY via BACK-STAIRS ... then to KITCHEN but not through the DOWNSTAIRS-BEDROOM ...

CL-USER> (set-robbie-location 'pantry)
PANTRY
CL-USER> (move 'west)
(ROBBIE IS DOWNSTAIRS IN THE DINING-ROOM)
CL-USER> (move 'west)
(ROBBIE IS DOWNSTAIRS IN THE DOWNSTAIRS-BEDROOM)
CL-USER> (move 'north)
(ROBBIE IS ON THE BACK-STAIRS)
CL-USER> (move 'library)
(OUCH! ROBBIE HIT A WALL)
CL-USER> (move 'north)
(ROBBIE IS UPSTAIRS IN THE LIBRARY)
CL-USER> (move 'east)
(ROBBIE IS UPSTAIRS IN THE UPSTAIRS-BEDROOM)
CL-USER> (move 'south)
(ROBBIE IS ON THE FRONT-STAIRS)
CL-USER> (move 'south)
(ROBBIE IS DOWNSTAIRS IN THE LIVING-ROOM)
CL-USER> (move 'east)
(ROBBIE IS DOWNSTAIRS IN THE KITCHEN)



---
6 Advanced Topics
---
6.10 TREES
---

trees are nested-lists

all the functions we have covered so far operate on the top-level of a list, any other list-level-structure is unknown to them ...

SUBST and SUBLIS are two built-in functions that work on the entire list structure, not just the top-level



6.10 SUBST

CL-USER> (documentation 'subst 'function)
"Substitutes new for subtrees matching old."

the SUBST function substitutes one item for another everywhere it appears in a list

SUBST takes three inputs -- "substitute x for y in z"

CL-USER> (subst 'fred 'bill
                '(bill jones sent me an itemized bill for the tires))
(FRED JONES SENT ME AN ITEMIZED FRED FOR THE TIRES)

if the symbol being substituted doesnt appear in the given list, SUBST returns the original list unchanged

CL-USER> (subst 'bill 'fred '(keep off the grass))
(KEEP OFF THE GRASS)


CL-USER> (subst 'on 'off '(keep off the grass))
(KEEP ON THE GRASS)


SUBST looks at the entire structure of the list, not just the top-level elements

CL-USER> (subst 'the 'a '((a hatter) (a hare) and (a dormouse)))
((THE HATTER) (THE HARE) AND (THE DORMOUSE))



6.10.2 SUBLIS

CL-USER> (documentation 'sublis 'function)
"Substitute from ALIST into TREE nondestructively."

SUBLIS is like SUBST, except it can make many substitutions simultaneously


the first input to SUBLIS is a table whose entries are dotted-pairs

the second input is the list in which the substitutions are to be made


CL-USER> (sublis '((roses . violets) (red . blue))
                 '(roses are red))
(VIOLETS ARE BLUE)


CL-USER> (sublis dotted-words '(three one four one five))
(TROIS UN QUATRE UN CINQ)


--
EXERCISE
--
6.42 write function ROYAL-WE that changes every occurrence of the symbol I in a list to the symbol WE ... calling ROYAL-WE on (IF I LEARN LISP I WILL BE PLEASED) should return (IF WE LEARN LISP WE WILL BE PLEASED) ...

CL-USER> (defun royal-we (sent)
           "takes SENT; replaces all occurence of the symbol I to the symbol WE ..."
           (subst 'we 'i sent))
ROYAL-WE
CL-USER> (royal-we '(if i learn lisp i will be pleased))
(IF WE
    LEARN
    LISP
    WE
    WILL
    BE
    PLEASED)



---
6.11 EFFICIENCY OF LIST OPERATIONS
---

recall how lists appear symmetrical, but really arent ...

this asymmetry shows in the relative efficiency of certain operations

retrieving the first element of a list has virtually no cost to efficiency
retrieving the last element of a list could cost quite a bit ...

FIRST only has to retrieve the pointer to the first cons cell
LAST must follow the chain of pointers from first cell to the cell whose cdr is an atom ... and only then can we look in the car

"cdring down the list" could be cumbersome in some situations


computers can follow chains of a hundred thousand cons cells or more in milli-seconds ... the difference in efficiency wouldnt show unless the system being built was very large


the amount of consing a function performs can affect a systems efficiency by creating too many cons cells or maybe even creating useless cons cells that take up address space in computer memory ... garbage-collection has to be carried out on systems that have taken up too much memory space on the machine


CL-USER> (defun add-to-app-end (x y)
           "adds X to Y through APPEND ..."
           (append x (list y)))
ADD-TO-APP-END

X a (list of n elements) is input to APPEND
APPEND places the list Y onto the end
ADD-TO-APP-END creates n+1 cons cells


CL-USER> (defun add-to-rev-end (x y)
           "adds X to Y through REVERSE and CONS ..."
           (reverse (cons y (reverse x))))
ADD-TO-REV-END

X (a list of n elements) is input to REVERSE
REVERSE creates n number of cons cells to create the newly reversed list
CONS is called on the second input Y and the newly reversed list, creating one new cons cell
finally REVERSE is called on the result of that, creating another n+1 new cons cells
ADD-TO-REV-END creates n+1+(n+1) cons cells, the final n+1 forms the result ... while the other n+1 are thrown away shortly after creation becoming garbage


ADD-TO-APP-END is the more efficient function using less cons cells and being more efficient to type and read



---
6.12 SHARED STRUCTURE
---

two lists share structure if they have cons cells in common

lists typed from the keyboard will never share structure
READ builds every list with newly created cons cells

we can share structure between lists with CAR CDR and CONS by using them to point another shared structure(s)

CL-USER> (setf x '(a b c))
(A B C)
CL-USER> (setf y (cons 'd (cdr x)))
(D B C)

X is (A B C)
y is (D B C)
the lists share the same cons cell structure (B C)
(B C) is shared because Y is built from (CDR X)

defining the global-variable Y as (SETF Y '(D B C)) does not share the same structure (B C) as X because nothing within the definition points to those existing elements
the (D B C) in this Y are all new elements ...



---
6.13 EQUALITY OF OBJECTS
---

in lisp symbols are unique ... only one symbol with a given name can remain in computer memory

every object in computer memory has a numbered location, the address

symbols have unique addresses
(TIME AFTER TIME)
has two occurrences of TIME, those two occurrences are referring to the same address
there cannot be two separate symbols named TIME


lists are not unique
there can easily be two different lists of (A B C) from cons cell chains that are complete separate
the symbols within (A B C) that the lists (A B C) are pointing to are unique and are all referring to the same address


these concepts of symbols addresses and lists are reason why EQUAL cannot compare symbols by addresses
EQUAL compares lists element by element

CL-USER> (setf x1 (list 'a 'b 'c))    ; makes a new (A B C)
(A B C)
CL-USER> (setf x2 (list 'a 'b 'c))    ; makes a new (A B C)
(A B C)
CL-USER> (equal x1 x2)    ; lists are EQUAL
T


if we are trying to determine whether two pointers point to the same object, we have to compare addresses

lists are EQ if they have the same address ... element by element comparison is never carried out

CL-USER> (eq x1 x2)    ; these two arent EQ
NIL
CL-USER> (setf z x1)    ; now Z points to X1
(A B C)
CL-USER> (eq z x1)    ; that means Z and XL are EQ
T
CL-USER> (eq z '(a b c))    ; these lists have different addresses
NIL
CL-USER> (equal z '(a b c))    ; but they have the same elements
T


CL-USER> (documentation 'equal 'function)
"Return T if X and Y are EQL or if they are structured components whose
elements are EQUAL. Strings and bit-vectors are EQUAL if they are the same
length and have identical components. Other arrays must be EQ to be EQUAL."

CL-USER> (documentation 'eq 'function)
"Return T if OBJ1 and OBJ2 are the same object, otherwise NIL."

EQ is faster than EQUAL
EQ only has to compare addresses to one another
EQUAL has to first test if the inputs are lists, then corresponding elements are matched against one another

when symbols are being compared, lisp programmers utilize EQ
lisp programmers do not typically use EQ on lists, unless they are determining whether two cons cells are the same
numbers have different internal representations in different lisps, therefore EQ shall not be used to compare numbers


CL-USER> (documentation 'eql 'function)
NIL    ; hmm ... see EQUAL i suppose

the EQL predicate is a slightly more general variant of EQ
EQL compares the addresses of objects like EQ, except that when comparing two numbers of the same type (both integers) -- it compares value instead of address

numbers of different types are not EQL, even if their values are the same ...

CL-USER> (eql 'foo 'foo)
T
CL-USER> (eql 3 3)
T
CL-USER> (eql 3 3.0)
NIL
CL-USER> (equal 3 3.0)
NIL
CL-USER> (equal 3 3)
T
CL-USER> (equal 'foo 'foo)
T


... maybe EQUAL and EQL are the same now days ...

EQL is the standard comparison predicate in common lisp
functions such as MEMBER ASSOC utilize EQL as the testing tool within their function definitions ... although they can be told to use other ones ...


CL-USER> (documentation '= 'function)
"Return T if all of its arguments are numerically equal, NIL otherwise."

= compares numbers of different types that hold the same value
it is the most efficient way to compare two numbers

CL-USER> (= 3 3.0)
T
CL-USER> (= 3 3)
T
CL-USER> (= 'foo 'foo)
; Evaluation aborted on #<TYPE-ERROR expected-type: NUMBER datum: FOO>.


CL-USER> (documentation 'equalp 'function)
NIL    ; hmm ...

EQUALP is a predicate similar to EQUAL, but more liberal when comparing elements (... like ignoring case distinctions between symbols in strings)

CL-USER> (equal "foo bar" "Foo BAR")
NIL
CL-USER> (equalp "foo bar" "Foo BAR")
T


EQ (not for numbers)
the fastest equality test; compares addresses; lisp programmers use it to compare symbols quickly and test whether two cons cells are physically the same object

EQL (default equality test)
can compare numbers of the same type safely

EQUAL
general use predicate for beginners; compares lists element by element; otherwise same as EQL

EQUALP
liberal EQUAL; ignores things like case distinctions between symbols in strings;

= (only accepts numbers)
most efficient way to compare numbers; the only way to compare numbers of disparate types (= 3 3.0)



---
6.14 KEYWORD ARGUMENTS
---

keyword arguments are optional arguments that can be used on many lisp functions


REMOVE takes an optional argument called :COUNT that tells it how many instances of the item to remove

CL-USER> (setf text '(b a n a n a - p a n d a))
(B A N A N A - P A N D A)
CL-USER> (remove 'a text)    ; remove all A
(B N N - P N D)
CL-USER> (remove 'a text :count 3)    ; remove 3 A
(B N N - P A N D A)


REMOVE also accepts a :FROM-END keyword
if :FROM-END holds a non-nil value, REMOVE would start from the end of the list ...

CL-USER> (remove 'a text :count 2 :from-end t)
(B A N A N A - P N D)


a keyword is a special type of symbol whose name is always preceded by a colon


COUNT and :COUNT are not the same symbols
they are different objects and are not EQ to another
they exist in different packages ...


keywords always evaluate to themselves, they do not need to be quoted

it is an error to try and change the value of a keyword


CL-USER> (documentation 'keywordp 'function)
"Return true if Object is a symbol in the \"KEYWORD\" package."

KEYWORDP returns T if its input is a keyword ...

CL-USER> :count
:COUNT
CL-USER> (symbolp :count)
T
CL-USER> (equal :count 'count)
NIL
CL-USER> (keywordp 'count)
NIL
CL-USER> (keywordp :count)
T


MEMBER takes keyword arguments

MEMBER utilizes EQL in its function body to test whether an item appears in a set
EQL will work correctly for both symbols and numbers, but if our set contains a list we get an error

EQUAL must be utilized to evaluate lists

CL-USER> (setf cards
               '((3 clubs) (5 diamonds) (ace spades)))
((3 CLUBS) (5 DIAMONDS) (ACE SPADES))
CL-USER> (member '(5 diamonds) cards)
NIL
CL-USER> (second cards)
(5 DIAMONDS)
CL-USER> (eql (second cards) '(5 diamonds))
NIL
CL-USER> (equal (second cards) '(5 diamonds))
T


the :TEST keyword can be used with MEMBER to specify a different function for the equality test
we write '#EQUAL to specially quote the function for use as an input to MEMBER

CL-USER> (member '(5 diamonds) cards :test #'equal)
((5 DIAMONDS) (ACE SPADES))


all functions that include equality tests accept :TEST as a keyword argument

REMOVE is another example

CL-USER> (remove '(5 diamonds) cards)
((3 CLUBS) (5 DIAMONDS) (ACE SPADES))
CL-USER> (remove '(5 diamonds) cards :test #'equal)
((3 CLUBS) (ACE SPADES))
CL-USER> cards
((3 CLUBS) (5 DIAMONDS) (ACE SPADES))


UNION INTERSECTION SET-DIFFERENCE ASSOC RASSOC SUBST SUBLIS all accept :TEST as a keyword


FUNCTIONS COVERED
tree-functions: SUBST SUBLIS
additional-equality-functions: EQ EQL EQUALP =
keyword-predicate: KEYWORDP



---
7 Applicative Programming
---
7.1 INTRODUCTION
---

applicative-programming is based on the idea that functions are data
... along with symbols and lists,

a lisp programmer should be able to pass functions as inputs to other functions
a lisp programmer should be able to get newly created functions as return values

a lisp programmer can


applicative operators are functions that take another function as input and apply it to the elements of a list in various ways



---
7.2 FUNCALL
---

CL-USER> (documentation 'funcall 'function)
"Call FUNCTION with the given ARGUMENTS."

FUNCALL is the nucleus of these applicative operators


FUNCALL calls a function on some inputs

CL-USER> (funcall #'cons 'a 'b)
(A . B)

the sharp-quote notation is the correct way to quote a function in common lisp

CL-USER> (setf fn #'cons)
#<FUNCTION CONS>
CL-USER> fn
#<FUNCTION CONS>
CL-USER> (type-of fn)
FUNCTION
CL-USER> (funcall fn 'c 'd)
(C . D)

the value of the variable FN is a function object
the function object is the symbol CONS that represents the machine code CONS in address

TYPE-OF returns FUNCTION
the return value of FN (CONS the function object) is a function


only ordinary functions can be quoted with #' ...

CL-USER> #'cons
#<FUNCTION CONS>
CL-USER> #'if
#<CLOSURE (:SPECIAL IF) {10007933BB}>
CL-USER> #'turnips
; Evaluation aborted on #<UNDEFINED-FUNCTION TURNIPS {1005EC5433}>.
CL-USER> #'defun
#<CLOSURE (:MACRO DEFUN) {100079938B}>    ; this must have changed ...



---
7.3 THE MAPCAR OPERATOR
---

CL-USER> (documentation 'mapcar 'function)
"Apply FUNCTION to successive tuples of elements of LIST and MORE-LISTS.
Return list of FUNCTION return values."
CL-USER> #'mapcar
#<FUNCTION MAPCAR>

MAPCAR applies a function to each element of a list, one at a time, then returns a list of the results


CL-USER> (defun square (n)
           "takes N; returns N multiplied by N ..."
           (* n n))
SQUARE
CL-USER> (square 3)
9
CL-USER> (square '(1 2 3 4 5))
; Evaluation aborted on #<TYPE-ERROR expected-type: NUMBER datum: (1 2 3 4 5)>.

SQUARE cannot square a list of numbers by itself
* doesnt work on lists

CL-USER> (mapcar #'square '(1 2 3 4 5))
(1 4 9 16 25)
CL-USER> (mapcar #'square '(3 8 -3 5 2 10))
(9 64 9 25 4 100)

we can apply MAPCAR to SQUARE to square each element one at a time on a given list

each element of the input list to MAPCAR is mapped independently to a corresponding element in the output ...


when MAPCAR is used on a list of length n,
the list that is returned will have exactly n elements

if MAPCAR is used on the empty list,
the empty list is returned

CL-USER> (mapcar #'square '())
NIL



---
7.4 MANIPULATING TABLES WITH MAPCAR
---

set the global variable WORDS to a table of english and french words

CL-USER> (setf words
               '((one un)
                 (two deux)
                 (three trois)
                 (four quatre)
                 (five cinq)))
((ONE UN) (TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))


extract the english words with FIRST

CL-USER> (mapcar #'first words)
(ONE TWO THREE FOUR FIVE)


extract the french words with SECOND

CL-USER> (mapcar #'second words)
(UN DEUX TROIS QUATRE CINQ)


REVERSE translation

CL-USER> (mapcar #'reverse words)
((UN ONE) (DEUX TWO) (TROIS THREE) (QUATRE FOUR) (CINQ FIVE))


define TRANSLATE with ASSOC and SECOND

CL-USER> (defun translate (x)
           "translate a string of english words into french ones ..."
           (second (assoc x words)))
TRANSLATE
CL-USER> (mapcar #'translate '(three one four one five))
(TROIS UN QUATRE UN CINQ)

to translate a string of english words to french ones ...


--
EXERCISES
--

7.1 write an ADD1 function that adds one to its input ... then write an expression to add one to each element of the list (1 3 5 7 9) ...

CL-USER> (defun add1 (x)
           "adds one to an integer X"
           (+ x 1))
ADD1
CL-USER> (mapcar #'add1 '(1 3 5 7 9))
(2 4 6 8 10)


7.2 let the global variable DAILY-PLANET hold a table ... entries consist of last-name first-name social-security-number job-title ... extract the socials ...

CL-USER> (setf daily-planet
               '((olsen jimmy 123-76-4535 cub-reporter)
                 (kent clark 089-52-6787 reporter)
                 (lane lois 951-26-1438 reporter)
                 (white perry 355-16-7439 editor)))
((OLSEN JIMMY |123-76-4535| CUB-REPORTER) (KENT CLARK |089-52-6787| REPORTER)
 (LANE LOIS |951-26-1438| REPORTER) (WHITE PERRY |355-16-7439| EDITOR))

CL-USER> (mapcar #'third daily-planet)
(|123-76-4535| |089-52-6787| |951-26-1438| |355-16-7439|)


7.3 write an expression to apply the ZEROP predicate to each element of the list (2 0 3 4 0 -5 -6) ... Ts and NILs should be the return values ...

CL-USER> (mapcar #'zerop '(2 0 3 4 0 -5 -6))
(NIL T NIL NIL T NIL NIL)


7.4 define GREATER-THAN-FIVE ... use mapcar on (2 0 3 4 0 -5 -6) ...

CL-USER> (defun greater-than-five-p (n)
           "determines whether n is greater than 5 ..."
           (> n 5))
GREATER-THAN-FIVE-P
CL-USER> (mapcar #'greater-than-five-p '(2 0 3 4 0 -5 -6))
(NIL NIL NIL NIL NIL NIL NIL)



---
7.5 LAMBDA EXPRESSIONS
---

there are two ways to specify the function to be used by an applicative operator

one
we can use DEFUN to define a function, then specify the new function by #'new-function in mapcar


two
pass the function definition directly through a lambda-expression

CL-USER> (mapcar #'(lambda (n) (* n n)) '(1 2 3 4 5))
(1 4 9 16 25)


LAMBDAs look similar to DEFUNs
lambda expressions are missing the function name and LAMBDA appears instead of DEFUN ...

lambda expressions are unnamed functions
LAMBDA is not a macro or special function that needs to be evaluated like DEFUN

LAMBDA is a sort of marker stating "this is a function ..."


lambda expressions are especially useful for synthesizing one input functions from related two input functions ...

CL-USER> (mapcar #'(lambda (n) (* n 10)) '(1 2 3 4 5))
(10 20 30 40 50)

a lambda expression of one input that multiplies its input by 10 fed to MAPCAR to evaluate each element of a list


CL-USER> (mapcar #'(lambda (x) (list 'hi 'there x))
                 '(joe fred wanda))
((HI THERE JOE) (HI THERE FRED) (HI THERE WANDA))

adding HI THERE to the front of each element and listing them


CL-USER> (lambda (n) (* n 10))
#<FUNCTION (LAMBDA (N)) {1004681E9B}>
CL-USER> #'(lambda (n) (* n 10))
#<FUNCTION (LAMBDA (N)) {1004681FEB}>

the objects we are returned by a (LAMBDA ...) expression are called lexical-closures


--
EXERCISES
--

7.5 write a lambda expression to subtract seven from a number ...

(lambda (n) (- n 7))


7.6 write a lambda expression that returns T if its input is T or NIL, but NIL for any other input ...

(lambda (x)
"returns T if its input is T or NIL; NIL for any other ..."
(or (null x) (equal x t)))


7.7 write a function that takes a list such as (UP DOWN UP UP) and inverts each element returning (DOWN UP DOWN DOWN) ...

CL-USER> (defun flip-element (list)
           "inverts individual UP DOWN elements in a given list ..."
           (mapcar #'(lambda (e)
                       (if (equal e 'up) 'down 'up))
                   list))
FLIP-ELEMENT
CL-USER> (flip-element '(up down up up))
(DOWN UP DOWN DOWN)
CL-USER> (flip-element '(down down down))
(UP UP UP)
CL-USER> (flip-element '(up up dog))
(DOWN DOWN UP)



---
7.6 THE FIND-IF OPERATOR
---

FIND-IF is another applicative operator

giving FIND-IF a predicate and a list as input, returns the first element of the list for which the predicate returns true (any non-NIL) value

CL-USER> (find-if #'oddp '(2 4 6 7 8 9 10 11))
7
CL-USER> (find-if #'(lambda (x) (> x 3))
                  '(2 4 6 7 8 9))
4
CL-USER> (find-if #'oddp '(2 4 6 8))
NIL

FIND-IF returns NIL if no given elements satisfy the predicate



---
7.7 WRITING ASSOC WITH FIND-IF
---

ASSOC searches for a table entry with a specified key

we can write a simple version of ASSOC that uses FIND-IF to search the table

CL-USER> (defun my-assoc (key table)
           (find-if #'(lambda (entry)
                        (equal key (first entry)))
                    table))
MY-ASSOC
CL-USER> (my-assoc 'two words)
(TWO DEUX)
CL-USER> (my-assoc 'five words)
(FIVE CINQ)
CL-USER> (my-assoc 'four words)
(FOUR QUATRE)
CL-USER> words
((ONE UN) (TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))

the lambda expression (actually a lexical-closure) that MY-ASSOC passes to FIND-IF takes a table entry such as (ONE UN) as input
it returns T if the first element of the entry matches the key that is the first input to MY-ASSOC
FIND-IF calls the closure on each entry in the table until it finds one that makes the closure return T

(EQUAL KEY (FIRST ENTRY))
refers to two variables,
ENTRY -- local to the lambda expression
KEY -- local to MY-ASSOC

lambda expressions can refer to their own local variables as well as the other local variables of the larger function containing the lambda expression


--
EXERCISES
--

7.8 write a function that takes two inputs (X and K) and returns the first number in the list X that is roughly equal to K ... roughly being no less than K-10 and no more than K+10 ...

CL-USER> (defun roughly-equal (e k)
           "takes E K; returns T if E is within -10 to +10 of K ..."
           (and (not (< e (- k 10)))
                (not (> e (+ k 10)))))
ROUGHLY-EQUAL
CL-USER> (roughly-equal 9 13)
T
CL-USER> (roughly-equal -4 7)
NIL
CL-USER> (roughly-equal -2 7)
T
CL-USER> (defun find-first-roughly-equal (x k)
           "takes X K; finds first element roughly equal to K ..."
           (find-if #'(lambda (e) (roughly-equal e k))
                    x))
FIND-FIRST-ROUGHLY-EQUAL
CL-USER> (find-first-roughly-equal '(1 43 87 22 46 94) '27)
22
CL-USER> (find-first-roughly-equal '(1 43 87 22 46 94) '48)
43
CL-USER> (find-first-roughly-equal '(1 43 87 22 46 94) '83)
87


7.9 write FIND-NESTED that returns the first element of a list that is itself a non-NIL list ...

CL-USER> (defun find-nested (x)
           "takes an input; returns the first element of a list that is a non-NIL list ..."
           (find-if #'consp x))
FIND-NESTED
CL-USER> (find-nested '(() () () (a d f g) () ()))
(A D F G)
CL-USER> (find-nested '((bung) () () ()))
(BUNG)
CL-USER> (find-nested '(() () () () () (hole)))
(HOLE)



--
MINI KEYBOARD EXERCISE
--
7.10
a. write NOTE-TABLE to represent the note-number correspondence for the given one-octave scale ...

CL-USER> (setf note-table
               '((c . 1)    (c-sharp . 2)
                 (d . 3)    (d-sharp . 4)
                 (e . 5)    (f . 6)
                 (f-sharp . 7)    (g . 8)
                 (g-sharp . 9)    (a . 10)
                 (a-sharp . 11)    (b . 12)))
((C . 1) (C-SHARP . 2) (D . 3) (D-SHARP . 4) (E . 5) (F . 6) (F-SHARP . 7)
 (G . 8) (G-SHARP . 9) (A . 10) (A-SHARP . 11) (B . 12))


b. write function NUMBERS ... that takes a list of notes as input and returns the corresponding list of numbers ...

CL-USER> (defun numbers (x)
           (mapcar #'(lambda (e)
                       (cdr (assoc e note-table)))
                   x))
NUMBERS
CL-USER> (numbers '(a f g g-sharp d e f-sharp))
(10 6 8 9 3 5 7)
CL-USER> (numbers '(e d c d e e e))
(5 3 1 3 5 5 5)
CL-USER> (numbers '(c a a b c f g))
(1 10 10 12 1 6 8)


c. write NOTES that takes a list of numbers as input and returns the corresponding list of notes ...

CL-USER> (defun notes (x)
           "takes number from NOTE-TABLEas input; returns corresponding notes from NOTE-TABLE"
           (mapcar #'(lambda (e)
                       (car (rassoc e note-table)))
                   x))
NOTES
CL-USER> (notes '(5 3 1 3 5 5 5))
(E D C D E E E)
CL-USER> (notes '(10 12 3 4 2 2 3))
(A B D D-SHARP C-SHARP C-SHARP D)
CL-USER> (notes '(10 8 3 7 9 11 12))
(A G D F-SHARP G-SHARP A-SHARP B)


d. notice that NOTES and NUMBERS are mutual inverses:

for X a list of notes:
X = (NOTES (NUMBERS X))

for X a list of numbers:
X = (NUMBERS (NOTES X))

this being the case, what can be said for (NOTES (NOTES X)) and (NUMBERS (NUMBERS X)) ...

both expressions return a list of NILs the same length as the input list


e. to transpose a piece of music up by n half steps, we begin by adding the value n to each note in the piece ... write function RAISE that takes n and a list of numbers as input and raises each number in the list by the value n ...

CL-USER> (defun raise (n x)
           "takes n and X; returns a transposed piece of music, each note raised n times ..."
           (mapcar #'(lambda (e) (+ e n))
                   x))
RAISE
CL-USER> (raise 5 '(5 3 1 3 5 5 5))
(10 8 6 8 10 10 10)
CL-USER> (raise 3 '(5 3 1 3 5 5 5))
(8 6 4 6 8 8 8)
CL-USER> (raise 1 '(5 3 1 3 5 5 5))
(6 4 2 4 6 6 6)


f. sometimes when we raise the value of a note, we may raise it into the next octave ... write function NORMALIZE that takes a list of numbers as input and normalizes them to make them between 1 and 12 ... a number greater than 12 should have 12 subtracted form it ... a number less than one should have 12 added to it ...

CL-USER> (defun normalize (x)
           "takes a list of numbers X, returns a normalized list of them ..."
           (mapcar #'(lambda (e)                     ; mapcar evaluates each individual element with the following; begin lambda expression with variable (E)
                       (cond ((< e 1) (+ e 12))      ; conditional, if T add 12 -- NIL, next
                             ((> e 12) (- e 12))     ; if T subtract 12 -- NIL next
                             (t e)))                 ; test clause, evaluate E to itsself
                   x))                               ; X, the list LAMBDA is evaluating each element of ...
NORMALIZE
CL-USER> (normalize '(6 10 13))
(6 10 1)
CL-USER> (normalize '(-4 16 5))
(8 4 5)
CL-USER> (normalize '(-11 15 -6))
(1 3 6)


g. write function TRANSPOSE that takes a number n and a song, then returns the song transposed by n half-steps ... NUMBERS NOTES RAISE NORMALIZE should be available ... transpose mary-had-a-little-lamb by 11 half-steps ... 12 half-steps ... -1 half-steps ...

(defun numbers (x)                           ; defining a new function NUMBERS- takes a list of notes, returns corresponding numbers from NOTE-TABLE
  (mapcar #'(lambda (e)                      ; MAPCAR will evaluate every element from input- LAMBDA is called to construct a local nameless function as the other input to MAPCAR- E is the note from the a-list NOTE-TABLE
              (cdr (assoc e note-table)))    ; ASSOC returns the cons of the a-list entry whose car is equal to E from the a-list NOTE-TABLE
              x))                            ; X is the list of notes as letters from the a-table NOTE-TABLE- LAMBDA is being fed each element of X one at a time and evaluating each element as E

(defun notes (x)                              ; defining a new function NOTES- takes a list of numbers, returns the corresponding notes from NOTE-TABLE
;; MAPCAR is called so that every element from list X can be evaluated one at a time- the MAPCAR form closes with list X- LAMBDA constructs a nameless function to act as a single input in order to evaluate each element from list X individually
  (mapcar #'(lambda (e)                       
              (car (rassoc e note-table)))    ; RASSOC parses the a-list NOTE-TABLE for the entry with a cdr that matches input E, then returns that entry- CAR takes the car of that entry and places the return value sequentially within the list to be returned
              x))                             ; list X is the input list trailing the MAPCAR form, feeding LAMBDA the elements its composed of one after the other

(defun raise (n x)                  ; defining a new function RAISE- takes a single number n as well as a list of numbers X, returns listX raised by n
  (mapcar #'(lambda (e) (+ e n))    ; MAPCAR feeds LAMBDA closing its form with listX- LAMBDA takes each element being fed by MAPCAR from listX then adds E to n from the defun form
          x))                       ; listX trails the form  as the other input to MAPCAR and assist with the context of E

(defun normalize (x)                       ; defining a new function NORMALIZE- taking a list X of numbers and normalizing them between 1 and 12
  (mapcar #'(lambda (e)                    ; MAPCAR feeds LAMBDA each element to be evaluated from listX one at a time- LAMBDA constructs a nameless function that will evaluate each element E given by MAPCAR from listX 
;; COND is given three tests to evaluate
              (cond ((< e 1) (+ e 12))     ; test1- T if E is less than 12, then add 12 to E- next test if NIL
                    ((> e 12) (- e 12))    ; test2- T if E is greater than 12, then subtract 12 from E- next test if NIL
                    (t e)))                ; if E is NIL for the above two tests, E will evaluate to its self and return to top-level
          x))                              ; E is returned to listX, the next E is given to the LAMBDA form and evaluated ... this process will repeat until E is NIL (there are no more elements to evaluate to listX


having each line of the above functions explained, write a statement supporting TRANSPOSE ...

CL-USER> (defun transpose (n x)
           "takes number as n and a song X; returns X transposed by n half steps ..."    
           (notes (normalize (raise n (numbers x)))))
TRANSPOSE

TRANSPOSE take a number n and song-as-a-list X, then return a transposed song-as-a-list X by n half steps
NUMBERS is called on song-as-a-list X (letters ...)- that list is returned to RAISE as a list of numbers (corresponding with each individual element (letter) in song-as-a-list X)
RAISE has a number n and a list of numbers (corresponding with the notes from song-as-a-list X)- RAISE will return the list of numbers it was given each element raised (+ in this context) by n to NORMALIZE
NORMALIZE is fed the raised list of numbers- taking numbers on the list that are greater than 12 and subtracting 12 from them, taking numbers on the list that are less than 1 and adding 12 to them, or returning the number it was given if that number is greater than 1 and less than 12- the new list NORMALIZE has constructed just needs to be translated from numbers to musical notes by NOTES
NOTES takes the list of numbers from NORMALIZE, corresponds each element with the letter from NOTE-TABLE and returns a list of those corresponding letters as the transposed song in the form of musical notes as letters

what is generally happening within the function TRANSPOSE is that X starts as letters, gets translated to numbers, each of those numbers then get n added to them- call it numlis-plus-n- numlis-plus-n gets handed to NORMALIZE who keeps list numbers between 1 and 12, the normalized numlis-plus-n finally gets translated back into a list of musical notes that has been transposed n half steps from X ...

CL-USER> (transpose 5 '(e d c d e e e))
(A G F G A A A)
CL-USER> (transpose 11 '(e d c d e e e))
(D-SHARP C-SHARP B C-SHARP D-SHARP D-SHARP D-SHARP)
CL-USER> (transpose -1 '(e d c d e e e))
(D-SHARP C-SHARP B C-SHARP D-SHARP D-SHARP D-SHARP)



---
7.8 REMOVE-IF AND REMOVE-IF-NOT
---

CL-USER> (documentation 'remove-if 'function)
"Return a copy of sequence with elements satisfying PREDICATE removed."


REMOVE-IF is an applicative operator that takes a predicate as input

REMOVE-IF removes all the items from a list that satisfy the predicate, then returns whats left

CL-USER> (remove-if #'numberp '(2 for 1 sale))
(FOR SALE)
CL-USER> (remove-if #'oddp '(1 2 3 4 5 6 7))
(2 4 6)


how do we find all the positive elements in a list of numbers ...

(2 0 -4 6 -8 10)

CL-USER> (documentation 'plusp 'function)
"Is this real number strictly positive?"
CL-USER> (plusp '(2 0 -4 6 -8 10))
; Evaluation aborted on #<TYPE-ERROR expected-type: NUMBER datum: (2 0 -4 6 -8 10)>.
CL-USER> (plusp 2)
T
CL-USER> (plusp 0)
NIL

PLUSP is a predicate that tests whether a number is greater than zero- thats one number- one input ...

LAMBDA will handle all the inputs (X) with a nameless local function, as currently stands all the positive numbers will be removed and the negatives returned ...

NOT can reverse this ...

CL-USER> (remove-if #'(lambda (x) (not (plusp x)))
                    '(2 0 -4 6 -8 10))
(2 6 10)
CL-USER> (remove-if #'(lambda (x) (not (plusp x)))
                    '(-1 -2 -3 -4 4 3 2 1))
(4 3 2 1)
CL-USER> (remove-if #'(lambda (x) (not (plusp x)))
                    '(-1 -2 -3 -4))
NIL


that was fun, but the inversion of REMOVE-IF already exists ...


CL-USER> (documentation 'remove-if-not 'function)
"Return a copy of sequence with elements not satisfying PREDICATE removed."

REMOVE-IF-NOT is more frequently used than REMOVE-IF

REMOVE-IF-NOT returns a list of all the items that satisfy the predicate

CL-USER> (remove-if-not #'plusp '(2 0 -4 6 -8 10))
(2 6 10)
CL-USER> (remove-if-not #'oddp '(2 0 -4 6 -8 10))
NIL
CL-USER> (remove-if-not #'evenp '(2 0 -4 6 -8 10))
(2 0 -4 6 -8 10)

more ...

CL-USER> (remove-if-not #'(lambda (x) (> x 3))
                        '(2 4 6 8 4 2 1))
(4 6 8 4)
CL-USER> (remove-if-not #'numberp
                        '(3 apples 4 pears and 2 little plums))
(3 4 2)
CL-USER> (remove-if-not #'symbolp
                        '(3 apples 4 pears and 2 little plums))
(APPLES PEARS AND LITTLE PLUMS)


count how many zeros are in a list of numbers ...

CL-USER> (remove-if-not #'zerop '(34 0 0 95 0))
(0 0 0)


COUNT-ZEROS:
CL-USER> (defun count-zeros (x)
           "counts the zeros from list X of numbers ..."
           (length (remove-if-not #'zerop x)))
WARNING: redefining COMMON-LISP-USER::COUNT-ZEROS in DEFUN
COUNT-ZEROS
CL-USER> (count-zeros '(34 0 0 95 0))
3
CL-USER> (count-zeros '(1 0 63 0 38))
2
CL-USER> (count-zeros '(0 0 0 0 0 0))
6
CL-USER> (count-zeros '(1 2 3 4 5))
0


--
EXERCISES
--

7.11 write a function to pick out those numbers in a list that are greater than one and less than five ...

CL-USER> (defun pick (x)
           "list X of numbers in; list of those (< 1 X 5) comes out ..."
           (remove-if-not #'(lambda (x) (< 1 x 5))
                          x))
PICK
CL-USER> (pick '(1 9 3 7 6 4 9 0 0))
(3 4)
CL-USER> (pick '(2 5 3 6 4 7))
(2 3 4)
CL-USER> (pick '(1 5 6 7 8))
NIL
CL-USER> (documentation '< 'function)
"Return T if its arguments are in strictly increasing order, NIL otherwise."
CL-USER> (< 1 2 5)
T
CL-USER> (> 5 2 1)    ; note we can fence an input to test whether it is between two others
T
CL-USER> (> (length '(a b c d e f g)) (length '(1 2 3 4)))
T

CL-USER> (time (pick '(1 9 3 2 5 3 8 4)))
Evaluation took:
  0.000 seconds of real time
  0.000000 seconds of total run time (0.000000 user, 0.000000 system)
  100.00% CPU
  6,048 processor cycles
  0 bytes consed
  
(3 2 3 4)


7.12 write a function that counts how many times the word THE appears in a sentence ...

COUNT-THE:
CL-USER> (defun count-the (sent)
           "SENT in; counts the THEs, then returns that value ..."
           (length (remove-if-not
                    #'(lambda (x) (equal x 'the))
                    sent)))
COUNT-THE
CL-USER> (count-the '(the hairy bung ate the frosty sandwich int the morning))
3
CL-USER> (count-the '(the cherrys taste of the summer))
2
CL-USER> (count-the '(thesaurus there them they anthem these))
0

COUNT-THE-THES:
CL-USER> (defun count-the-thes (sent)
           "SENT in; COUNTs the THEs better ..."
           (count 'the sent))
COUNT-THE-THES
CL-USER> (count-the-thes '(the bum in the sum))
2


7.13 write a function that picks from a list of lists those of exactly length 2 ...

PICK-PAIRS:
CL-USER> (defun pick-pairs (x)
           "takes list X of lists in; picks lists of two elements, returns them"
           (remove-if
            #'(lambda (x)
                (not (equal (length x) 2)))
            x))
PICK-PAIRS
CL-USER> (pick-pairs '((1 2) (1 2 3 4) (a b) (a d c)))
((1 2) (A B))
CL-USER> (defun remove-non-pairs (x)
           "takes list X of lists in; removes lists of more than two elements, returns what's left ..."
           (remove-if-not #'(lambda (x)
                              (equal (length x) 2))
                          x))
REMOVE-NON-PAIRS
CL-USER> (remove-non-pairs '((1 2) (a b) (a b c) (1 2 3)))
((1 2) (A B))


7.14
SET-DIFFERENCE written with REMOVE-IF-
CL-USER> (defun my-setdiff (x y)
           (remove-if #'(lambda (e) (member e y))
                      x))
MY-SETDIFF
CL-USER> (documentation 'set-difference 'function)
"Return the elements of LIST1 which are not in LIST2."
CL-USER> (my-setdiff '(1 0 8 2) '(7 2 0 3))
(1 8)

write INTERSECTION and UNION using REMOVE-IF or REMOVE-IF-NOT ...

CL-USER> (defun rem-if-notersection (list1 list2)
           "INTERSECTION written with REMOVE-IF-NOT ..."
           (remove-if-not
            #'(lambda (e)
                (member e list2))
            list1))
REM-IF-NOTERSECTION
CL-USER> (rem-if-notersection '(1 2 3 4) '(3 4 5 6))
(3 4)
CL-USER> (rem-if-notersection '(a b c 1 2 3) '(4 5 6 a c b))
(A B C)
CL-USER> (rem-if-notersection '(c a t d o g) '(c d t d h g))
(C T D G)

CL-USER> (defun rem-union-if (list1 list2)
           "UNION written with REMOVE-IF ..."
           (append list1
                   (remove-if
                    #'(lambda (e)
                        (member e list1))
                    list2)))
REM-UNION-IF
CL-USER> (rem-union-if '(a b c) '(f a d))
(A B C F D)
CL-USER> (rem-union-if '(1 2 3) '(1 2 5))
(1 2 3 5)
CL-USER> (rem-union-if '(ab ac ag) '(ab ac fh))
(AB AC AG FH)



MINI KEYBOARD EXERCISE
7.15
lets manipulate playing cards with applicative operators ...


7.15a write function RANK and SUIT that return the rank and suit of a card ...

CL-USER> (defun rank (card)
           "takes CARD; returns RANK as integer ..."
           (first card))
RANK
CL-USER> (rank '(2 clubs))
2
CL-USER> (rank '(9 spades))
9
CL-USER> (rank '(J diamonds))
J
CL-USER> (defun suit (card)
           "takes CARD; returns SUIT as symbol ..."
           (second card))
SUIT
CL-USER> (suit '(2 clubs))
CLUBS
CL-USER> (suit '(8 diamonds))
DIAMONDS
CL-USER> (suit '(J spades))
SPADES


7.15b set global variable MY-HAND to the following hand of cards:

CL-USER> (setf MY-HAND
               '((3 hearts)
                 (5 clubs)
                 (2 diamonds)
                 (4 diamonds)
                 (ace spades)))
((3 HEARTS) (5 CLUBS) (2 DIAMONDS) (4 DIAMONDS) (ACE SPADES))

... now write function COUNT-SUIT that takes two inputs (SUIT and a hand of cards), and returns the number of cards belonging to that suit ...

CL-USER> (defun count-suit (s hand)
           "~&takes suit-S and a HAND of cards;~
            ~%returns cards of suit-S in HAND"
            ;; REMOVE-IF-NOT takes the T value from LAMBDA and removes all other values from HAND
            ;; finally, LENGTH counts whats left from REMOVE-IF-NOT and returns the final value
           (length (remove-if-not
                    #'(lambda (card)    ; this lambda function takes CARD from MY-HAND
                    ;; each CARDs SUIT is being evaluated and given to EQUAL
                    ;; EQUAL takes those evaluated SUITs and tests them against the input suit-S
                    ;; all CARDs with SUIT suit-S are given to REMOVE-IF-NOT
                        (equal (suit card) s))
                    hand)))    ; this is the a-list MY-HAND, it feeds the lambda function
COUNT-SUIT
CL-USER> (count-suit 'diamonds my-hand)
2
CL-USER> (count-suit 'clubs my-hand)
1
CL-USER> (count-suit 'hearts my-hand)
1


7.15c set global variable COLORS

CL-USER> (setf colors
               '((clubs black)
                 (diamonds red)
                 (hearts red)
                 (spades black)))
((CLUBS BLACK) (DIAMONDS RED) (HEARTS RED) (SPADES BLACK))

... now write a function COLOR-OF that uses the table COLORS to retrieve the color of a card ...

CL-USER> (defun color-of (card)
           "takes CARD; returns CARD color from a-list COLORS ..."
           ;; find SUIT of CARD, give that to ASSOC
           ;; ASSOC- look up table entry SUIT in a-list COLORS give that to SECOND
           ;; SECOND- take the table entry and return the SECOND element
           (second (assoc (suit card) colors)))
COLOR-OF
CL-USER> (color-of '(6 hearts))
RED
CL-USER> (color-of '(2 clubs))
BLACK
CL-USER> (color-of '(10 diamonds))
RED


7.15d write function FIRST-RED, returning the first card of a hand that is of a red suit, or NIL if none ...

CL-USER> (defun first-red (hand)
           "takes HAND; returns the fist card of red suit ..."
           ;; unsure of FIND-IF, but i think it evaluates each element of HAND with LAMBDA ...
           ;; LAMBDA- take a CARD from HAND, return T if its RED
           ;; FIND-IF return the table entry that gave T to LAMBDA in HAND
           (find-if #'(lambda (card)
                        (equal (color-of card) 'red))
                    hand))    ; context- FIND-IF
FIRST-RED
CL-USER> (first-red my-hand)
(3 HEARTS)


7.15e write function BLACK-CARDS that returns a list of all the black cards in a hand ...

CL-USER> (defun black-cards (hand)
           "takes HAND; returns a list of all the black cards in it ..."
           (remove-if-not                          ; removes all CARDs not BLACK from HAND
            #'(lambda (card)                       ; refers to HAND
                (equal (color-of card) 'black))    ; COLOR-OF determines CARD color. T for CARD color BLACK, NIL gets passed up for removal
            hand))                                 ; the HAND everything is referring to. the input to this function. gives CARD to LAMBDA.
BLACK-CARDS
CL-USER> (black-cards my-hand)
((5 CLUBS) (ACE SPADES))


7.15f write function WHAT-RANKS that takes two inputs (suit and hand), then returns the ranks of all cards belonging to that suit ... first extract all the cards of SUIT, then use another operator to get the ranks of those cards ...

CL-USER> (defun what-ranks (s hand)
           "takes suit-S and HAND; returns (all) card rank of suit-S ..."
           ;; MAPCAR tells RANK to apply itself to each element returned by REMOVE-IF-NOT.
           ;; MAPCAR takes from RANK, and returns that as a list.
           (mapcar #'rank                         ; MAPCAR tells RANK to apply itself to each element returned by REMOVE-IF-NOT. They
                   (remove-if-not                 ; REMOVE-IF-NOT passes what it has left to RANK up top.
                    #'(lambda (card)              ; CARD is from hand. Apply the nameless function to each CARD from HAND.
                    ;; *start below here*, then go up
                        (equal (suit card) s))    ; CARD in from HAND. SUIT is determined then EQUALd to top-level suit-S. Pass NILs up.
                    hand)))                       ; Top-level input. A-list feeding each top-level form, provides CARD for LAMBDA
WHAT-RANKS
CL-USER> (what-ranks 'diamonds my-hand)
(2 4)
CL-USER> (what-ranks 'spades my-hand)
(ACE)
CL-USER> (what-ranks 'hearts my-hand)
(3)


7.15g set global variable ALL-RANKS to the list

CL-USER> (setf all-ranks
               '(2 3 4 5 6 7 8 9 10 jack queen king ace))
(2 3 4 5 6 7 8 9 10 JACK QUEEN KING ACE)

... then write predicate HIGHER-RANK-P that takes two cards as input and returns true if the first card has a higher rank than the second ... look at BEFOREP in c6 p171 ...

CL-USER> (defun higher-rank-p (card1 card2)
           "takes CARD1 CARD2; RANK and REST of ALL-RANKS if CARD1 holds higher rank ..."
           ;; bleh
           (beforep (rank card2)
                    (rank card1)
                    all-ranks))
HIGHER-RANK-P


7.15h write function HIGH-CARD that returns the highest ranked card in a hand ...

CL-USER> (defun high-card-find-if (hand)
           "takes HAND; returns the highest ranked card in HAND ..."
           ;; Uses FIND-IF. ASSOC returns key entry from FIND-IF.
           (assoc (find-if                 ; FIND-IF takes the first T R and gives it to ASSOC. ASSOC returns the key-entry of R
                   #'(lambda (r)           ; R is each element from reversed a-list ALL-RANKS (starting with ACE).
                       (assoc r hand))     ; ASSOC takes each R to HAND. Non-NIL goes up to LAMBDA then to FIND-IF.
                   (reverse all-ranks))    ; REVERSEs the a-list ALL-RANKS from low-high, to high-low.
                  hand))                   ; Top-level input. Referred to in LAMBDA, parsed by FIND-IF, key-entry extraction by ASSOC.
HIGH-CARD-FIND-IF
CL-USER> (high-card-find-if my-hand)
(ACE SPADES)

CL-USER> (defun high-card-reduce (hand)
           "takes HAND; returns the highest ranked card in HAND ..."
           (reduce
            #'(lambda (card1 card2)
                (if (higher-rank-p card1 card2)
                    card1
                    card2))
            hand))
HIGH-CARD-REDUCE
CL-USER> (high-card-reduce my-hand)
(ACE SPADES)



---
7.9 THE REDUCE OPERATOR
---

REDUCE is an applicative operator that reduces the elements of a list into a single result.

REDUCE takes a function and a list as input. The input function to REDUCE must be a minimum two input function.


CL-USER> (reduce #'+ '(1 2 3))
6
CL-USER> (reduce #'+ '(10 9 8 7 6))
40
CL-USER> (reduce #'+ '(5))
5
CL-USER> (reduce #'+ nil)
0
CL-USER> (reduce #'* '(2 4 5))
40
CL-USER> (reduce #'* '(3 4 0 7))
0
CL-USER> (reduce #'* '(8))
8


we can apply reduction to lists of lists ...

APPEND can turn a table into a one level list through reduction ...

CL-USER> (reduce #'append
                 '((one un) (two deux) (three trois)))
(ONE UN TWO DEUX THREE TROIS)
CL-USER> (reduce #'append
                 '((one (uno) un) (two (dos) deux) (three (tres) trois)))
(ONE (UNO) UN TWO (DOS) DEUX THREE (TRES) TROIS)


REDUCE uses a binary operation (the input function) to combine the elements of SEQUENCE (the other input ... which is a list).

CL-USER> (reduce #'* '(1 2 3 4 5))
120
CL-USER> (reduce #'append '((1) (2)) :initial-value '(i n i t))
(I N I T 1 2)
CL-USER> (reduce #'append '((1) (2)) :from-end t
                 :initial-value '(i n i t))
(1 2 I N I T)
CL-USER> (reduce #'- '(1 2 3 4))
-8


--
EXERCISES
--

7.16 What reducing function should be used to collapse ((A B C) (C D A) (F B D) (G)) ...

CL-USER> (reduce #'append '((a b c) (c d a) (f b d) (g)))
(A B C C D A F B D G)

REDUCE


7.17 Write a function that, given a list of lists, returns the total length of all the lists. There are two different solutions ...

CL-USER> (defun total-length-append (x)    ;conses alot- inefficient
           "Takes a list. REDUCEs list through APPEND, returns LENGTH of that."
           (length (reduce #'append x)))
TOTAL-LENGTH-APPEND
CL-USER> (total-length-append '((a b c) (c d a) (f b d) (g)))
10

CL-USER> (defun total-length (x)    ;more efficient
           "List as input. Returns the total list length ..."
           (reduce #'+ (mapcar #'length x)))
TOTAL-LENGTH
CL-USER> (total-length '((a b d) (d b a) (u g b) (i)))
10
CL-USER> (mapcar #'length '((a b d) (d b a) (u g b) (i)))
(3 3 3 1)
CL-USER> (reduce #'+ '(3 3 3 1))
10


7.18 Why ...?

CL-USER> (reduce #'+ nil)
0
CL-USER> (reduce #'* nil)
1

Zero (0) is the identity value for addition.
That is why calling + with no arguments returns 0.
One (1) is the identity value for multiplication.
That is why calling * with no arguments returns 1.



---
7.10 EVERY
---

CL-USER> (documentation 'every 'function)
"Apply PREDICATE to the 0-indexed elements of the sequences, then
   possibly to those with index 1, and so on. Return NIL as soon
   as any invocation of PREDICATE returns NIL, or T if every invocation
   is non-NIL."

EVERY takes a predicate and a list as input.
EVERY returns T if there is no element that causes the predicate to return NIL.

CL-USER> (every #'numberp '(1 2 3 4 5))
T
CL-USER> (every #'numberp '(1 2 a b c 5))
NIL
CL-USER> (every #'(lambda (x) (> x 0)) '(1 2 3 4 5))
T
CL-USER> (every #'(lambda (x) (> x 0)) '(1 2 3 -4 5))
NIL


if EVERY is called with NIL as its second argument, it returns T.
The empty list has no elements that could fail to satisfy EVERY.

CL-USER> (every #'oddp nil)
T
CL-USER> (every #'evenp nil)
T


EVERY can also operate on multiple lists, given a predicate that accepts multiple inputs.

CL-USER> (every #'> '(10 20 30 40) '(1 5 11 23))
T


--
EXERCISES
--
7.19 Write function ALL-ODD that returns T if every element of a list of numbers is odd.

CL-USER> (defun all-odd (x)
           "Takes list-X as numbers. Returns T if every element is odd."
           (every #'oddp x))
ALL-ODD
CL-USER> (all-odd '(1 3 5 7 9))
T
CL-USER> (all-odd '(1 3 5 6 7 8))
NIL
CL-USER> (all-odd nil)
T

7.20 Write function NONE-ODD that returns T if ever element of a list of numbers is not odd.

CL-USER> (defun none-odd (x)
           "Takes list-X as numbers. Returns T if every element is not odd."
           (every #'evenp x))
NONE-ODD
CL-USER> (none-odd '(2 4 6 8 10))
T
CL-USER> (none-odd '(2 4 5 6 7 8))
NIL
CL-USER> (none-odd nil)
T


7.21 Write function NOT-ALL-ODD that returns T if not every element of a list of numbers is not odd.

CL-USER> (defun not-all-odd (x)
           "Takes list-X as numbers. Returns T if not every element of list-X is odd."
           (find-if #'evenp x))
NOT-ALL-ODD
CL-USER> (not-all-odd '(1 3 5 7 9))
NIL
CL-USER> (not-all-odd '(1 2 3 5 7 9))
2
CL-USER> (not-all-odd nil)
NIL


7.22 Write function NOT-NONE-ODD that returns T if it is not the case that a list of numbers contains no odd elements.

CL-USER> (defun not-none-odd (x)
           "Takes list-X as numbers. Returns T if there aint no odd elements in the list."
           (find-if #'oddp x))
NOT-NONE-ODD
CL-USER> (not-none-odd '(1 3 5 7 9))
1
CL-USER> (not-none-odd '(1 2 3 5 7 9))
1
CL-USER> (not-none-odd '(2 4 5 7 9 8))
5


7.23 Are all of the above functions distinct from another, or some the same? Can there be better names for the last two functions?

All four functions are distinct. They all use different applicative operators.
NOT-ALL-ODD => FIND-EVEN
NOT-NONE-ODD => FIND-ODD


SUMMARY

Applicative operators are functions that apply other functions to data structures.
There are many possible applicative operators, only a few of which are built into Lisp.
Advanced Lisp Programmers make up their own operators when necessary.

MAPCAR applies a function to every element of a list and returns a list of the results.
FIND-IF searches a list and returns the first element that satisfies a predicate.
REMOVE-IF removes all the elements of a list that satisfy a predicate, the list returned contains only those elements that fail to satisfy it.
REMOVE-IF-NOT is more frequently used than REMOVE-IF, it returns the elements that satisfy it.
EVERY returns T only if every element of a list satisfies a predicate.
REDUCE uses a reducing function to reduce a list into a single value.


--
REVIEW EXERCISES
--
7.24 What is an applicative operator?

Applicative operators are functions that apply other functions to data structures.


7.25 Why are lambda expressions useful? Can we do without them?

Lambda expressions allow us to apply nameless functions to applicative operators.
Functions can be named and defined separately with DEFUN, but they would not be able to refer to local variables of the parent function.


7.26 Show how to write FIND-IF given REMOVE-IF-NOT.

CL-USER> (defun my-find-if (pred x)
           "FIND-IF defined with REMOVE-IF-NOT."
           (first (remove-if-not pred x)))
MY-FIND-IF


7.27 Show how to write EVERY given REMOVE-IF.


7.28 See book.


FUNCTIONS COVERED

Applicative operators: MAPCAR FIND-IF REMOVE-IF REMOVE-IF-NOT REDUCE EVERY



--
Keyboard Exercise
--

We will develop a system for representing knowledge about "blocks world" scenes (see book). Triples of form (block attribute value) represent object assertions. Block B2's attribute assertions:

(b2 shape brick)
(b2 color red)
(b2 size small)
(b2 supports b1)
(b2 left-of b3)

A list (or collection) of assertions is called a database.

Given a database describing the blocks, we can then write functions that answer questions regarding objects in the database.

We will use a pattern matcher function to search a database for us and answer questions.

DATABASE:
CL-USER> (setf database
               '((b1 shape brick)
                 (b1 color green)
                 (b1 size small)
                 (b1 supported-by b2)
                 (b1 supported-by b3)
                 (b2 shape brick)
                 (b2 color red)
                 (b2 size small)
                 (b2 supports b1)
                 (b2 left-of b3)
                 (b3 shape brick)
                 (b3 color red)
                 (b3 size small)
                 (b3 supports b1)
                 (b3 right-of b2)
                 (b4 shape pyramid)
                 (b4 color blue)
                 (b4 size large)
                 (b4 supported-by b5)
                 (b5 shape cube)
                 (b5 color green)
                 (b5 size large)
                 (b5 supports b4)
                 (b6 shape brick)
                 (b6 color purple)
                 (b6 size large)))
((B1 SHAPE BRICK) (B1 COLOR GREEN) (B1 SIZE SMALL) (B1 SUPPORTED-BY B2)
 (B1 SUPPORTED-BY B3) (B2 SHAPE BRICK) (B2 COLOR RED) (B2 SIZE SMALL)
 (B2 SUPPORTS B1) (B2 LEFT-OF B3) (B3 SHAPE BRICK) (B3 COLOR RED)
 (B3 SIZE SMALL) (B3 SUPPORTS B1) (B3 RIGHT-OF B2) (B4 SHAPE PYRAMID)
 (B4 COLOR BLUE) (B4 SIZE LARGE) (B4 SUPPORTED-BY B5) (B5 SHAPE CUBE)
 (B5 COLOR GREEN) (B5 SIZE LARGE) (B5 SUPPORTS B4) (B6 SHAPE BRICK)
 (B6 COLOR PURPLE) (B6 SIZE LARGE))

If we wanted to find the color of block B2, we can use the pattern (B2 COLOR ?)

If we wanted to find which blocks support B1, we use pattern (? SUPPORTS B1)

FETCH (will be written later) returns those assertions from the database that match a given pattern.

A pattern is a triple with some of its elements replaced by question marks:

(B1 COLOR ?) *translates-to* "What color is B1?"
(? COLOR RED) *translates-to* "Which blocks are red?"
(B1 COLOR RED) *translates-to* "Is B1 known to be red?"
(B1 ? B2) *translates-to* "What relation is B1 to B2?"
(B1 ? ?) *translates-to* "What is known about B1?"
(? supports ?) *translates-to* "What support relationships exist?"
(? ? B1) *translates-to* "What blocks are related to B1?"
(? ? ?) *translates-to* "What's in the database?"


--
EXERCISE
--

7.29
Set the global variable DATABASE.

a. Write function MATCH-ELEMENT that takes two symbols as inputs. If the two are equal, or if the second is a question mark, MATCH-ELEMENT should return T. Otherwise NIL.

CL-USER> (defun match-element (e q)
           "Takes two symbols in. T if they are EQUAL or if one is a question mark, NIL otherwise."
           (or (equal e q)
               (equal q '?)))
MATCH-ELEMENT
CL-USER> (match-element 'red 'red)
T
CL-USER> (match-element 'red '?)
T
CL-USER> (match-element 'red 'blue)
NIL


b. Write function MATCH-TRIPLE that takes an assertion and a pattern as input, and returns T if the assertion matches the pattern. Both inputs will be three element lists.
HINT: Use MATCH-ELEMENT as a building block.

CL-USER> (defun match-triple (x pat)
           "Takes an assertion and a pattern, each three element lists. T if X matches PAT."
           (every #'match-element
                  x
                  pat))
MATCH-TRIPLE
CL-USER> (match-triple '(b2 color red) '(b2 color ?))
T
CL-USER> (match-triple '(b2 color red) '(b1 color green))
NIL
CL-USER> (match-triple '(b3 shape brick) '(? ? ?))
T


c. Write function FETCH that takes a pattern as input and returns all assertions in the database that match the pattern. Remember that DATABASE is a global variable.

CL-USER> (defun fetch (pat)
           "Takes a pattern as input. Returns all assertions in DATABASE that match PAT."
           (remove-if-not    ; LAMBDA returns T for all assertions that match PAT to here
            #'(lambda (x) (match-triple x pat))    ;matches X (which is the og PAT) with PAT (PAT)
            database))    ;the global variable LAMBDA and REMOVE-IF-NOT refer to
FETCH
CL-USER> (fetch '(b2 color ?))
((B2 COLOR RED))
CL-USER> (fetch '(? supports b1))
((B2 SUPPORTS B1) (B3 SUPPORTS B1))
CL-USER> (fetch '(? color ?))
((B1 COLOR GREEN) (B2 COLOR RED) (B3 COLOR RED) (B4 COLOR BLUE)
 (B5 COLOR GREEN) (B6 COLOR PURPLE))


d. Use FETCH with patterns you construct yourself to answer the following questions:

What shape is block B4?
CL-USER> (fetch '(b4 shape ?))
((B4 SHAPE PYRAMID))

Which blocks are bricks?
CL-USER> (fetch '(? shape brick))
((B1 SHAPE BRICK) (B2 SHAPE BRICK) (B3 SHAPE BRICK) (B6 SHAPE BRICK))

What relation is block B2 to block B3?
CL-USER> (fetch '(b2 ? b3))
((B2 LEFT-OF B3))

List the color of every block.
CL-USER> (fetch '(? color ?))
((B1 COLOR GREEN) (B2 COLOR RED) (B3 COLOR RED) (B4 COLOR BLUE)
 (B5 COLOR GREEN) (B6 COLOR PURPLE))

What facts are known about block B4?
CL-USER> (fetch '(b4 ? ?))
((B4 SHAPE PYRAMID) (B4 COLOR BLUE) (B4 SIZE LARGE) (B4 SUPPORTED-BY B5))


e. Write a function that takes a block name as input and returns a pattern asking the color of the block.

CL-USER> (defun color-pattern (block)
           "Takes block number from DATABASE, Asks which color BLOCK is?"
           (list block 'color '?))
COLOR-PATTERN
CL-USER> (color-pattern 'b3)
(B3 COLOR ?)
CL-USER> (color-pattern 'my-balls)
(MY-BALLS COLOR ?)
CL-USER> (color-pattern nil)
(NIL COLOR ?)


f. Write function SUPPORTERS that takes one input (a block), and returns a list of the blocks that support it. The function should work by constructing a pattern containing the blocks name. The constructed pattern should be input to FETCH. Block names should be extracted from the resulting list of assertions.

CL-USER> (defun supporters (block)
           "Takes a BLOCK name. Returns a list of all blocks that support BLOCK."
           (mapcar #'first
                   (fetch (list '? 'supports block))))
SUPPORTERS
CL-USER> (supporters 'b1)
(B2 B3)
CL-USER> (supporters 'b4)
(B5)
CL-USER> (supporters 'red)
NIL


g. Write predicate SUPP-CUBE that takes a block as input and returns true if that block is supported by a cube. HINT: Use the result of the SUPPORTERS function as a starting point.

CL-USER> (defun supp-cube (block)
           "Takes a BLOCK name. T if BLOCK is supported by a cube."
           (member 'cube
                   (mapcar
                    #'(lambda (b) (third (first (fetch    ;B is each element returned by SUPPORTERS
                                                 (list b 'shape '?)))))    ;constructs the pattern
                    (supporters block))))    ;START. retruns list of block names that support BLOCK
SUPP-CUBE
CL-USER> (supp-cube 'b1)
NIL
CL-USER> (supp-cube 'b4)
(CUBE)
CL-USER> (supp-cube 'b2)
NIL


h. Write function DESCRIPTION that returns the description of a block. First, write a function DESC1 that takes a block as input and returns all assertions dealing with that block.

CL-USER> (defun desc1 (block)
           "Takes a BLOCK name. Returns all assertions having to do with BLOCK."
           (fetch (list block '? '?)))
DESC1
CL-USER> (desc1 'b3)
((B3 SHAPE BRICK) (B3 COLOR RED) (B3 SIZE SMALL) (B3 SUPPORTS B1)
 (B3 RIGHT-OF B2))
CL-USER> (desc1 'b5)
((B5 SHAPE CUBE) (B5 COLOR GREEN) (B5 SIZE LARGE) (B5 SUPPORTS B4))
CL-USER> (desc1 'b1)
((B1 SHAPE BRICK) (B1 COLOR GREEN) (B1 SIZE SMALL) (B1 SUPPORTED-BY B2)
 (B1 SUPPORTED-BY B3))


i. Write function DESC2 of one input that calls DESC1 and strips the block name off each element from the result.

CL-USER> (defun desc2 (block)
           "Takes BLOCK name. Returns the REST of each element returned from DESC1."
           (mapcar #'rest (desc1 block)))
DESC2
CL-USER> (desc2 'b6)
((SHAPE BRICK) (COLOR PURPLE) (SIZE LARGE))
CL-USER> (desc2 'b3)
((SHAPE BRICK) (COLOR RED) (SIZE SMALL) (SUPPORTS B1) (RIGHT-OF B2))
CL-USER> (desc2 '?)
((SHAPE BRICK) (COLOR GREEN) (SIZE SMALL) (SUPPORTED-BY B2) (SUPPORTED-BY B3)
 (SHAPE BRICK) (COLOR RED) (SIZE SMALL) (SUPPORTS B1) (LEFT-OF B3)
 (SHAPE BRICK) (COLOR RED) (SIZE SMALL) (SUPPORTS B1) (RIGHT-OF B2)
 (SHAPE PYRAMID) (COLOR BLUE) (SIZE LARGE) (SUPPORTED-BY B5) (SHAPE CUBE)
 (COLOR GREEN) (SIZE LARGE) (SUPPORTS B4) (SHAPE BRICK) (COLOR PURPLE)
 (SIZE LARGE))


j. Write function DESCRIPTION that takes one input, call DESC2, and merge the resulting list of lists into a single list.


CL-USER> (defun description (block)
           "Takes BLOCK name. Calls DESC2, merges what is returned into a single list."
           (reduce #'append (desc2 block)))
DESCRIPTION
CL-USER> (description 'b4)
(SHAPE PYRAMID COLOR BLUE SIZE LARGE SUPPORTED-BY B5)
CL-USER> (description 'b1)
(SHAPE BRICK COLOR GREEN SIZE SMALL SUPPORTED-BY B2 SUPPORTED-BY B3)
CL-USER> (description '?)
(SHAPE BRICK COLOR GREEN SIZE SMALL SUPPORTED-BY B2 SUPPORTED-BY B3 SHAPE BRICK
 COLOR RED SIZE SMALL SUPPORTS B1 LEFT-OF B3 SHAPE BRICK COLOR RED SIZE SMALL
 SUPPORTS B1 RIGHT-OF B2 SHAPE PYRAMID COLOR BLUE SIZE LARGE SUPPORTED-BY B5
 SHAPE CUBE COLOR GREEN SIZE LARGE SUPPORTS B4 SHAPE BRICK COLOR PURPLE SIZE
 LARGE)


k. What is the description of block B1? Of block B4?

CL-USER> (description 'b1)
(SHAPE BRICK COLOR GREEN SIZE SMALL SUPPORTED-BY B2 SUPPORTED-BY B3)

CL-USER> (description 'b4)
(SHAPE PYRAMID COLOR BLUE SIZE LARGE SUPPORTED-BY B5)


l. Block B1 is made of wood, but block B2 is made of plastic. How would this additional information be input to DATABASE?

Add the lists (B1 COMPOSITION WOOD) and (B2 COMPOSITION PLASTIC) to DATABASE



---
7 Advanced Topics
---
7.11 OPERATING ON MULTIPLE LISTS
---

We previously used MAPCAR to apply a one-input function to each element of a list.

Given a function of n inputs, MAPCAR will map it over n lists.

CL-USER> (mapcar #'(lambda (x y) (list x 'gets y))
                 '(fred wilma george diane)
                 '(job1 job2 job3 job4))
((FRED GETS JOB1) (WILMA GETS JOB2) (GEORGE GETS JOB3) (DIANE GETS JOB4))

CL-USER> (mapcar #'(lambda (list1 list2) (list list1 list2))
                 '(a b c d)
                 '(1 2 3 4))
((A 1) (B 2) (C 3) (D 4))


MAPCAR goes through the two lists in parallel, taking one element from each list at each step.

If one list is shorter than the other, MAPCAR stops when it reaches the end of the shortest list.

Another example of operating on multiple lists with MAPCAR is the problem of adding two lists of numbers pairwise:

CL-USER> (mapcar #'+ '(1 2 3 4) '(60 70 80 90 100))
(61 72 83 94)
CL-USER> (mapcar #'+ '(1 2 3) '(10 20 30 40 50))
(11 22 33)


--
EXERCISE
--
7.30 Set global variable words.

CL-USER> (setf words
               '((one un uno)
                 (two deux dos)
                 (three trois tres)
                 (four quatre quatro)
                 (five cinq cinco)))
((ONE UN UNO) (TWO DEUX DOS) (THREE TROIS TRES) (FOUR QUATRE QUATRO)
 (FIVE CINQ CINCO))

Write an expression to return a trilingual dictionary.

CL-USER> (mapcar #'(lambda (x y) (append x (list y)))
                 words
                 '(uno dos tres quatro cinco))
((ONE UN UNO UNO) (TWO DEUX DOS DOS) (THREE TROIS TRES TRES)
 (FOUR QUATRE QUATRO QUATRO) (FIVE CINQ CINCO CINCO))

... we can now see that the spanish translations were to be appended in the expression.
Not added to WORDS before the exercise ...



---
7.12 THE FUNCTION SPECIAL FUNCTION
---

CL-USER> (documentation 'function 'function)
"FUNCTION name

Return the lexically apparent definition of the function NAME. NAME may also
be a lambda expression."

FUNCTION returns the functional interpretation of its unevaluated argument.

#' is shorthand for the FUNCTION special function.

CL-USER> (function cons)
#<FUNCTION CONS>
CL-USER> #'cons
#<FUNCTION CONS>


If FUNCTION takes a lambda expression as an argument, the result is typically a lexical closure.

CL-USER> #'(lambda (x) (+ x 2))
#<FUNCTION (LAMBDA (X)) {10024D087B}>
CL-USER> #'lambda
#<CLOSURE (:MACRO LAMBDA) {10005F7B6B}>


The result returned by FUNCTION is always some kind of function object.
These objects are a form of data, just like symbols and lists.
Just like everything else in Lisp, we can store these function objects in variables.


Function objects can also be called, like with FUNCALL or APPLY.

CL-USER> (setf g #'(lambda (x) (* x 10)))
#<FUNCTION (LAMBDA (X)) {10024D09BB}>
CL-USER> (funcall g 12)
120

The value of variable G is a lexical closure (which is a function).
But G itself is not the name of any function; (G 12) gets an error ...



---
7.13 KEYWORD ARGUMENTS TO APPLICATIVE OPERATORS
---

Some applicative operators, such as FIND-IF REMOVE-IF REMOVE-IF-NOT and REDUCE, accept optional keyword arguments.

If given a non-NIL value, the :FROM-END keyword causes the list to be processed from right to left.

CL-USER> (find-if #'oddp '(2 3 4 5 6))
3
CL-USER> (find-if #'oddp '(2 3 4 5 6)
                  :from-end t)
5

Using FROM-END with REDUCE causes elements to be reduced from right to left.

CL-USER> (reduce #'cons '(a b c d e))
((((A . B) . C) . D) . E)
CL-USER> (reduce #'cons '(a b c d e) :from-end t)
(A B C D . E)


REMOVE-IF and REMOVE-IF-NOT accept a :COUNT keyword that specifies the maximum number of elements to be removed.


MAPCAR and EVERY do not accept any keyword arguments, they accept a variable number of lists instead.



---
7.14 SCOPING AND LEXICAL CLOSURES
---

(defun my-assoc (key table)
  ;; FIND-IF searches a list and returns the first element that satisfies a predicate.
  ;; LAMBDA takes each element of TABLE, stored in the local variable ENTRY, and evaluates those.
  (find-if #'(lambda (entry)
               (equal key (first entry)))    ; The first element is taken from the list ENTRY,
           table))                           ; then tested for equality with KEY from input.

Use comments to describe the MY-ASSOC function from section 7.7.

How is it possible to refer to the local variables of MY-ASSOC?
Why is it unable to see the local variables, if any, of FIND-IF itself?


First it is important to understand that what is passed to FIND-IF is not the raw lambda expression, but rather the lexical closure created by FUNCTION (#').

The closure remembers its lexical environment.

The scope rule for closures is that any variable not local to the closure is looked up in the closure's parent context.

Every lexical context has a parent context.

If something is defined at top level, its lexical context is global.

Things with a global parent lexical context cannot refer to local variables within function definitions.

Replacing the LAMBDA expression in MY-ASSOC with an independent function would result in error.

The independent function would not be able to refer to local variable KEY.

(defun helper (entry)
  (equal key (first entry)))

(defun faulty-assoc (key table)
  (find-if #'helper table))



---
7.15 WRITING AN APPLICATIVE OPERATOR
---

Using FUNCALL, we can write our own applicative operator that takes a function as input.

Call it INALIENABLE-RIGHTS. It applies its input to a particular list, drawn from the American Declaration of Independence.

CL-USER> (defun inalienable-rights (fn)
           "Applies FN to a list drawn from the American Declaration of Independence."
           (funcall fn
                    '(life liberty and the pursuit of happiness)))
INALIENABLE-RIGHTS
CL-USER> (inalienable-rights #'length)
7
CL-USER> (inalienable-rights #'reverse)
(HAPPINESS OF PURSUIT THE AND LIBERTY LIFE)
CL-USER> (inalienable-rights #'first)
LIFE
CL-USER> (inalienable-rights #'rest)
(LIBERTY AND THE PURSUIT OF HAPPINESS)


It is an error to call INALIENABLE-RIGHTS on something that isn't a function.


CL-USER> (describe #'funcall)
#<FUNCTION FUNCALL>
  [compiled function]


Lambda-list: (FUNCTION &REST SB-IMPL::ARGUMENTS)
Declared type: (FUNCTION ((OR FUNCTION SYMBOL) &REST T) *)
Documentation:
  Call FUNCTION with the given ARGUMENTS.
Known attributes: unwind, any
Source file: SYS:SRC;CODE;EVAL.LISP
; No value

CL-USER> (inalienable-rights 5)
; Evaluation aborted on #<TYPE-ERROR expected-type: (OR FUNCTION SYMBOL) datum: 5>.

FUNCALL requires a function as its first input.


CL-USER> (inalienable-rights #'cons)
; Evaluation aborted on #<SB-INT:SIMPLE-PROGRAM-ERROR "invalid number of arguments: ~S" {1002EBCA03}>.

The input to INALIENABLE-RIGHTS must be a function that can take a single list as its argument.

... however we can use CONS inside of a LAMBDA expression that takes one argument like -

CL-USER> (inalienable-rights
          #'(lambda (x) (cons 'high x)))
(HIGH LIFE LIBERTY AND THE PURSUIT OF HAPPINESS)


Remember that in Lisp, functions are data.

Just like with symbols and lists, functions can be passed as inputs to other functions.

Functions can also be returned as values.



---
7.16 FUNCTIONS THAT MAKE FUNCTIONS
---

We can write functions that have return values as functions.

Make a function that returns true if its input is greater than a certain number N.

We can make this function by constructing a lambda expression that refers to N, and returning that lambda expression.

CL-USER> (defun make-greater-than-predicate (n)
           #'(lambda (x) (> x n)))
MAKE-GREATER-THAN-PREDICATE
CL-USER> (setf pred (make-greater-than-predicate 3))
#<CLOSURE (LAMBDA (X) :IN MAKE-GREATER-THAN-PREDICATE) {100324C84B}>
CL-USER> (funcall pred 2)
NIL
CL-USER> (funcall pred 5)
T
CL-USER> (find-if pred '(2 3 4 5 6 7 8 9))
4


The value returned by MAKE-GREATER-THAN-PREDICATE will be a lexical closure.

We can store this away or pass it as an argument to any applicative operator.



----
8 Recursion
----
---
8.1 INTRODUCTION
---

A function is said to be recursive if it calls itself.


---
8.2 MARTIN AND THE DRAGON
---

Read the story.

Highlight the section.


Way back in the gap ...
Martin, an alchemists apprentice, discovered recursion by outsmarting a lazy dragon.
The alchemist instructed Martin to --

"... take this list of numbers to the dungeon where the dragon is,
ask him if any of them are odd."

Martin goes, he asks the dragon his question.

(3142 5798 6550 8914)

The dragon explains to Martin that he will only evaluate the first number on a list Martin hands to him.
The dragon states --

"I will not evaluate your whole list,
but what I am willing to do is ...
tell you if the first number on the list is odd.

You may hand me as many lists as you please but, the only number I will look at is the first on each one."

Martin hands the dragon this list:
(3142 5798 6550 8914)
The dragon replies, "The first number is not odd."

Martin *covers-the-first-number* *draws-a-left-parenthesis*, then hands the dragon:
(5798 6550 8914)
"The first number is not odd."

Martin does the same until ...

(6550 8914)
"... not odd."

(8914)
"... not odd."

()
"That's the empty list. There can't be an odd number in nothing."

Martin smiles and explains to the dragon that he has all even numbers, none odd.
The dragon asks how this is so, so Martin exclaims "Mr. dragon ya see if ya just ..."

(3142 5798 6550 8914)
     (5798 6550 8914)
          (6550 8914)
               (8914)
                   ()

"Looks like you found out about recursion."
The dragons mumbled something like that before falling asleep.
So Martin left.



---
8.3 A FUNCTION TO SEARCH FOR ODD NUMBERS
---

ANYODDP is a recursive function that returns T if any element of a list of numbers is odd. NIL if none are.

CL-USER> (defun anyoddp (x)
           "Takes a list of numbers. Returns T if any element of X is an odd number."
           (cond ((null x) nil)
                 ((oddp (first x)) t)
                 (t (anyoddp (rest x)))))
ANYODDP


If the list of numbers is empty, ANYODDP should return NIL.
If the list is not empty, go to the second COND clause and test the first element.
If the first element is odd, then ANYODDP can return T.
If the first element is even, ANYODDP must call itself on the rest of the list to keep looking for odd elements.

Thus ANYODDP is a recursive function.


(defun anyoddp (x)
  "Takes a list of numbers. Returns T if any are odd."
  ;; This function is recursive.
  (cond ((null x) nil)    ; COND Test - Is the given list empty? No ...? Next test.
        ((oddp (first x)) t)    ; Is the first element of X odd? Yes then T. NIL, next test.
        (t (anyoddp (rest x)))))    ; Call myself on the rest of the list to find an odd number.


CL-USER> (dtrace anyoddp)
WARNING: Function is not TRACEd: ANYODDP
(ANYODDP)
CL-USER> (anyoddp nil)
----Enter ANYODDP
|     Arg-1 = NIL
 \--ANYODDP returned NIL    ; First clause: gives us return value.
NIL
CL-USER> (anyoddp '(7))
----Enter ANYODDP
|     Arg-1 = (7)
 \--ANYODDP returned T    ; Second clause: gives us a return value
T
CL-USER> (anyoddp '(6))
----Enter ANYODDP
|     Arg-1 = (6)
|   ----Enter ANYODDP    ; Third clause: recursive call.
|   |     Arg-1 = NIL
|    \--ANYODDP returned NIL    ; Second clause: NIL.
 \--ANYODDP returned NIL    ; First clause: NIL.
NIL


Calling DTRACE on ANYODDP, we can step ourselves through ANYODDPs conditional tests.


CL-USER> (anyoddp '(2 4 6 8 7 5 9))
----Enter ANYODDP
|     Arg-1 = (2 4 6 8 7 5 9)
|   ----Enter ANYODDP
|   |     Arg-1 = (4 6 8 7 5 9)
|   |   ----Enter ANYODDP
|   |   |     Arg-1 = (6 8 7 5 9)
|   |   |   ----Enter ANYODDP
|   |   |   |     Arg-1 = (8 7 5 9)
|   |   |   |   ----Enter ANYODDP    ; Stops parsing the list at 7.
|   |   |   |   |     Arg-1 = (7 5 9)
|   |   |   |    \--ANYODDP returned T
|   |   |    \--ANYODDP returned T
|   |    \--ANYODDP returned T
|    \--ANYODDP returned T
 \--ANYODDP returned T
T

In this example, there are multiple even and odd numbers listed.
DTRACE shows that ANYODDP finds an odd number 7 in its third conditional clause.


--
EXERCISES
--

8.1 Use a trace to show how ANYODDP handles (3142 5798 6550 8914).

CL-USER> (anyoddp '(3142 5798 6550 8914))
----Enter ANYODDP
|     Arg-1 = (3142 5798 6550 8914)
|   ----Enter ANYODDP
|   |     Arg-1 = (5798 6550 8914)
|   |   ----Enter ANYODDP
|   |   |     Arg-1 = (6550 8914)
|   |   |   ----Enter ANYODDP
|   |   |   |     Arg-1 = (8914)
|   |   |   |   ----Enter ANYODDP
|   |   |   |   |     Arg-1 = NIL
|   |   |   |    \--ANYODDP returned NIL
|   |   |    \--ANYODDP returned NIL
|   |    \--ANYODDP returned NIL
|    \--ANYODDP returned NIL
 \--ANYODDP returned NIL
NIL

Which COND clause is never true in this case?

We can see with DTRACE that ANYODDP gets hung up at the second clause.
The second COND clause tests every numerical element on the list until it is empty and cannot return a true value.


8.2 Show how to write ANYODDP using IF instead of COND.

(defun anyoddp (x)
  (if x
      (if (oddp (first x))
          t
          (anyoddp (rest x)))))



---
8.4 MARTIN VISITS THE DRAGON AGAIN
---

Martin goes down to the dungeon again one day.

He finds the dragon.

"I'm supposed to find out what five factorial is."

The dragon says, "The factorial of five is five times the factorial of four."

Martin: "What about the factorial of four?"

"Four times the factorial of three."

Martin: "... all the way to zero and then?"

"The factorial of zero is one. That's all you really need to know about factorials."


Martin had been writing down these steps as they had been talking in some sort of way -

Factorial(5) = 5 X Factorial(4)
             = 5 X 4 X Factorial(3)
             = 5 X 4 X 3 X Factorial(2)
             = 5 X 4 X 3 X 2 X Factorial(1)
             = 5 X 4 X 3 X 2 X 1 X Factorial(0)
             = 5 X 4 X 3 X 2 X 1 X 1


Peeking at Martin's work the dragon says,

"Well you've recursed all the way down to factorial of zero, which you know is one.
Why don't you try working your way back up to ..."

The dragon paused.

Too late, Martin had already drafted what the dragon was getting at -

                1 X 1= 1
            2 X 1 X 1= 2
        3 X 2 X 1 X 1= 6
    4 X 3 X 2 X 1 X 1= 24
5 X 4 X 3 X 2 X 1 X 1= 120

"The factorial of five is 120."

"Recursively figuring out how to recursively work your way back up."


The factorial of zero is one.

The factorial of n is n times factorial of n-1.



---
8.5 A LISP VERSION OF THE FACTORIAL FUNCTION
---

n factorial is n times n-1 factorial, and zero factorial is one.


FACT is a function that computes factorials recursively.

(defun fact (n)
  (cond ((zerop n) 1)
        (t (* n (fact (- n 1))))))

CL-USER> (fact 5)
----Enter FACT
|     Arg-1 = 5
|   ----Enter FACT
|   |     Arg-1 = 4
|   |   ----Enter FACT
|   |   |     Arg-1 = 3
|   |   |   ----Enter FACT
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter FACT
|   |   |   |   |     Arg-1 = 1
|   |   |   |   |   ----Enter FACT
|   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |    \--FACT returned 1
|   |   |   |    \--FACT returned 1
|   |   |    \--FACT returned 2
|   |    \--FACT returned 6
|    \--FACT returned 24
 \--FACT returned 120
120


--
EXERCISE
--

8.3 Why does (FACT 20.0) produce a different result than (FACT 20)?
Why does (FACT 0.0) and (FACT 0) both produce the same result?

20.0 is a floating point number, these numbers have limited precision.
20 is a bignum integer. Bignums have unlimited precision.

0 and 0.0 both satisfy the first COND clause within the FACT function definition.



---
8.6 THE DRAGON'S DREAM
---

Martin came back down to the dungeon.

Dragon looks like it just woke up.

"I had a recursive dream. Wanna Hear about it?"

"Ight .."


"Last night I was looking at a long loaf of bread, and I wondered how many slices it would make .."
"To answer my question I actually went and cut one slice from the loaf .."
"I then had one slice and a resulting shorter slice of bread (.. by one slice exactly) .."
"With no obvious solution in front of me, I fell asleep .."

"So then I fell asleep dreaming about a dragon who had a loaf of bread like mine, except his was a slice shorter .."
"This dragon also wanted to know how many slices his bread would make, but he turned up with the same results and fell asleep the same .."
"And so there he was sleeping and dreaming, and he had the same dream as well .."
".. except his loaf was exactly one slice shorter than that one dragons ..."

"Finally a dream turned up with a dragon that had an 'empty loaf'. He didn't fall asleep .."
"All the dragons ended up waking in series adding there missing slices to previous dragons until I woke up .."
"The loaf made 27 slices Martin. It was a long dream."



---
8.7 A RECURSIVE FUNCTION FOR COUNTING SLICES OF BREAD
---

If we represent a slice of bread by a symbol, then a loaf can be represented as a list of symbols.

The problem of finding how many slices a loaf contains is thus the problem of finding out how many elements a list contains.

An obvious solution for this problem is to use LENGTH, but what if LENGTH didn't exist ...


(defun count-slices (loaf)
  "Counts the number of elements in list LOAF recursively."
  (cond ((null loaf) 0)
        (t (+ 1 (count-slices (rest loaf))))))

We would still be able to count the slices recursively.


CL-USER> (dtrace count-slices)
WARNING: Function is not TRACEd: COUNT-SLICES
(COUNT-SLICES)
CL-USER> (count-slices nil)
----Enter COUNT-SLICES
|     Arg-1 = NIL
 \--COUNT-SLICES returned 0
0
CL-USER> (count-slices '(x))
----Enter COUNT-SLICES
|     Arg-1 = (X)
|   ----Enter COUNT-SLICES
|   |     Arg-1 = NIL
|    \--COUNT-SLICES returned 0
 \--COUNT-SLICES returned 1
1
CL-USER> (count-slices '(x x x x x))
----Enter COUNT-SLICES
|     Arg-1 = (X X X X X)
|   ----Enter COUNT-SLICES
|   |     Arg-1 = (X X X X)
|   |   ----Enter COUNT-SLICES
|   |   |     Arg-1 = (X X X)
|   |   |   ----Enter COUNT-SLICES
|   |   |   |     Arg-1 = (X X)
|   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |     Arg-1 = (X)
|   |   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |    \--COUNT-SLICES returned 0
|   |   |   |    \--COUNT-SLICES returned 1
|   |   |    \--COUNT-SLICES returned 2
|   |    \--COUNT-SLICES returned 3
|    \--COUNT-SLICES returned 4
 \--COUNT-SLICES returned 5
5

Once zero is reached, COUNT-SLICES can recursively call itself counting one to top level returning 5 as the result.



---
8.8 THE THREE RULES OF RECURSION
---

The dragon and Martin now kicked it on the regs.

The dragon:
".. every recursive problem is a journey Martin you understand?"
"Every journey can be completed if the three rules of recursion are followed ..."


THE-THREE-RULES-OF-RECURSION:

1) Know when to stop.
2) Decide how to take one step.
3) Break that journey down into that step plus a smaller journey,


We can apply these rules to Lisp functions that we have already written.


The first rule, "Know when to stop."
A recursive function must check if the journey has been previously completed before recursing further.
COND can satisfy this first rule by applying the empty-list-test to its first clause.

(defun anyoddp (x)
  "Takes a list of numbers. Returns T if any are odd."
  (cond ((null x) nil)    ; COND Test - Is the given list empty? No ...? Next test.
        ((oddp (first x)) t)    ; Is the first element of X odd? Yes then T. NIL, next test.
        (t (anyoddp (rest x)))))    ; Call myself on the rest of the list to find an odd number.

CL-USER> (dtrace anyoddp)
(ANYODDP)
CL-USER> (anyoddp '())
----Enter ANYODDP
|     Arg-1 = NIL
 \--ANYODDP returned NIL
NIL

ANYODDP tests whether the list is empty as the first COND clause.

Here is ANYODDP computing the return value on the second clause:

CL-USER> (anyoddp '(1 2 4 6))
----Enter ANYODDP
|     Arg-1 = (1 2 4 6)
 \--ANYODDP returned T
T

On the third:

CL-USER> (anyoddp '(2 4 6 1))
----Enter ANYODDP
|     Arg-1 = (2 4 6 1)
|   ----Enter ANYODDP
|   |     Arg-1 = (4 6 1)
|   |   ----Enter ANYODDP
|   |   |     Arg-1 = (6 1)
|   |   |   ----Enter ANYODDP
|   |   |   |     Arg-1 = (1)
|   |   |    \--ANYODDP returned T
|   |    \--ANYODDP returned T
|    \--ANYODDP returned T
 \--ANYODDP returned T
T


After applying DTRACE to ANYODDP and testing all three of its COND clauses-
The first test tells our function when to stop if there is an empty list.
The second test tells ANYODDP to stop if the first element on the list is odd.
The third test recursively calls on ANYODPP its self to evaluate each element,
  if no odd element is found stop and return NIL.

Knowing when to stop is applied in all the COND clauses.


(defun fact (n)
  (cond ((zerop n) 1)
        (t (* n (fact (- n 1))))))
CL-USER> (fact '0)

----Enter FACT
|     Arg-1 = 0
 \--FACT returned 1
1

FACT does a similar dance ...

CL-USER> (fact '3)
----Enter FACT
|     Arg-1 = 3
|   ----Enter FACT
|   |     Arg-1 = 2
|   |   ----Enter FACT
|   |   |     Arg-1 = 1
|   |   |   ----Enter FACT
|   |   |   |     Arg-1 = 0
|   |   |    \--FACT returned 1
|   |    \--FACT returned 1
|    \--FACT returned 2
 \--FACT returned 6
6

... when the input gets down to zero.


Zero factorial is one.
The rest are computed recursively.

(defun count-slices (loaf)
  "Counts the number of elements in list LOAF recursively."
  (cond ((null loaf) 0)
        (t (+ 1 (count-slices (rest loaf))))))

CL-USER> (count-slices '())
----Enter COUNT-SLICES
|     Arg-1 = NIL
 \--COUNT-SLICES returned 0
0

COUNT-SLICES knows to stop firstly if the empty list is input.

CL-USER> (count-slices '(x x x x x x x))
----Enter COUNT-SLICES
|     Arg-1 = (X X X X X X X)
|   ----Enter COUNT-SLICES
|   |     Arg-1 = (X X X X X X)
|   |   ----Enter COUNT-SLICES
|   |   |     Arg-1 = (X X X X X)
|   |   |   ----Enter COUNT-SLICES
|   |   |   |     Arg-1 = (X X X X)
|   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |     Arg-1 = (X X X)
|   |   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |   |     Arg-1 = (X X)
|   |   |   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |   |   |     Arg-1 = (X)
|   |   |   |   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |    \--COUNT-SLICES returned 0
|   |   |   |   |   |    \--COUNT-SLICES returned 1
|   |   |   |   |    \--COUNT-SLICES returned 2
|   |   |   |    \--COUNT-SLICES returned 3
|   |   |    \--COUNT-SLICES returned 4
|   |    \--COUNT-SLICES returned 5
|    \--COUNT-SLICES returned 6
 \--COUNT-SLICES returned 7
7

COUNT-SLICES also knows when to stop with a return value.

The function exhausts the list elements to zero,
recursively calls its self,
adding one,
stopping when the list is full,
then returning that value.


"Decide how to take one step."

CL-USER> (describe 'anyoddp)
COMMON-LISP-USER::ANYODDP
  [symbol]

ANYODDP names a compiled function:
  Lambda-list: (X)
  Derived type: (FUNCTION (T) *)
  Documentation:
    Takes a list of numbers. Returns T if any element of X is an odd number.
  Source form:
    (LAMBDA (X)
      "Takes a list of numbers. Returns T if any element of X is an odd number."
      (BLOCK ANYODDP
        (COND ((NULL X) NIL) ((ODDP (FIRST X)) T)
              (T (ANYODDP (REST X))))))

The second rule, break from the problem one tiny piece that we already know how to solve.
In ANYODDP we check whether the FIRST of some list is an odd number.

CL-USER> (describe 'fact)
COMMON-LISP-USER::FACT
  [symbol]

FACT names a compiled function:
  Lambda-list: (N)
  Derived type: (FUNCTION (T) (VALUES NUMBER &OPTIONAL))
  Source form:
    (LAMBDA (N)
      (BLOCK FACT (COND ((ZEROP N) 1) (T (* N (FACT (- N 1)))))))

FACT performs a single multiplication operation,
multiplying n by factorial of n-1.

CL-USER> (describe 'count-slices)
COMMON-LISP-USER::COUNT-SLICES
  [symbol]

COUNT-SLICES names a compiled function:
  Lambda-list: (LOAF)
  Derived type: (FUNCTION (T) (VALUES NUMBER &OPTIONAL))
  Documentation:
    Counts the number of elements in list LOAF recursively.
  Source form:
    (LAMBDA (LOAF)
      "Counts the number of elements in list LOAF recursively."
      (BLOCK COUNT-SLICES
        (COND ((NULL LOAF) 0) (T (+ 1 (COUNT-SLICES (REST LOAF)))))))

COUNT-SLICES uses a + operator:
For each slice that is cut from the loaf,
we add one to whatever the length of the resulting function turned out to be.


The third rule, "Break the journey down into that step plus a smaller journey."
Find a way for the function to call its self recursively on that resulting slightly smaller problem.

(defun anyoddp (x)
  "Takes a list of numbers. Returns T if any are odd."
  (cond ((null x) nil)    ; COND Test - Is the given list empty? No ...? Next test.
        ((oddp (first x)) t)    ; Is the first element of X odd? Yes then T. NIL, next test.
        (t (anyoddp (rest x)))))    ; Call myself on the rest of the list to find an odd number.

ANYODDP calls its self on the REST of the list.
That list being shorter than the original.
It is done until any odd numbers are found.

(defun fact (n)
  (cond ((zerop n) 1)
        (t (* n (fact (- n 1))))))

FACT recursively computes factorial n-1,
a simpler problem than factorial n.
The result of that being used to solve factorial n.

(defun count-slices (loaf)
  "Counts the number of elements in list LOAF recursively."
  (cond ((null loaf) 0)
        (t (+ 1 (count-slices (rest loaf))))))

COUNT-SLICES uses a recursive call to count the number of slices in the REST of the loaf,
then add one to the result to get the total number of slices in the whole loaf.


--
FIRST RECURSION EXERCISE
--

8.4 Write function LAUGH.
Takes a number as input and returns a list of that many HAs.

scratch LAUGH:
(defun laugh (n)
  (cond (?a ?b)
        (t (cons 'ha ?c))))


*Under what condition should the LAUGH function stop recursing?
*Replace ?a in the skeleton with that condition.

If the input is the empty list.
?a  =>  (zerop n)


*What value should LAUGH return for that case?
*Replace ?b with that value.

NIL should be returned
?b  =>  NIL


*A single step for this problem is to add a HA onto the result of a subproblem.
*Replace ?c with that subproblem.

(laugh (- n 1))


(defun laugh (n)
  "Takes a number, returns that many HAs."
  (cond ((zerop n) nil)    ; Stops recursing at the empty list.
        (t (cons 'ha (laugh (- n 1))))))    ; Adds HA onto the result of a sub-problem.

CL-USER> (laugh 5)
----Enter LAUGH
|     Arg-1 = 5
|   ----Enter LAUGH
|   |     Arg-1 = 4
|   |   ----Enter LAUGH
|   |   |     Arg-1 = 3
|   |   |   ----Enter LAUGH
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter LAUGH
|   |   |   |   |     Arg-1 = 1
|   |   |   |   |   ----Enter LAUGH
|   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |    \--LAUGH returned NIL
|   |   |   |    \--LAUGH returned (HA)
|   |   |    \--LAUGH returned (HA HA)
|   |    \--LAUGH returned (HA HA HA)
|    \--LAUGH returned (HA HA HA HA)
 \--LAUGH returned (HA HA HA HA HA)
(HA HA HA HA HA)
CL-USER> (laugh 0)
----Enter LAUGH
|     Arg-1 = 0
 \--LAUGH returned NIL
NIL

(LAUGH -1) results in a massive loop crashing my running Lisp ..


--
EXERCISES
--

8.5 Write ADD-UP.
It adds up all the numbers in a list.
REDUCE evaluates this problem applicatively.
Solve this problem recursively.
Follow all three rules of recursion.

CL-USER> (defun add-up (x)
           "Takes a list of numbers. Returns the sum of all numbers from input."
           (cond ((null x) 0)
                 (t (+ (first x) (add-up (rest x))))))
ADD-UP
CL-USER> (dtrace add-up)
(ADD-UP)
;; the second clause of COND
CL-USER> (add-up '(2 3 7))
----Enter ADD-UP    ; And go to REST
|     Arg-1 = (2 3 7)    ; Keep for FIRST and +
|   ----Enter ADD-UP
|   |     Arg-1 = (3 7)    ; Keep for FIRST and +
|   |   ----Enter ADD-UP
|   |   |     Arg-1 = (7)    ; Keep for FIRST and +
|   |   |   ----Enter ADD-UP
|   |   |   |     Arg-1 = NIL
|   |   |    \--ADD-UP returned 0    ; + FIRST of previous REST
|   |    \--ADD-UP returned 7    ; + FIRST of previous REST
|    \--ADD-UP returned 10    ; + FIRST of previous REST
 \--ADD-UP returned 12    ; This is the sum of the final argument. Its the return value.
12


8.6 Write ALLODDP, a recursive function that returns T if all the numbers on an input list are odd.

CL-USER> (defun alloddp (x)
           "Recursive. Returns T if all the numbers on the input list are odd."
           (cond ((null x) t)
                 ((evenp (first x)) nil)
                 (t (alloddp (rest x)))))
ALLODDP
CL-USER> (dtrace alloddp)
(ALLODDP)
CL-USER> (alloddp '(2 4 6 8))
----Enter ALLODDP
|     Arg-1 = (2 4 6 8)
 \--ALLODDP returned NIL
NIL
CL-USER> (alloddp '(1 3 4 5))
----Enter ALLODDP
|     Arg-1 = (1 3 4 5)
|   ----Enter ALLODDP
|   |     Arg-1 = (3 4 5)
|   |   ----Enter ALLODDP
|   |   |     Arg-1 = (4 5)
|   |    \--ALLODDP returned NIL
|    \--ALLODDP returned NIL
 \--ALLODDP returned NIL
NIL
CL-USER> (alloddp '(1 3 5 7 9))
----Enter ALLODDP
|     Arg-1 = (1 3 5 7 9)
|   ----Enter ALLODDP
|   |     Arg-1 = (3 5 7 9)
|   |   ----Enter ALLODDP
|   |   |     Arg-1 = (5 7 9)
|   |   |   ----Enter ALLODDP
|   |   |   |     Arg-1 = (7 9)
|   |   |   |   ----Enter ALLODDP
|   |   |   |   |     Arg-1 = (9)
|   |   |   |   |   ----Enter ALLODDP
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |    \--ALLODDP returned T
|   |   |   |    \--ALLODDP returned T
|   |   |    \--ALLODDP returned T
|   |    \--ALLODDP returned T
|    \--ALLODDP returned T
 \--ALLODDP returned T
T


8.7 Write a recursive version of MEMBER, REC-MEMBER.

CL-USER> (defun rec-member (e x)
           "Recursive version of MEMBER."
           (cond ((null x) nil)
                 ((equal e (first x)) x)
                 (t (rec-member e (rest x)))))
REC-MEMBER
CL-USER> (dtrace rec-member)
(REC-MEMBER)
CL-USER> (rec-member nil nil)
----Enter REC-MEMBER
|     Arg-1 = NIL
|     Arg-2 = NIL
 \--REC-MEMBER returned NIL
NIL
CL-USER> (rec-member 4 '(1 2 3 4 5 6 7))
----Enter REC-MEMBER    ; Go to the second clause with input.
|     Arg-1 = 4
|     Arg-2 = (1 2 3 4 5 6 7)    ; Is 4 EQUAL to FIRST of the given list? No. Next.
|   ----Enter REC-MEMBER    ; Grab the REST of the last given list given recursively by REC-MEMBER.
|   |     Arg-1 = 4
|   |     Arg-2 = (2 3 4 5 6 7)    ; Is 4 EQUAL ...? No. Next
|   |   ----Enter REC-MEMBER    ; Grab the REST of the last given ...
|   |   |     Arg-1 = 4
|   |   |     Arg-2 = (3 4 5 6 7)    ; Is 4 EQUAL ...?
|   |   |   ----Enter REC-MEMBER    ; Grab the REST ...
|   |   |   |     Arg-1 = 4
|   |   |   |     Arg-2 = (4 5 6 7)    ; Is 4 EQUAL ...? T, return 4 plus the REST of the previous list.
|   |   |    \--REC-MEMBER returned (4 5 6 7)
|   |    \--REC-MEMBER returned (4 5 6 7)
|    \--REC-MEMBER returned (4 5 6 7)
 \--REC-MEMBER returned (4 5 6 7)
(4 5 6 7)
CL-USER> (rec-member 4 '(1 2 3 5 6 7))
----Enter REC-MEMBER
|     Arg-1 = 4
|     Arg-2 = (1 2 3 5 6 7)
|   ----Enter REC-MEMBER
|   |     Arg-1 = 4
|   |     Arg-2 = (2 3 5 6 7)
|   |   ----Enter REC-MEMBER
|   |   |     Arg-1 = 4
|   |   |     Arg-2 = (3 5 6 7)
|   |   |   ----Enter REC-MEMBER
|   |   |   |     Arg-1 = 4
|   |   |   |     Arg-2 = (5 6 7)
|   |   |   |   ----Enter REC-MEMBER
|   |   |   |   |     Arg-1 = 4
|   |   |   |   |     Arg-2 = (6 7)
|   |   |   |   |   ----Enter REC-MEMBER
|   |   |   |   |   |     Arg-1 = 4
|   |   |   |   |   |     Arg-2 = (7)
|   |   |   |   |   |   ----Enter REC-MEMBER
|   |   |   |   |   |   |     Arg-1 = 4
|   |   |   |   |   |   |     Arg-2 = NIL
|   |   |   |   |   |    \--REC-MEMBER returned NIL
|   |   |   |   |    \--REC-MEMBER returned NIL
|   |   |   |    \--REC-MEMBER returned NIL
|   |   |    \--REC-MEMBER returned NIL
|   |    \--REC-MEMBER returned NIL
|    \--REC-MEMBER returned NIL
 \--REC-MEMBER returned NIL
NIL


8.8 Write a recursive version  of ASSOC, REC-ASSOC.

(defun rec-assoc (key table)
  "Recursive version of ASSOC."
  (cond ((null table) nil)
        ((equal key (car (first table)))
         (first table))
        (t (rec-assoc key (rest table)))))

CL-USER> (rec-assoc 'four words)
----Enter REC-ASSOC
|     Arg-1 = FOUR
|     Arg-2 = ((ONE UN) (TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
|   ----Enter REC-ASSOC
|   |     Arg-1 = FOUR
|   |     Arg-2 = ((TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
|   |   ----Enter REC-ASSOC
|   |   |     Arg-1 = FOUR
|   |   |     Arg-2 = ((THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
|   |   |   ----Enter REC-ASSOC
|   |   |   |     Arg-1 = FOUR
|   |   |   |     Arg-2 = ((FOUR QUATRE) (FIVE CINQ))
|   |   |    \--REC-ASSOC returned (FOUR QUATRE)
|   |    \--REC-ASSOC returned (FOUR QUATRE)
|    \--REC-ASSOC returned (FOUR QUATRE)
 \--REC-ASSOC returned (FOUR QUATRE)
(FOUR QUATRE)

CL-USER> (rec-assoc 'q rec-values)
----Enter REC-ASSOC
|     Arg-1 = Q
|     Arg-2 = ((X . 100) (Y . 200) (Z . 300) (Q . 500) (P . 35))
|   ----Enter REC-ASSOC
|   |     Arg-1 = Q
|   |     Arg-2 = ((Y . 200) (Z . 300) (Q . 500) (P . 35))
|   |   ----Enter REC-ASSOC
|   |   |     Arg-1 = Q
|   |   |     Arg-2 = ((Z . 300) (Q . 500) (P . 35))
|   |   |   ----Enter REC-ASSOC
|   |   |   |     Arg-1 = Q
|   |   |   |     Arg-2 = ((Q . 500) (P . 35))
|   |   |    \--REC-ASSOC returned (Q . 500)
|   |    \--REC-ASSOC returned (Q . 500)
|    \--REC-ASSOC returned (Q . 500)
 \--REC-ASSOC returned (Q . 500)
(Q . 500)


8.9 Write recursive version of NTH, REC-NTH.

(defun rec-nth (n x)
  "Recursive version of NTH."
  (cond ((zerop n) (first x))
        (t (rec-nth (- n 1) (rest x)))))

CL-USER> (rec-nth 0 '(a b c d))
----Enter REC-NTH
|     Arg-1 = 0
|     Arg-2 = (A B C D)
 \--REC-NTH returned A
A
CL-USER> (rec-nth 4 '(a b c d))
----Enter REC-NTH
|     Arg-1 = 4
|     Arg-2 = (A B C D)
|   ----Enter REC-NTH
|   |     Arg-1 = 3
|   |     Arg-2 = (B C D)
|   |   ----Enter REC-NTH
|   |   |     Arg-1 = 2
|   |   |     Arg-2 = (C D)
|   |   |   ----Enter REC-NTH
|   |   |   |     Arg-1 = 1
|   |   |   |     Arg-2 = (D)
|   |   |   |   ----Enter REC-NTH
|   |   |   |   |     Arg-1 = 0
|   |   |   |   |     Arg-2 = NIL
|   |   |   |    \--REC-NTH returned NIL
|   |   |    \--REC-NTH returned NIL
|   |    \--REC-NTH returned NIL
|    \--REC-NTH returned NIL
 \--REC-NTH returned NIL
NIL
CL-USER> (rec-nth 3 '(a b c d))
----Enter REC-NTH
|     Arg-1 = 3
|     Arg-2 = (A B C D)
|   ----Enter REC-NTH
|   |     Arg-1 = 2
|   |     Arg-2 = (B C D)
|   |   ----Enter REC-NTH
|   |   |     Arg-1 = 1
|   |   |     Arg-2 = (C D)
|   |   |   ----Enter REC-NTH
|   |   |   |     Arg-1 = 0
|   |   |   |     Arg-2 = (D)
|   |   |    \--REC-NTH returned D
|   |    \--REC-NTH returned D
|    \--REC-NTH returned D
 \--REC-NTH returned D
D


8.10 For x a nonnegative integer and y a positive integer, x+y equals x+1+(y-1).
If y is zero, then x+y equals x.
Use these equations to build a recursive version of + called REC-PLUS:
ADD1 SUB1 COND ZEROP
ADD1 and SUB1 will have to be written as well.

CL-USER> (defun add1 (n) (+ n 1))
ADD1
CL-USER> (defun sub1 (n) (- n 1))
SUB1
CL-USER> (defun rec-plus (x y)
           "Recursive version of +."
           (cond ((zerop y) x)
                 (t (rec-plus (add1 x) (sub1 y)))))
REC-PLUS
CL-USER> (dtrace add1 sub1 rec-plus)
WARNING: Function is not TRACEd: ADD1
WARNING: Function is not TRACEd: SUB1
WARNING: Function is not TRACEd: REC-PLUS
(ADD1 SUB1 REC-PLUS)
CL-USER> (rec-plus 2 3)
----Enter REC-PLUS
|     Arg-1 = 2
|     Arg-2 = 3
|   ----Enter ADD1
|   |     Arg-1 = 2
|    \--ADD1 returned 3
|   ----Enter SUB1
|   |     Arg-1 = 3
|    \--SUB1 returned 2
|   ----Enter REC-PLUS
|   |     Arg-1 = 3
|   |     Arg-2 = 2
|   |   ----Enter ADD1
|   |   |     Arg-1 = 3
|   |    \--ADD1 returned 4
|   |   ----Enter SUB1
|   |   |     Arg-1 = 2
|   |    \--SUB1 returned 1
|   |   ----Enter REC-PLUS
|   |   |     Arg-1 = 4
|   |   |     Arg-2 = 1
|   |   |   ----Enter ADD1
|   |   |   |     Arg-1 = 4
|   |   |    \--ADD1 returned 5
|   |   |   ----Enter SUB1
|   |   |   |     Arg-1 = 1
|   |   |    \--SUB1 returned 0
|   |   |   ----Enter REC-PLUS
|   |   |   |     Arg-1 = 5
|   |   |   |     Arg-2 = 0
|   |   |    \--REC-PLUS returned 5
|   |    \--REC-PLUS returned 5
|    \--REC-PLUS returned 5
 \--REC-PLUS returned 5
5
CL-USER> (rec-plus 0 0)
----Enter REC-PLUS
|     Arg-1 = 0
|     Arg-2 = 0
 \--REC-PLUS returned 0
0
CL-USER> (rec-plus -2 2)
----Enter REC-PLUS
|     Arg-1 = -2
|     Arg-2 = 2
|   ----Enter ADD1
|   |     Arg-1 = -2
|    \--ADD1 returned -1
|   ----Enter SUB1
|   |     Arg-1 = 2
|    \--SUB1 returned 1
|   ----Enter REC-PLUS
|   |     Arg-1 = -1
|   |     Arg-2 = 1
|   |   ----Enter ADD1
|   |   |     Arg-1 = -1
|   |    \--ADD1 returned 0
|   |   ----Enter SUB1
|   |   |     Arg-1 = 1
|   |    \--SUB1 returned 0
|   |   ----Enter REC-PLUS
|   |   |     Arg-1 = 0
|   |   |     Arg-2 = 0
|   |    \--REC-PLUS returned 0
|    \--REC-PLUS returned 0
 \--REC-PLUS returned 0
0

REC-PLUS recursively evaluates the return value from the previous argument until Y satisfies the ZEROP test.
Once Y is T for ZEROP, whatever X is at that point in the evaluation is the return value.

CL-USER> (rec-plus 3 3)
----Enter REC-PLUS
|     Arg-1 = 3
|     Arg-2 = 3
|   ----Enter ADD1
|   |     Arg-1 = 3
|    \--ADD1 returned 4
|   ----Enter SUB1
|   |     Arg-1 = 3
|    \--SUB1 returned 2
|   ----Enter REC-PLUS
|   |     Arg-1 = 4
|   |     Arg-2 = 2
|   |   ----Enter ADD1
|   |   |     Arg-1 = 4
|   |    \--ADD1 returned 5
|   |   ----Enter SUB1
|   |   |     Arg-1 = 2
|   |    \--SUB1 returned 1
|   |   ----Enter REC-PLUS
|   |   |     Arg-1 = 5
|   |   |     Arg-2 = 1
|   |   |   ----Enter ADD1    ; This is the step in the evaluation that triggers the first COND test-form.
|   |   |   |     Arg-1 = 5
|   |   |    \--ADD1 returned 6
|   |   |   ----Enter SUB1
|   |   |   |     Arg-1 = 1
|   |   |    \--SUB1 returned 0    ; SUB1 has returned 0. This satisfies the first test-form.
|   |   |   ----Enter REC-PLUS
|   |   |   |     Arg-1 = 6
|   |   |   |     Arg-2 = 0
|   |   |    \--REC-PLUS returned 6    ; Y (Arg-2) returns T for ZEROP. X (Arg-1) is the return value.
|   |    \--REC-PLUS returned 6
|    \--REC-PLUS returned 6
 \--REC-PLUS returned 6
6



---
8.9 MARTIN DISCOVERS INFINITE RECURSION
---

Martin came down to the dungeon to the dragon with a scroll.

"Someone else knows about recursion dude ..."

Dragon: "Gimme"

"This isn't right, there are too many parenthesis."


Martin say, "Yeah, it's weird. Turns out to be an algorithm for computing fibonacci numbers."

"It says - fib of n equals fib of n-1 plus fib of n-2. It's recursive. What else is there to it?"


Dragon: "What is Fib of four?"

"You can't find it, it's infinite."


Martin: "How did ya figure that out so quickly Mr. Dragon?"


Dragon: "See, the scroll told us how to take a single step. The scroll never mentions when to stop. Infinite recursion."



---
8.10 INFINITE RECURSION IN LISP
---

Lisp functions can be made to recurse infinitely by ignoring the dragon's first rule of recursion.
Know when to stop.
The Lisp implementation of Martin's algorithm:

(defun fib (n)
  "Martin's infinite recursion algorithm."
  (+ (fib (- n 1))
     (fib (- n 2))))


Attempting to evaluate this function will result in an infinite loop and your Lisp to abandon ship.

Good Lisp programmers can tell by glimpse whether a function will exhibit infinite recursion.


But check this out:

(defun c (n)
  (cond ((equal n 1) t)
        ((evenp n) (c (/ n 2)))
        (t (c (+ (* 3 n) 1)))))

CL-USER> (c 3)
----Enter C
|     Arg-1 = 3
|   ----Enter C
|   |     Arg-1 = 10
|   |   ----Enter C
|   |   |     Arg-1 = 5
|   |   |   ----Enter C
|   |   |   |     Arg-1 = 16
|   |   |   |   ----Enter C
|   |   |   |   |     Arg-1 = 8
|   |   |   |   |   ----Enter C
|   |   |   |   |   |     Arg-1 = 4
|   |   |   |   |   |   ----Enter C
|   |   |   |   |   |   |     Arg-1 = 2
|   |   |   |   |   |   |   ----Enter C
|   |   |   |   |   |   |   |     Arg-1 = 1
|   |   |   |   |   |   |    \--C returned T
|   |   |   |   |   |    \--C returned T
|   |   |   |   |    \--C returned T
|   |   |   |    \--C returned T
|   |   |    \--C returned T
|   |    \--C returned T
|    \--C returned T
 \--C returned T
T

CL-USER> (c 6)
----Enter C
|     Arg-1 = 6
|   ----Enter C
|   |     Arg-1 = 3
|   |   ----Enter C
|   |   |     Arg-1 = 10
|   |   |   ----Enter C
|   |   |   |     Arg-1 = 5
|   |   |   |   ----Enter C
|   |   |   |   |     Arg-1 = 16
|   |   |   |   |   ----Enter C
|   |   |   |   |   |     Arg-1 = 8
|   |   |   |   |   |   ----Enter C
|   |   |   |   |   |   |     Arg-1 = 4
|   |   |   |   |   |   |   ----Enter C
|   |   |   |   |   |   |   |     Arg-1 = 2
|   |   |   |   |   |   |   |   ----Enter C
|   |   |   |   |   |   |   |   |     Arg-1 = 1
|   |   |   |   |   |   |   |    \--C returned T
|   |   |   |   |   |   |    \--C returned T
|   |   |   |   |   |    \--C returned T
|   |   |   |   |    \--C returned T
|   |   |   |    \--C returned T
|   |   |    \--C returned T
|   |    \--C returned T
|    \--C returned T
 \--C returned T
T


This is algorithm is called Collatz's conjecture.

It is believed that T is returned for every positive integer,
  and that there are no possible inputs for infinite recursion.


--
EXERCISES
--

8.11 The missing part of Martin's Fibonacci algorithm is the rule for Fib(1) and Fib(0).
  Both of these are defined to be one.
  Using this information, write a correct version of the FIB function.

(defun fib (n)
  "Correct version of Martin's Fibonacci algorithm."
  (cond ((equal n 0) 1)
        ((equal n 1) 1)
        (t (+ (fib (- n 1))
              (fib (- n 2))))))

CL-USER> (fib 4)
----Enter FIB
|     Arg-1 = 4
|   ----Enter FIB
|   |     Arg-1 = 3
|   |   ----Enter FIB
|   |   |     Arg-1 = 2
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 1
|   |   |    \--FIB returned 1
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 0
|   |   |    \--FIB returned 1
|   |    \--FIB returned 2
|   |   ----Enter FIB
|   |   |     Arg-1 = 1
|   |    \--FIB returned 1
|    \--FIB returned 3
|   ----Enter FIB
|   |     Arg-1 = 2
|   |   ----Enter FIB
|   |   |     Arg-1 = 1
|   |    \--FIB returned 1
|   |   ----Enter FIB
|   |   |     Arg-1 = 0
|   |    \--FIB returned 1
|    \--FIB returned 2
 \--FIB returned 5
5
CL-USER> (fib 5)
----Enter FIB
|     Arg-1 = 5
|   ----Enter FIB
|   |     Arg-1 = 4
|   |   ----Enter FIB
|   |   |     Arg-1 = 3
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter FIB
|   |   |   |   |     Arg-1 = 1
|   |   |   |    \--FIB returned 1
|   |   |   |   ----Enter FIB
|   |   |   |   |     Arg-1 = 0
|   |   |   |    \--FIB returned 1
|   |   |    \--FIB returned 2
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 1
|   |   |    \--FIB returned 1
|   |    \--FIB returned 3
|   |   ----Enter FIB
|   |   |     Arg-1 = 2
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 1
|   |   |    \--FIB returned 1
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 0
|   |   |    \--FIB returned 1
|   |    \--FIB returned 2
|    \--FIB returned 5
|   ----Enter FIB
|   |     Arg-1 = 3
|   |   ----Enter FIB
|   |   |     Arg-1 = 2
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 1
|   |   |    \--FIB returned 1
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 0
|   |   |    \--FIB returned 1
|   |    \--FIB returned 2
|   |   ----Enter FIB
|   |   |     Arg-1 = 1
|   |    \--FIB returned 1
|    \--FIB returned 3
 \--FIB returned 8
8


8.12 Consider this version of ANY-7-P.

(defun any-7-p (x)
  "Recursively searches a list for the number seven."
  (cond ((equal (first x) 7) t)
        (t (any-7-p (rest x)))))

Sample input for which this function works correctly.
Give one for which the function will recurse infinitely.

CL-USER> (any-7-p '(1 2 3 7 4 5 2 1))
----Enter ANY-7-P
|     Arg-1 = (1 2 3 7 4 5 2 ...)
|   ----Enter ANY-7-P
|   |     Arg-1 = (2 3 7 4 5 2 1)
|   |   ----Enter ANY-7-P
|   |   |     Arg-1 = (3 7 4 5 2 1)
|   |   |   ----Enter ANY-7-P
|   |   |   |     Arg-1 = (7 4 5 2 1)
|   |   |    \--ANY-7-P returned T
|   |    \--ANY-7-P returned T
|    \--ANY-7-P returned T
 \--ANY-7-P returned T
T

The function ANY-7-P does not possess a test for whether there is an empty list as input.

CL-USER> (any-7-p '())
----Enter ANY-7-P
|     Arg-1 = NIL
|   ----Enter ANY-7-P
|   |     Arg-1 = NIL
|   |   ----Enter ANY-7-P
|   |   |     Arg-1 = NIL
|   |   |   ----Enter ANY-7-P
|   |   |   |     Arg-1 = NIL
|   |   |   |   ----Enter ANY-7-P
|   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
  Arg-1 = NIL
----Enter ANY-7-P
|     Arg-1 = NIL
|   ----Enter ANY-7-P
|   |     Arg-1 = NIL
|   |   ----Enter ANY-7-P
|   |   |     Arg-1 = NIL
|   |   |   ----Enter ANY-7-P
|   |   |   |     Arg-1 = NIL
|   |   |   |   ----Enter ANY-7-P
|   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
|   |   |   |   |   |   |   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |   |   |   |   |   |   |   |   ----Enter ANY-7-P
  Arg-1 = NIL
----Enter ANY-7-P
|     Arg-1 = NIL
|   ----Enter ANY-7-P

Therefore if the empty list is given to ANY-7-P as input, your Lisp will try hard then duck out


8.13 Review the function definition of FACT. What input would cause it infinite recursion?

(defun fact (n)
  (cond ((zerop n) 1)
        (t (* n (fact (- n 1))))))

Calling FACT with a negative number would cause it infinite recursion.


8.14 Write the very shortest infinite recursion function you can.

(defun infinite-recursion ()
  "The shortest infinitely recursive function from AGITSC."
  (infinite-recursion))


8.15 Look at the circular list in the book. What is the car of the list? What is the cdr? What will the COUNT-SLICES function do when given this iput?

(defun count-slices (loaf)
  "Counts the number of elements in list LOAF recursively."
  (cond ((null loaf) 0)
        (t (+ 1 (count-slices (rest loaf))))))

The car of the circular list is X.
The cdr is the list itself.
If this list were input to the function COUNT-SLICES, the function would recurse infinitely because the end of the cons cell chain can never be reached.



---
8.11 RECURSION TEMPLATES
---

Most recursive Lisp functions fall into a few standard forms.

These are described by recursion templates,
  which capture the form in a fill-in-the-blank pattern.

New functions may be created by selecting a template and filling in the blanks.

Once mastered, recursion templates can be used to analyze existing functions to see which pattern they fit.



8.11.1 Double-Test Tail Recursion

Template:

(DEFUN func (X)
  "Double-test tail recursion"
  (COND (end-test-1 end-value-1)
        (end-test-2 end-value-2)
        (T (func reduced-x))))


Double-test tail recursion has two end tests.

If either test is true, recursion is halted and the corresponding end value is returned.

When both end tests are false, we end up at the last COND clause.
The function reduces its input and then calls itself recursively.

This template is said to be tail-recursive because the action part of the last COND clause does not do any work after the recursive call.

Whatever result the recursive call produces, that is what the COND returns, so that is what each parent call returns.


Func: ANYODDP
End-test-1: (NULL X)
End-value-1: NIL
End-test-2: (ODDP (FIRST X))
End-value-2: T
Reduced-x: (REST X)

(defun anyoddp (x)
  "Takes a list of numbers. Returns T if any are odd."
  (cond ((null x) nil)    ; COND Test - Is the given list empty? No ...? Next test.
        ((oddp (first x)) t)    ; Is the first element of X odd? Yes then T. NIL, next test.
        (t (anyoddp (rest x)))))    ; Call myself on the rest of the list to find an odd number.

ANYODDP is an example of a tail-recursive function.


--
EXERCISES
--
8.16 What would happen if the first and second COND clauses were switched in ANYODDP?

If the empty list were input, unexpected data type error occurs.
The function does not recognize NIL as correct input.


8.17 Write FIND-FIRST-ODD with double-test tail recursion. Start by copying the recursion template values of ANYODDP.

(defun anyoddp (x)
  "Takes a list of numbers. Returns T if any are odd."
  (cond ((null x) nil)    ; COND Test - Is the given list empty? No ...? Next test.
        ((oddp (first x)) t)    ; Is the first element of X odd? Yes then T. NIL, next test.
        (t (anyoddp (rest x)))))    ; Call myself on the rest of the list to find an odd number.

(defun find-first-odd (x)
  "Finds the first odd element on the list."
  (cond ((null x) nil)
        ((oddp (first x)) (first x))
        (t (find-first-odd (rest x)))))

CL-USER> (anyoddp '(2 4 6 1 4 2))
----Enter ANYODDP
|     Arg-1 = (2 4 6 1 4 2)
|   ----Enter ANYODDP
|   |     Arg-1 = (4 6 1 4 2)
|   |   ----Enter ANYODDP
|   |   |     Arg-1 = (6 1 4 2)
|   |   |   ----Enter ANYODDP
|   |   |   |     Arg-1 = (1 4 2)
|   |   |    \--ANYODDP returned T
|   |    \--ANYODDP returned T
|    \--ANYODDP returned T
 \--ANYODDP returned T
T
CL-USER> (find-first-odd '(2 4 6 1 4 2))
----Enter FIND-FIRST-ODD
|     Arg-1 = (2 4 6 1 4 2)
|   ----Enter FIND-FIRST-ODD
|   |     Arg-1 = (4 6 1 4 2)
|   |   ----Enter FIND-FIRST-ODD
|   |   |     Arg-1 = (6 1 4 2)
|   |   |   ----Enter FIND-FIRST-ODD
|   |   |   |     Arg-1 = (1 4 2)
|   |   |    \--FIND-FIRST-ODD returned 1
|   |    \--FIND-FIRST-ODD returned 1
|    \--FIND-FIRST-ODD returned 1
 \--FIND-FIRST-ODD returned 1
1

The reason why the odd number that was found is returned instead of T is because -
  The end-value-1 in ANYODDP is T.
  The end-value-1 in FIND-FIRST-ODD is (FIRST X)
    (FIRST X) is what returned T for end-test-1



8.11.2 Single-Test Tail Recursion

Template:

(DEFUN func (X)
  "Single-test tail recursion"
  (COND (end-test end-value)
        (T (func reduced-x))))

Example:

Func: FIND-FIRST-ATOM
End-test: (ATOM X)
End-value: X
Reduced-x: (FIRST X)

(defun find-first-atom (x)
  "Finds the first atom on the list."
  (cond ((atom x) x)
        (t (find-first-atom (first x)))))


CL-USER> (find-first-atom '(1 2 3))
----Enter FIND-FIRST-ATOM
|     Arg-1 = (1 2 3)
|   ----Enter FIND-FIRST-ATOM
|   |     Arg-1 = 1
|    \--FIND-FIRST-ATOM returned 1
 \--FIND-FIRST-ATOM returned 1
1
CL-USER> (find-first-atom '((((a f)) i) r))
----Enter FIND-FIRST-ATOM
|     Arg-1 = ((((A F)) I) R)
|   ----Enter FIND-FIRST-ATOM
|   |     Arg-1 = (((A F)) I)
|   |   ----Enter FIND-FIRST-ATOM
|   |   |     Arg-1 = ((A F))
|   |   |   ----Enter FIND-FIRST-ATOM
|   |   |   |     Arg-1 = (A F)
|   |   |   |   ----Enter FIND-FIRST-ATOM
|   |   |   |   |     Arg-1 = A
|   |   |   |    \--FIND-FIRST-ATOM returned A
|   |   |    \--FIND-FIRST-ATOM returned A
|   |    \--FIND-FIRST-ATOM returned A
|    \--FIND-FIRST-ATOM returned A
 \--FIND-FIRST-ATOM returned A
A
CL-USER> (find-first-atom 'fred)
----Enter FIND-FIRST-ATOM
|     Arg-1 = FRED
 \--FIND-FIRST-ATOM returned FRED
FRED

If we are trying to find an atom nested arbitrarily deep within the input list,
  we can take successive FIRSTs of the list until an atom is reached.

Single-test recursion is generally used when we know the function will always find what it is looking for eventually.
Otherwise we can get infinite recursion as a return value.

FIND-FIRST-ATOM is guaranteed to find an atom if it keeps taking successive FIRSTs of its input.

We use double-test recursion when there is the possibility the function might not find a return value.
  In ANYODDP the second test checked if it had found an odd number,
  but first a test was needed to see if the function had run off the end of the list (NIL if it tried).


--
EXERCISES
--
8.18 Use single-test tail recursion to write LAST-ELEMENT, a function that returns the last element of a list.

(defun last-element (x)
  "Recursively returns the last element of the list."
  (cond ((atom (cdr x)) (car x))
        (t (last-element (cdr x)))))

*Your first try was with LAST as the end-test ... LAST is not a test function dumbass*

CL-USER> (last-element '(a b c d))
----Enter LAST-ELEMENT
|     Arg-1 = (A B C D)
|   ----Enter LAST-ELEMENT
|   |     Arg-1 = (B C D)
|   |   ----Enter LAST-ELEMENT
|   |   |     Arg-1 = (C D)
|   |   |   ----Enter LAST-ELEMENT
|   |   |   |     Arg-1 = (D)
|   |   |    \--LAST-ELEMENT returned D
|   |    \--LAST-ELEMENT returned D
|    \--LAST-ELEMENT returned D
 \--LAST-ELEMENT returned D
D

When we translate this function definition to english,
  LAST-ELEMENT recursively travels down the input list
  until it reaches the last cons cell (a cell whose cdr is an atom);
  then it returns the car of that cell.


8.19 Suppose we decided to convert ANYODDP to single-test tail recursion by eliminating the COND clause with the NULL test.
  For which inputs would it still work?
  What occurs under failed tests?

If ANYODDP is converted to single-test tail recursion by eliminating the NULL test,
  it will function properly as long as an input list has an odd number;
  It's an error if there are no odd numbers found in a list,
  ANYODDP cannot compute the ODDP of NIL.



8.11.3 Augmenting Recursion

Template:

(DEFUN func (X)
  "Augmenting recursion"
  (COND (end-test end-value)
        (T (aug-fun aug-val
                    (func reduced-x)))))

Example:

Func: COUNT-SLICES
End-test: (NULL X)
End-value: 0
Aug-fun: +
Aug-val: 1
Reduced-x: (REST X)

(defun count-slices (x)
  (cond ((null x) 0)
        (t (+ 1 (count-slices (rest x))))))


Augmenting recursive functions build up their return values bit-by-bit.

Instead of dividing the problem into an initial step plus a smaller journey,
  they divide it into a smaller journey plus a final step.

The final step consists of choosing an augmentation value
  and applying it to the result of the previous recursive call.

In COUNT-SLICES we built up the result by first making a recursive call
  and then adding one to the input.


No augmentation of the result is permitted in tail-recursive functions.

The return value of a tail-recursive function is always equal
  to one of the end-values in the function definition.
  It isn't built up as each recursive call returns.

Compare to ANYODDP, a function that only returns T or NIL.
  It never augments its result.


--
EXERCISES
--
8.20 Which template describes FACT? Show the template components of FACT.

(defun fact (n)
  (cond ((zerop n) 1)
        (t (* n (fact (- n 1))))))

Func: FACT
End-test: (ZEROP N)
End-value: 1
Aug-fun: *
Aug-val: N
Reduced-x: (- N 1)

The augmenting recursion template fits FACT.


8.21 Write recursive function ADD-BUMS that adds up the numbers
  N, N-1, N-2, ..., down to 0 and returns the result.

(defun add-nums (n)
  "Recursively adds down to zero and returns the result."
  (cond ((zerop n) 0)
        (t (+ n (add-nums (- n 1))))))

Func: ADD-NUMS
End-test: (ZEROP N)
End-value: 0
Aug-fun: +
Aug-val: N
Reduced-x: (- N 1)

CL-USER> (add-nums 5)
----Enter ADD-NUMS
|     Arg-1 = 5
|   ----Enter ADD-NUMS
|   |     Arg-1 = 4
|   |   ----Enter ADD-NUMS
|   |   |     Arg-1 = 3
|   |   |   ----Enter ADD-NUMS
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter ADD-NUMS
|   |   |   |   |     Arg-1 = 1
|   |   |   |   |   ----Enter ADD-NUMS
|   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |    \--ADD-NUMS returned 0
|   |   |   |    \--ADD-NUMS returned 1
|   |   |    \--ADD-NUMS returned 3
|   |    \--ADD-NUMS returned 6
|    \--ADD-NUMS returned 10
 \--ADD-NUMS returned 15
15


8.22 Write a recursive function ALL-EQUAL that returns T if the first element of a list is equal to the second, the second equal to the third, the third equal to the fourth, etc. ALL-EQUAL should NIL for lists which elements are not all equal and T for lists with less than two elements. Does this problem require augmentation? Which template will you use to solve it?

This recursive function will use the double-test tail recursion template.

(defun all-equal (n)
  "Returns T if all elements of the list are equal."
  (cond ((null (rest x)) t)
        ((not (equal (first x) (second x))) nil)
        (t (all-equal (rest x)))))


Augmentation is not required, the function only returns T or NIL.


CL-USER> (all-equal '(i i i i i))
----Enter ALL-EQUAL
|     Arg-1 = (I I I I I)
|   ----Enter ALL-EQUAL
|   |     Arg-1 = (I I I I)
|   |   ----Enter ALL-EQUAL
|   |   |     Arg-1 = (I I I)
|   |   |   ----Enter ALL-EQUAL
|   |   |   |     Arg-1 = (I I)
|   |   |   |   ----Enter ALL-EQUAL
|   |   |   |   |     Arg-1 = (I)
|   |   |   |    \--ALL-EQUAL returned T
|   |   |    \--ALL-EQUAL returned T
|   |    \--ALL-EQUAL returned T
|    \--ALL-EQUAL returned T
 \--ALL-EQUAL returned T
T
CL-USER> (all-equal '(i i e i))
----Enter ALL-EQUAL
|     Arg-1 = (I I E I)
|   ----Enter ALL-EQUAL
|   |     Arg-1 = (I E I)
|    \--ALL-EQUAL returned NIL
 \--ALL-EQUAL returned NIL
NIL
CL-USER> (all-equal '(i))
----Enter ALL-EQUAL
|     Arg-1 = (I)
 \--ALL-EQUAL returned T
T

Break ALL-EQUAL down to the pieces.

(defun all-equal (n)
  "Returns T if all elements of the list are equal."
  (cond ((null (rest x)) t)
        ((not (equal (first x) (second x))) nil)
        (t (all-equal (rest x)))))

Func:  ALL-EQUAL
End-test-1:  (NULL (REST X))
End-value-1:  T
End-test-2:  (NOT (EQUAL (FIRST X) (SECOND X)))
End-value-2:  NIL
Reduced-x:  (REST X)

CL-USER> (all-equal '(p p p p))
----Enter ALL-EQUAL
|     Arg-1 = (P P P P)
|   ----Enter ALL-EQUAL
|   |     Arg-1 = (P P P)
|   |   ----Enter ALL-EQUAL
|   |   |     Arg-1 = (P P)
|   |   |   ----Enter ALL-EQUAL
|   |   |   |     Arg-1 = (P)
|   |   |    \--ALL-EQUAL returned T
|   |    \--ALL-EQUAL returned T
|    \--ALL-EQUAL returned T
 \--ALL-EQUAL returned T
T

CL-USER> (all-equal '(e i i))
----Enter ALL-EQUAL
|     Arg-1 = (E I I)
 \--ALL-EQUAL returned NIL
NIL

End-test-1 End-value-1:
((NULL (REST X)) T)
NULL occupies the T cons cell.
(REST X) occupies the value cons cell.
When the value cell of (REST X) returns NULL, end-test-1 is then satisfied.
If end-test-1 is triggered, it matches the T of end-value-1.
The value of end-test-1 is the return value.

Remember that this is a double-test tail recursion type function,
  the NULL value is set by us, so we know that if this test is triggered
  NIL will be the return value.


End-test-2 End-value-2:
((NOT (EQUAL (FIRST X) (SECOND X))) NIL)
NOT occupies the T cons cell.
(EQUAL (FIRST X) (SECOND X)) occupies the value cons cell.

  This takes the FIRST and SECOND elements of the list, then tests their EQUALity,
  for a T value, NOT switches it to NIL,
  test is satisfied and recursion may continue.

  For a NIL test value, NOT switches the value to T.
  This does not match the defined end-value-2,
  recursion is halted - NIL is the return value.


Reduced-x:
(T (ALL-EQUAL (REST X)))
This is the recursive portion of the function definition.
The reduced-x method uses REST to reduce the list by one each time the list is passed down.

CL-USER> (all-equal '(i i g g))
----Enter ALL-EQUAL
|     Arg-1 = (I I G G)
|   ----Enter ALL-EQUAL
|   |     Arg-1 = (I G G)
|    \--ALL-EQUAL returned NIL
 \--ALL-EQUAL returned NIL
NIL

In this example we can see each element is passed one-by-one.
The symbol I is reduced by one each time the list is recursed.
Once the list is exhausted of elements, NIL becomes the recursed input value.
T catches the NIL and is returned as the value.

CL-USER> (defun all-equal-bogotified (x)
           "The T replaced with NIL on the reduced-x line."
           (cond ((null (rest x)) t)
                 ((not (equal (first x) (second x))) nil)
                 (nil (all-equal (rest x)))))
ALL-EQUAL-BOGOTIFIED
CL-USER> (all-equal-bogotified '(i i i i))
----Enter ALL-EQUAL-BOGOTIFIED
|     Arg-1 = (I I I I)
 \--ALL-EQUAL-BOGOTIFIED returned NIL
NIL

  If T were replaced with NIL in the test portion of the cons cell chain
    the function would return true for NIL,
    this satisfies the NIL occupying the test portion of the cons cell chain,
    recursion halts and NIL is passed as the return value.

  We can see with ALL-EQUAL-BOGOTIFIED a list with all elements equal is input,
    but NIL is returned instead of T.

CL-USER> (defun all-equal-bogotified (x)
           "The T is missing from the reduced-x line."
           (cond ((null (rest x)) t)
                 ((not (equal (first x) (second x))) nil)
                 ((all-equal (rest x)))))
ALL-EQUAL-BOGOTIFIED
CL-USER> (all-equal-bogotified '(g g g))
----Enter ALL-EQUAL-BOGOTIFIED
|     Arg-1 = (G G G)
 \--ALL-EQUAL-BOGOTIFIED returned T
T

  If T were completely remove from the reduced-x line,
    the function assumes a T value and works properly.


---
8.12 VARIATIONS OF THE BASIC TEMPLATES
---

The templates learned so far are useful.
There are common ways of using them in Lisp programming.



8.12.1 List-Consing Recursion

(DEFUN func (N)
  "Every time the function is recursed, one new cons cell is created."
  (COND (end-test NIL)
        (T (CONS new-element
                 (func reduced-n)))))


List-consing recursion is used frequently in Lisp.

It is a special case of augmenting recursion where the augmentation function  used is CONS.
As each recursive call returns, one new cons cell is created.
The depth of the recursion is equal to the length of the resulting cons cell chain, plus one (the last call returns NIL instead of a cons).

Func: LAUGH
End-test: (ZEROP N)
New-element: 'HA
Reduced-n: (- N 1)

(defun laugh (n)
  "Takes a number, returns that many HAs."
  (cond ((zerop n) nil)
        (t (cons 'ha (laugh (- n 1))))))

LAUGH is an example of list-consing recursion.


--
EXERCISES
--
8.23 Suppose we evaluate (LAUGH 5). Make a table showing each call to LAUGH and what happens to the value of N (from 5 to 0), the value of the first input to CONS, the value of the second input to CONS, and the result returned by LAUGH.


CL-USER> (defun laugh (n)
           "Takes a number and returns that many HAs"
           (cond ((zerop n) nil)
                 (t (cons 'ha (laugh (- n 1))))))

CL-USER> (laugh 5)
----Enter LAUGH
|     Arg-1 = 5
|   ----Enter LAUGH
|   |     Arg-1 = 4
|   |   ----Enter LAUGH
|   |   |     Arg-1 = 3
|   |   |   ----Enter LAUGH
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter LAUGH
|   |   |   |   |     Arg-1 = 1
|   |   |   |   |   ----Enter LAUGH
|   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |    \--LAUGH returned NIL
|   |   |   |    \--LAUGH returned (HA)
|   |   |    \--LAUGH returned (HA HA)
|   |    \--LAUGH returned (HA HA HA)
|    \--LAUGH returned (HA HA HA HA)
 \--LAUGH returned (HA HA HA HA HA)
(HA HA HA HA HA)
CL-USER> (sdraw-loop)
Type any Lisp expression, or :ABORT to exit.

S> (laugh 5)

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |        |        |
 v        v        v        v        v
 HA       HA       HA       HA       HA

Result:  (HA HA HA HA HA)

(CONS 'HA (LAUGH (- 5 1)))
The first input to CONS is 5.
1 is taken from 5, making 4.
(LAUGH 4) results from that.
The second input to CONS is (LAUGH 4).
  (CONS 'HA (LAUGH 4))  =>  (HA HA HA HA HA)

(CONS 'HA (LAUGH (- 4 1)))
The first input to CONS is 4.
1 is taken from 4, resulting in 3.
(LAUGH 3) evaluates from that.
The second input to CONS is the recursed function (LAUGH 3).
  (CONS 'HA (LAUGH 3))  =>  (HA HA HA HA)

(CONS 'HA (LAUGH (- 3 1)))
The first input to CONS is 3.
1 is taken from 3, resulting in 2.
(LAUGH 2) evaluates from that.
The second input to CONS is the recursive function (LAUGH 2).
  (CONS 'HA (LAUGH 2))  =>  (HA HA HA)

(CONS 'HA (LAUGH (- 2 1)))
The first input to CONS is 2.
1 is taken from 2, resulting in 1.
(LAUGH 1) evaluates from that.
The second input to CONS in the recursive function (LAUGH 1).
  (CONS 'HA (LAUGH 1))  =>  (HA HA)

(CONS 'HA (LAUGH (- 1 1)))
The first input to CONS is 1.
1 is taken from 1, resulting in 0.
(LAUGH 0) evaluates from that.
The second input to CONS is (LAUGH 0).
  (CONS 'HA (LAUGH 0)  =>  (HA)

(CONS 'HA (LAUGH 0))
The first input to CONS is (LAUGH 0).
NIL is passed up to ZEROP triggering the conditional end-test,
  and LAUGH retraces to the return value of its initial input (HA HA HA HA HA).


8.24 Write COUNT-DOWN, a function that counts down from n using list-consing recursion.

(defun func (n)
  "Template for list-consing recursion."
  (cond (end-test end-value)
        (t (cons new-element
                 (func reduced-n)))))

(defun count-down (n)
  "Takes a number then counts down to zero from there."
  (cond ((zerop n) nil)
        (t (cons n (count-down (- n 1))))))

CL-USER> (count-down 5)
----Enter COUNT-DOWN
|     Arg-1 = 5
|   ----Enter COUNT-DOWN
|   |     Arg-1 = 4
|   |   ----Enter COUNT-DOWN
|   |   |     Arg-1 = 3
|   |   |   ----Enter COUNT-DOWN
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |     Arg-1 = 1
|   |   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |    \--COUNT-DOWN returned NIL
|   |   |   |    \--COUNT-DOWN returned (1)
|   |   |    \--COUNT-DOWN returned (2 1)
|   |    \--COUNT-DOWN returned (3 2 1)
|    \--COUNT-DOWN returned (4 3 2 1)
 \--COUNT-DOWN returned (5 4 3 2 1)
(5 4 3 2 1)
CL-USER> (count-down nil)
----Enter COUNT-DOWN
|     Arg-1 = NIL; Evaluation aborted on #<TYPE-ERROR expected-type: NUMBER datum: NIL>.
CL-USER> (count-down 0)

----Enter COUNT-DOWN
|     Arg-1 = 0
 \--COUNT-DOWN returned NIL
NIL
CL-USER> (describe 'count-down)
COMMON-LISP-USER::COUNT-DOWN
  [symbol]

COUNT-DOWN names a compiled function:
  Lambda-list: (&REST DTRACE::ARGUMENT-LIST)
  Derived type: FUNCTION
  Source file: c:/Users/tylerbrw/Documents/lisp/references/an-introduction/book-software/dtrace/dtrace.lisp

Symbol-plist:
  DTRACE::TRACED-TYPE -> DEFUN
  DTRACE::TRACED-DEFINITION -> #<CLOSURE (LAMBDA (&REST DTRACE..
  DTRACE::ORIGINAL-DEFINITION -> #<FUNCTION COUNT-DOWN {10023433..
; No value


8.25 How could COUNT-DOWN be used to write APPLIC-FACT, an applicative version of FACT?

(defun applic-fact (n)
  "Applicative version of FACT with user defined function COUNT-DOWN."
  (reduce #'* (count-down n)))

Explain:

Let's remind ourselves the return value of n-factorial-

n factorial is n times n-1 factorial,
    and zero factorial is one.
      
Let's remind ourselves of what FACT is-

(defun fact (n)
  "n FACTorial is n times n-1 FACTorial, and zero factorial is one."
  (cond ((zerop n) 1)
        (t (* n (fact (- n 1))))))

CL-USER> (fact 5)
----Enter FACT
|     Arg-1 = 5 <-------------------------
|   ----Enter FACT                       |
|   |     Arg-1 = 4                      |
|   |   ----Enter FACT                   |
|   |   |     Arg-1 = 3                  |
|   |   |   ----Enter FACT               |
|   |   |   |     Arg-1 = 2              |
|   |   |   |   ----Enter FACT           |
|   |   |   |   |     Arg-1 = 1          |
|   |   |   |   |   ----Enter FACT       |
|   |   |   |   |   |     Arg-1 = 0      |
|   |   |   |   |    \--FACT returned 1  ---------> The product of 5 and 24 is 120.
|   |   |   |    \--FACT returned 1      |            Factorial 5 is 120.
|   |   |    \--FACT returned 2          |              (FACT 5)  =>  120
|   |    \--FACT returned 6              |                             |
|    \--FACT returned 24 <----------------                             |
 \--FACT returned 120                                                  |
120 <------------------------------------------------------------------

What is COUNT-DOWN?

(defun count-down (n)
  "Takes a number and counts to one from there,"
  (cond ((zerop n) nil)
        (t (cons n (count-down (- n 1))))))

CL-USER> (count-down 5)
----Enter COUNT-DOWN
|     Arg-1 = 5
|   ----Enter COUNT-DOWN
|   |     Arg-1 = 4
|   |   ----Enter COUNT-DOWN
|   |   |     Arg-1 = 3
|   |   |   ----Enter COUNT-DOWN
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |     Arg-1 = 1
|   |   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |    \--COUNT-DOWN returned NIL
|   |   |   |    \--COUNT-DOWN returned (1)
|   |   |    \--COUNT-DOWN returned (2 1)
|   |    \--COUNT-DOWN returned (3 2 1)
|    \--COUNT-DOWN returned (4 3 2 1)
 \--COUNT-DOWN returned (5 4 3 2 1)
(5 4 3 2 1)

COUNT-DOWN takes a number then returns a list of that number counted down to one.

We know what n-factorial is.
We know how FACT is defined.
We know how COUNT-DOWN is defined.

If the factorial of some number is that number multiplied by the preceding number,
  then the result of that multiplied by the preceding number to zero (which is one),

.. And

If we know that COUNT-DOWN takes a number
  then returns a list of that recursively counted to one ...

Then all we need to do is multiply all the numbers on a list COUNT-DOWN returns together.

We can use the applicative operator REDUCE to and * to multiply COUNT-DOWN
  against the values returned by COUNT-DOWN for each cycle of recursion 

CL-USER> (reduce #'* '(5 4 3 2 1))
120

CL-USER> (reduce #'* (count-down 5))
----Enter COUNT-DOWN
|     Arg-1 = 5
|   ----Enter COUNT-DOWN
|   |     Arg-1 = 4
|   |   ----Enter COUNT-DOWN
|   |   |     Arg-1 = 3
|   |   |   ----Enter COUNT-DOWN
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |     Arg-1 = 1
|   |   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |    \--COUNT-DOWN returned NIL
|   |   |   |    \--COUNT-DOWN returned (1)
|   |   |    \--COUNT-DOWN returned (2 1)
|   |    \--COUNT-DOWN returned (3 2 1)
|    \--COUNT-DOWN returned (4 3 2 1)
 \--COUNT-DOWN returned (5 4 3 2 1)
120

There lies our function definition in all of its glory.

(defun applic-fact (n)
  "Applicative version of FACT using the user defined recursive function COUNT-DOWN."
  (reduce #'* (count-down n)))

CL-USER> (applic-fact 5)
----Enter APPLIC-FACT
|     Arg-1 = 5
|   ----Enter COUNT-DOWN
|   |     Arg-1 = 5
|   |   ----Enter COUNT-DOWN
|   |   |     Arg-1 = 4
|   |   |   ----Enter COUNT-DOWN
|   |   |   |     Arg-1 = 3
|   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |     Arg-1 = 2
|   |   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |   |     Arg-1 = 1
|   |   |   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |   |    \--COUNT-DOWN returned NIL
|   |   |   |   |    \--COUNT-DOWN returned (1)
|   |   |   |    \--COUNT-DOWN returned (2 1)
|   |   |    \--COUNT-DOWN returned (3 2 1)
|   |    \--COUNT-DOWN returned (4 3 2 1)
|    \--COUNT-DOWN returned (5 4 3 2 1)
 \--APPLIC-FACT returned 120
120

8.26 Suppose we wanted to modify COUNT-DOWN so that the list it constructs ends in zero.

(defun count-down-to-zero (n)
  "Takes a number, counts to zero from there"
  (cond ((equal n -1) nil)
        (t (cons n (count-down (- n 1))))))

CL-USER> (count-down-to-zero 5)
----Enter COUNT-DOWN-TO-ZERO
|     Arg-1 = 5
|   ----Enter COUNT-DOWN
|   |     Arg-1 = 4
|   |   ----Enter COUNT-DOWN
|   |   |     Arg-1 = 3
|   |   |   ----Enter COUNT-DOWN
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |     Arg-1 = 1
|   |   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |    \--COUNT-DOWN returned NIL
|   |   |   |    \--COUNT-DOWN returned (1)
|   |   |    \--COUNT-DOWN returned (2 1)
|   |    \--COUNT-DOWN returned (3 2 1)
|    \--COUNT-DOWN returned (4 3 2 1)
 \--COUNT-DOWN-TO-ZERO returned (5 4 3 2 1)
(5 4 3 2 1)

(defun count-down-to-zero-differently (n)
  "Takes a number, count to zero from there."
  (cond ((zerop n) (list 0))
        (t (cons n (count-down (- n 1))))))

CL-USER> (count-down-to-zero-differently 5)
----Enter COUNT-DOWN-TO-ZERO-DIFFERENTLY
|     Arg-1 = 5
|   ----Enter COUNT-DOWN
|   |     Arg-1 = 4
|   |   ----Enter COUNT-DOWN
|   |   |     Arg-1 = 3
|   |   |   ----Enter COUNT-DOWN
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |     Arg-1 = 1
|   |   |   |   |   ----Enter COUNT-DOWN
|   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |    \--COUNT-DOWN returned NIL
|   |   |   |    \--COUNT-DOWN returned (1)
|   |   |    \--COUNT-DOWN returned (2 1)
|   |    \--COUNT-DOWN returned (3 2 1)
|    \--COUNT-DOWN returned (4 3 2 1)
 \--COUNT-DOWN-TO-ZERO-DIFFERENTLY returned (5 4 3 2 1)
(5 4 3 2 1)

Hmm ...

This didn't work.


8.27 Write SQUARE-LIST, a recursive function that takes a list of numbers and returns a list of their squares.

(defun square-list (n)
  "Takes a list of numbers, returns a list of their squares."
  (cond ((null x) nil)
        (t (cons (* (first x) (first x))
                 (square-list (rest x))))))

CL-USER> (square-list '(3 4 5 6))
----Enter SQUARE-LIST
|     Arg-1 = (3 4 5 6)
|   ----Enter SQUARE-LIST
|   |     Arg-1 = (4 5 6)
|   |   ----Enter SQUARE-LIST
|   |   |     Arg-1 = (5 6)
|   |   |   ----Enter SQUARE-LIST
|   |   |   |     Arg-1 = (6)
|   |   |   |   ----Enter SQUARE-LIST
|   |   |   |   |     Arg-1 = NIL
|   |   |   |    \--SQUARE-LIST returned NIL
|   |   |    \--SQUARE-LIST returned (36)
|   |    \--SQUARE-LIST returned (25 36)
|    \--SQUARE-LIST returned (16 25 36)
 \--SQUARE-LIST returned (9 16 25 36)
(9 16 25 36)


SQUARE-LIST is taken down to NIL by the end-test (NULL X) NIL).
The augmenting CONS contains a nested operation multiplying each number against its self.

CONS operates on each element passed by the end-test from bottom up,
  listing each result until it reaches the first argument.



8.12.2 Simultaneous Recursion on Several Variables

Simultaneous recursion on multiple variables is a straightforward extension to recursion templates.

Instead of having only one input, the function has several,
  and one or more of the inputs will be reduced with each recursive call.

(DEFUN func (x)
  "Template for single-test tail recursion."
  (COND (end-test end-value)
        (T (func reduced-x)

(DEFUN func (N X)
  "Template for simultaneous recursion on several variables."
  (COND (end-test end-value)
        (T (func reduced-n reduced-x))))

(defun my-nth (n x)
  "Simultaneous recursion on two variables extending a single-test tail recursion template"
  (cond ((zerop n) (first x))
        (t (my-nth (- n 1) (rest x)))))

Func: MY-NTH
End-test: (ZEROP N)
End-value: (FIRST X)
Reduced-n: (- N 1)
Reduced-x: (REST X)

CL-USER> (my-nth 2 '(a b c d e))
----Enter MY-NTH
|     Arg-1 = 2
|     Arg-2 = (A B C D E)
|   ----Enter MY-NTH
|   |     Arg-1 = 1
|   |     Arg-2 = (B C D E)
|   |   ----Enter MY-NTH
|   |   |     Arg-1 = 0
|   |   |     Arg-2 = (C D E)
|   |    \--MY-NTH returned C
|    \--MY-NTH returned C
 \--MY-NTH returned C
C

*NOTE*
(NTH 0 x) = (FIRST x)
The value of (NTH 0 x) is equal to (FIRST x),
  (FIRST x) is the end-value to trigger the end-test.

With each recursive call we reduce n by one and take successive RESTs of the list x.
The resulting function demonstrates single-test tail recursion with simultaneous recursion on two variables.
The DTRACEd output above shows how the N and X variables are evaluated simultaneously.


--
EXERCISES
--
8.28 The expressions (MY-NTH 5 '(A B C)) and (MY-NTH 1000 '(A B C)) both run off the end of the list.
  Modify MY-NTH to MY-NTH-MOD so that recursion stops as soon as the function runs off the list.

(defun my-nth-mod (n x)
  "MY-NTH, modified to stop before running off the list."
  (cond ((null x) nil)    ; Test stops the function from running off the list.
        ((zerop n) (first x))
        (t (my-nth-mod (- n 1) (rest x)))))

CL-USER> (my-nth-mod 5 '(a b c))
----Enter MY-NTH-MOD
|     Arg-1 = 5
|     Arg-2 = (A B C)
|   ----Enter MY-NTH-MOD
|   |     Arg-1 = 4
|   |     Arg-2 = (B C)
|   |   ----Enter MY-NTH-MOD
|   |   |     Arg-1 = 3
|   |   |     Arg-2 = (C)
|   |   |   ----Enter MY-NTH-MOD
|   |   |   |     Arg-1 = 2
|   |   |   |     Arg-2 = NIL
|   |   |    \--MY-NTH-MOD returned NIL
|   |    \--MY-NTH-MOD returned NIL
|    \--MY-NTH-MOD returned NIL
 \--MY-NTH-MOD returned NIL
NIL
CL-USER> (my-nth-mod 1000 '(a b c))
----Enter MY-NTH-MOD
|     Arg-1 = 1000
|     Arg-2 = (A B C)
|   ----Enter MY-NTH-MOD
|   |     Arg-1 = 999
|   |     Arg-2 = (B C)
|   |   ----Enter MY-NTH-MOD
|   |   |     Arg-1 = 998
|   |   |     Arg-2 = (C)
|   |   |   ----Enter MY-NTH-MOD
|   |   |   |     Arg-1 = 997
|   |   |   |     Arg-2 = NIL
|   |   |    \--MY-NTH-MOD returned NIL
|   |    \--MY-NTH-MOD returned NIL
|    \--MY-NTH-MOD returned NIL
 \--MY-NTH-MOD returned NIL
NIL

Placing an additional end-test and end-value
  stops the function from recursing past the length of the input list.


8.29 Write MY-MEMBER, a recursive version of MEMBER.
  This function takes two inputs, but only one of them will be reduced for each recursive call.

CL-USER> (describe 'member)
COMMON-LISP:MEMBER
  [symbol]

MEMBER names a compiled function:
  Lambda-list: (SB-IMPL::ITEM LIST &KEY SB-IMPL::KEY
                (SB-IMPL::TEST NIL SB-IMPL::TESTP)
                (SB-IMPL::TEST-NOT NIL SB-IMPL::NOTP))
  Dynamic-extent arguments: keyword=(:KEY :TEST :TEST-NOT)
  Declared type: (FUNCTION
                  (T LIST &KEY (:TEST (OR FUNCTION SYMBOL))
                   (:TEST-NOT (OR FUNCTION SYMBOL))
                   (:KEY (OR FUNCTION SYMBOL)))
                  (VALUES LIST &OPTIONAL))
  Derived type: (FUNCTION (T T &KEY (:KEY T) (:TEST T) (:TEST-NOT T))
                 (VALUES LIST &OPTIONAL))
  Documentation:
    Return the tail of LIST beginning with first element satisfying EQLity,
       :TEST, or :TEST-NOT with the given ITEM.
  Known attributes: call, foldable, flushable, unsafely-flushable
  Source file: SYS:SRC;CODE;LIST.LISP
; No value

CL-USER> (setf vowels '(a e i o u))
(A E I O U)
CL-USER> (member 'i vowels)
(I O U)

(defun my-member (e x)
  "MEMBER, double-test tail recursion simultaneously on two variables."
  (cond ((null x) nil)
        ((equal e (first x)) x)
        (t (my-member e (rest x)))))

CL-USER> (my-member 'i vowels)
----Enter MY-MEMBER
|     Arg-1 = I
|     Arg-2 = (A E I O U)
|   ----Enter MY-MEMBER
|   |     Arg-1 = I
|   |     Arg-2 = (E I O U)
|   |   ----Enter MY-MEMBER
|   |   |     Arg-1 = I
|   |   |     Arg-2 = (I O U)
|   |    \--MY-MEMBER returned (I O U)
|    \--MY-MEMBER returned (I O U)
 \--MY-MEMBER returned (I O U)
(I O U)
CL-USER> (my-member 'u vowels)
----Enter MY-MEMBER
|     Arg-1 = U
|     Arg-2 = (A E I O U)
|   ----Enter MY-MEMBER
|   |     Arg-1 = U
|   |     Arg-2 = (E I O U)
|   |   ----Enter MY-MEMBER
|   |   |     Arg-1 = U
|   |   |     Arg-2 = (I O U)
|   |   |   ----Enter MY-MEMBER
|   |   |   |     Arg-1 = U
|   |   |   |     Arg-2 = (O U)
|   |   |   |   ----Enter MY-MEMBER
|   |   |   |   |     Arg-1 = U
|   |   |   |   |     Arg-2 = (U)
|   |   |   |    \--MY-MEMBER returned (U)
|   |   |    \--MY-MEMBER returned (U)
|   |    \--MY-MEMBER returned (U)
|    \--MY-MEMBER returned (U)
 \--MY-MEMBER returned (U)
(U)
CL-USER> (my-member 'z vowels)
----Enter MY-MEMBER
|     Arg-1 = Z
|     Arg-2 = (A E I O U)
|   ----Enter MY-MEMBER
|   |     Arg-1 = Z
|   |     Arg-2 = (E I O U)
|   |   ----Enter MY-MEMBER
|   |   |     Arg-1 = Z
|   |   |     Arg-2 = (I O U)
|   |   |   ----Enter MY-MEMBER
|   |   |   |     Arg-1 = Z
|   |   |   |     Arg-2 = (O U)
|   |   |   |   ----Enter MY-MEMBER
|   |   |   |   |     Arg-1 = Z
|   |   |   |   |     Arg-2 = (U)
|   |   |   |   |   ----Enter MY-MEMBER
|   |   |   |   |   |     Arg-1 = Z
|   |   |   |   |   |     Arg-2 = NIL
|   |   |   |   |    \--MY-MEMBER returned NIL
|   |   |   |    \--MY-MEMBER returned NIL
|   |   |    \--MY-MEMBER returned NIL
|   |    \--MY-MEMBER returned NIL
|    \--MY-MEMBER returned NIL
 \--MY-MEMBER returned NIL
NIL

Func: MY-MEMBER
End-test-1: (NULL X)
End-value-1: NIL
End-test-2: (EQUAL E (FIRST X))
End-value-2: X
Reduced-x: (REST X)

There is no reduced-e.
Take Z in the last example.
The first variable is constant and passed down each recursive call
  testing for EQUALity.

End-test-1 and end-value-1 are testing when the list reaches NIL,
  exhausting the input list elements from recursion.

The end-test-2 end-value-2 clause checks whether
  the input element matches the first element of the (X) input list.

The first (E) input is never changed.
The second (X) input is reduced.

The reduced-x function is REST, taking away the first element
  and giving the rest of that as input to each recursive call.

With the Z example, the rest of the list is given ..
  the first of that list is taken ..
    until NIL is reached ..

Triggering end-test-1, satisfying end-value-1, returning NIL.


8.30 Write MY-ASSOC, a recursive version of ASSOC.

ASSOC parses an ALIST looking for the car equal to the input ITEM.
The cons of the ITEM entry satisfying ASSOC is returned.

CL-USER> (setf words
               '((one un)
                 (two deux)
                 (three trois)
                 (four quatre)
                 (five cinq)))
((ONE UN) (TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
CL-USER> (assoc 'four words)
(FOUR QUATRE)

CL-USER> (describe 'assoc)
COMMON-LISP:ASSOC
  [symbol]

ASSOC names a compiled function:
  Lambda-list: (SB-IMPL::ITEM SB-IMPL::ALIST &KEY SB-IMPL::KEY
                (SB-IMPL::TEST NIL SB-IMPL::TESTP)
                (SB-IMPL::TEST-NOT NIL SB-IMPL::NOTP))
  Dynamic-extent arguments: keyword=(:KEY :TEST :TEST-NOT)
  Declared type: (FUNCTION
                  (T LIST &KEY (:KEY (OR FUNCTION SYMBOL))
                   (:TEST (OR FUNCTION SYMBOL))
                   (:TEST-NOT (OR FUNCTION SYMBOL)))
                  (VALUES LIST &OPTIONAL))
  Derived type: (FUNCTION (T T &KEY (:KEY T) (:TEST T) (:TEST-NOT T))
                 (VALUES LIST &OPTIONAL))
  Documentation:
    Return the cons in ALIST whose car is equal (by a given test or EQL) to
       the ITEM.
  Known attributes: call, foldable, flushable, unsafely-flushable
  Source file: SYS:SRC;CODE;LIST.LISP
; No value

(defun my-assoc (key table)
  "ASSOC using double-test tail recursion on one variable with two inputs."
  (cond ((null table) nil)
        ((equal key (car (first table)))
         (first table))
        (t (my-assoc key (rest table)))))

CL-USER> (my-assoc 'four words)
----Enter MY-ASSOC
|     Arg-1 = FOUR
|     Arg-2 = ((ONE UN) (TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
|   ----Enter MY-ASSOC
|   |     Arg-1 = FOUR
|   |     Arg-2 = ((TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
|   |   ----Enter MY-ASSOC
|   |   |     Arg-1 = FOUR
|   |   |     Arg-2 = ((THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
|   |   |   ----Enter MY-ASSOC
|   |   |   |     Arg-1 = FOUR
|   |   |   |     Arg-2 = ((FOUR QUATRE) (FIVE CINQ))
|   |   |    \--MY-ASSOC returned (FOUR QUATRE)
|   |    \--MY-ASSOC returned (FOUR QUATRE)
|    \--MY-ASSOC returned (FOUR QUATRE)
 \--MY-ASSOC returned (FOUR QUATRE)
(FOUR QUATRE)

Func: MY-ASSOC
End-test-1: (null table)
End-value-1: nil
End-test-2: (equal key (car (first table)
End-value-2: (first table)
reduced-table: (rest table)

End-test-1 and end-value-1 verify the table isn't empty.

(FIRST TABLE) is taking the first entry (top level element) from the ALIST (TABLE).
  For example (FOUR QUATRE)

A top level element like (FOUR QUATRE) is handed to CAR, taking the first element of the ALIST entry FOUR.

EQUAL tests the input KEY (FOUR) with the result evaluated by CAR (FOUR).
  That tests true and the entry is returned to top level, just as the primitive function ASSOC would.


8.31 We want to tell whether one list is shorter than another as quickly as possible.
  We should not have to determine the total LENGTHs of each input during evaluation.
  Write recursive function COMPARE-LENGTHS, taking two lists as input and returns symbols:
    SAME-LENGTH FIRST-IS-LONGER SECOND-IS-LONGER
  This function uses triple-test simultaneous recursion.
    *HINT* If x is shorter than y and both lists are non-empty,
      then (REST x) is shorter than (REST y).

(defun compare-lengths (x y)
  "Test whether an input is shorter than the other using triple-test simultaneous recursion,"
  (cond ((and (null x) (null y)) 'same-length)
        ((null x) 'second-is-longer)
        ((null y) 'first-is-longer)
        (t (compare-lengths (rest x)
                            (rest y)))))

CL-USER> (setf a '(1 2 3 4))
(1 2 3 4)
CL-USER> (setf b '(1 2 3 4 5))
(1 2 3 4 5)
CL-USER> (compare-lengths a b)
----Enter COMPARE-LENGTHS
|     Arg-1 = (1 2 3 4)
|     Arg-2 = (1 2 3 4 5)
|   ----Enter COMPARE-LENGTHS
|   |     Arg-1 = (2 3 4)
|   |     Arg-2 = (2 3 4 5)
|   |   ----Enter COMPARE-LENGTHS
|   |   |     Arg-1 = (3 4)
|   |   |     Arg-2 = (3 4 5)
|   |   |   ----Enter COMPARE-LENGTHS
|   |   |   |     Arg-1 = (4)
|   |   |   |     Arg-2 = (4 5)
|   |   |   |   ----Enter COMPARE-LENGTHS
|   |   |   |   |     Arg-1 = NIL
|   |   |   |   |     Arg-2 = (5)
|   |   |   |    \--COMPARE-LENGTHS returned SECOND-IS-LONGER
|   |   |    \--COMPARE-LENGTHS returned SECOND-IS-LONGER
|   |    \--COMPARE-LENGTHS returned SECOND-IS-LONGER
|    \--COMPARE-LENGTHS returned SECOND-IS-LONGER
 \--COMPARE-LENGTHS returned SECOND-IS-LONGER
SECOND-IS-LONGER

Func: COMPARE-LENGTHS
End-test-1: (AND (NULL x) (NULL y))
End-value-1: 'SAME-LENGTH
End-test-2: (NULL x)
End-value-2: 'SECOND-IS-LONGER
End-test-3: (NULL y)
End-value-3: 'FIRST-IS-LONGER
Reduced-x: (REST x)
Reduced-y: (REST y)

  *NOTE* AND finds the NILs and returns NIL,
           if AND does not find the NIL,
             it returns the last element.

AND adds the capability of the third test,
  each element of X and Y are simultaneously checked for NIL.
  NIL at the same time means SAME-LENGTH

End-test-2 and end-value-2 say,
  if X is at NIL first then Y is the longer list.

End-test-3 and end-value-3 say,
  if y is at nil first then X is the longer list.

X and Y are reduced simultaneously the same way with REST,
  the lists being reduced by one until one is exhausted of elements
  either satisfying an end-test or being equal in length down to NIL.



8.12.3 Conditional Augmentation

(DEFUN func (X)
  "Template for conditional augmentation type recursion."
  (COND (end-test end-value)
        (aug-test (aug-fun aug-val
                           (func reduced-x)))
        (T (func reduced-x))))


In some list processing problems we want to skip certain elements of the list
  and use only the remaining elements to build up the return value.

This sort of picking and choosing is known as conditional augmentation.

(defun extract-symbols (x)
  "Given a list, extracts the symbols, returns those as a list. Uses conditional augmentation."
  (cond ((null x) nil)
        ((symbolp (first x))
         (cons (first x)
               (extract-symbols (rest x))))
        (t (extract-symbols (rest x)))))

Func: EXTRACT-SYMBOLS
End-test: (NULL X)
End-value: NIL
Aug-test: (SYMBOLP (FIRST X))
Aug-fun: CONS
Aug-val: (FIRST X)
Reduced-x: (REST X)

CL-USER> (extract-symbols '(3 bears and 1 girl))
----Enter EXTRACT-SYMBOLS
|     Arg-1 = (3 BEARS AND 1 GIRL)
|   ----Enter EXTRACT-SYMBOLS
|   |     Arg-1 = (BEARS AND 1 GIRL)
|   |   ----Enter EXTRACT-SYMBOLS
|   |   |     Arg-1 = (AND 1 GIRL)
|   |   |   ----Enter EXTRACT-SYMBOLS
|   |   |   |     Arg-1 = (1 GIRL)
|   |   |   |   ----Enter EXTRACT-SYMBOLS
|   |   |   |   |     Arg-1 = (GIRL)
|   |   |   |   |   ----Enter EXTRACT-SYMBOLS
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |    \--EXTRACT-SYMBOLS returned NIL
|   |   |   |    \--EXTRACT-SYMBOLS returned (GIRL)
|   |   |    \--EXTRACT-SYMBOLS returned (GIRL)
|   |    \--EXTRACT-SYMBOLS returned (AND GIRL)
|    \--EXTRACT-SYMBOLS returned (BEARS AND GIRL)
 \--EXTRACT-SYMBOLS returned (BEARS AND GIRL)
(BEARS AND GIRL)

The body of EXTRACT-SYMBOLS contains two recursive calls.

One call is nested within an augmentation expression,
  which in this case conses a new element onto the list.

The other call is unaugmented;
  instead its result simply returned.


Notice in the trace output that sometimes two successive calls return the same value.

The list (GIRL) is returned by EXTRACT-SYMBOLS twice in series.
The list (BEARS AND GIRL) is returned twice in series as well.

The reason for this is because one of each pair of calls chose the unaugmented COND clause.

When the augmented clause was chosen, the result got longer,
  as when we went from NIL to (GIRL),
    from there to (AND GIRL),
      and from there to (BEARS AND GIRL).

Breakdown EXTRACT-SYMBOLS:

The end-test end-value clause tests whether the input list is empty,
  if the list is empty we return NIL.

The augmentation test (SYMBOLP (FIRST X)) takes the first element of the recursed input list
  and tests whether it is a symbol.

If the element is a symbol, the augmentation function conses that symbol to the result list.

The reduced-x is a REST function that coordinates with augmenting function FIRST nicely.


--
EXERCISES
--
8.32 Write the function SUM-NUMERIC-ELEMENTS, which adds up all the numbers in a list and ignores the non-numbers.

(defun sum-numeric-elements (x)
  "Adds up the numbers extracted from a list. Ignores non-numbers."
  (cond ((null x) 0)
        ((numberp (first x))
         (+ (first x)
            (sum-numeric-elements (rest x))))
        (t (sum-numeric-elements (rest x)))))

CL-USER> (sum-numeric-elements '(3 bears 3 bowls and 1 girls))
----Enter SUM-NUMERIC-ELEMENTS
|     Arg-1 = (3 BEARS 3 BOWLS AND 1 GIRLS)
|   ----Enter SUM-NUMERIC-ELEMENTS
|   |     Arg-1 = (BEARS 3 BOWLS AND 1 GIRLS)
|   |   ----Enter SUM-NUMERIC-ELEMENTS
|   |   |     Arg-1 = (3 BOWLS AND 1 GIRLS)
|   |   |   ----Enter SUM-NUMERIC-ELEMENTS
|   |   |   |     Arg-1 = (BOWLS AND 1 GIRLS)
|   |   |   |   ----Enter SUM-NUMERIC-ELEMENTS
|   |   |   |   |     Arg-1 = (AND 1 GIRLS)
|   |   |   |   |   ----Enter SUM-NUMERIC-ELEMENTS
|   |   |   |   |   |     Arg-1 = (1 GIRLS)
|   |   |   |   |   |   ----Enter SUM-NUMERIC-ELEMENTS
|   |   |   |   |   |   |     Arg-1 = (GIRLS)
|   |   |   |   |   |   |   ----Enter SUM-NUMERIC-ELEMENTS
|   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |    \--SUM-NUMERIC-ELEMENTS returned 0
|   |   |   |   |   |    \--SUM-NUMERIC-ELEMENTS returned 0
|   |   |   |   |    \--SUM-NUMERIC-ELEMENTS returned 1
|   |   |   |    \--SUM-NUMERIC-ELEMENTS returned 1
|   |   |    \--SUM-NUMERIC-ELEMENTS returned 1
|   |    \--SUM-NUMERIC-ELEMENTS returned 4
|    \--SUM-NUMERIC-ELEMENTS returned 4
 \--SUM-NUMERIC-ELEMENTS returned 7
7

Func: SUM-NUMERIC-ELEMENTS
End-test: (NULL X)
End-value: 0
Aug-test: (NUMBERP (FIRST X))
Aug-fun: +
Aug-val: (FIRST X)
Reduced-x: (REST X)


The end-test end-value combination tests whether the input list is empty,
  if the list is empty return NIL.

The augmentation test checks whether the first element of the input list is a number.

If T for the aug-test the aug-fun + adds the number to the others, or not.

REST is the reduced-x function working with FIRST,
  the list is reduced by one element for each recursive call.


8.33 Write MY-REMOVE, a recursive version of the REMOVE function.




8.34 Write MY-INTERSECTION, a recursive version of the INTERSECTION function.

First understand what intersection is,

CL-USER> (describe 'intersection)
COMMON-LISP:INTERSECTION
  [symbol]

INTERSECTION names a compiled function:
  Lambda-list: (SB-IMPL::LIST1 SB-IMPL::LIST2 &KEY SB-IMPL::KEY
                (SB-IMPL::TEST NIL SB-IMPL::TESTP)
                (SB-IMPL::TEST-NOT NIL SB-IMPL::NOTP))
  Dynamic-extent arguments: keyword=(:KEY :TEST :TEST-NOT)
  Declared type: (FUNCTION
                  (LIST LIST &KEY (:KEY (OR FUNCTION SYMBOL))
                        (:TEST (OR FUNCTION SYMBOL))
                        (:TEST-NOT (OR FUNCTION SYMBOL)))
                  (VALUES LIST &OPTIONAL))
  Derived type: (FUNCTION (T T &KEY (:KEY T) (:TEST T) (:TEST-NOT T))
                 (VALUES LIST &OPTIONAL))
  Documentation:
    Return the intersection of LIST1 and LIST2.
  Inline proclamation: MAYBE-INLINE (inline expansion available)
  Known attributes: call, foldable, flushable, unsafely-flushable
  Source file: SYS:SRC;CODE;LIST.LISP
; No value
CL-USER> (intersection '(A B C) '(a b c))
(C B A)
CL-USER> (intersection '("A" "B" "C") '("a" "b" "c"))
NIL
CL-USER> (intersection '(1 2 3 4) '(5 2 7 8))
(2)

At the basic level INTERSECTION returns a list of the common elements between LIST1 and LIST2.

We need a function that returns the common element and the rest of the list as well.
  From there we can extract the common element with FIRST,
    then use CONS to add it to the list of recursed results.

A function that can accomplish this is MEMBER.

CL-USER> (member 2 '(1 2 3 4))
(2 3 4)

MEMBER takes the common input element,
  then returns that element including the rest of the input list

(defun my-intersection (x y)
  (cond ((null x) nil)
        ((member (first x) y)
         (cons (first x)
               (my-intersection (rest x) y)))
        (t (my-intersection (rest x) y))))

CL-USER> (my-intersection '(1 2 3 4) '(5 2 6 7))
----Enter MY-INTERSECTION
|     Arg-1 = (1 2 3 4)
|     Arg-2 = (5 2 6 7)
|   ----Enter MY-INTERSECTION
|   |     Arg-1 = (2 3 4)
|   |     Arg-2 = (5 2 6 7)
|   |   ----Enter MY-INTERSECTION
|   |   |     Arg-1 = (3 4)
|   |   |     Arg-2 = (5 2 6 7)
|   |   |   ----Enter MY-INTERSECTION
|   |   |   |     Arg-1 = (4)
|   |   |   |     Arg-2 = (5 2 6 7)
|   |   |   |   ----Enter MY-INTERSECTION
|   |   |   |   |     Arg-1 = NIL
|   |   |   |   |     Arg-2 = (5 2 6 7)
|   |   |   |    \--MY-INTERSECTION returned NIL
|   |   |    \--MY-INTERSECTION returned NIL
|   |    \--MY-INTERSECTION returned NIL
|    \--MY-INTERSECTION returned (2)
 \--MY-INTERSECTION returned (2)
(2)

Func: MY-INTERSECTION
End-test: (NULL X)
End-value: NIL
Aug-test: (MEMBER (FIRST X) Y))
Aug-fun: CONS
Aug-val: (FIRST X)
Reduced-x: (REST X)

The end-test end-value clause test for an empty input,
  NIL is returned if so.

The test to initiate augmentation uses MEMBER,
  checking the first element of list X with list Y.
  This test continues through recursion with the reduced-x.

The reduced-x in this function reduces only the variable list X not Y.


8.35 Write MY-SET-DIFFERENCE, a recursive version of the SET-DIFFERENCE function.

First we find out what is SET-DIFFERENCE,

CL-USER> (describe 'set-difference)
COMMON-LISP:SET-DIFFERENCE
  [symbol]

SET-DIFFERENCE names a compiled function:
  Lambda-list: (SB-IMPL::LIST1 SB-IMPL::LIST2 &KEY SB-IMPL::KEY
                (SB-IMPL::TEST NIL SB-IMPL::TESTP)
                (SB-IMPL::TEST-NOT NIL SB-IMPL::NOTP))
  Dynamic-extent arguments: keyword=(:KEY :TEST :TEST-NOT)
  Declared type: (FUNCTION
                  (LIST LIST &KEY (:KEY (OR FUNCTION SYMBOL))
                        (:TEST (OR FUNCTION SYMBOL))
                        (:TEST-NOT (OR FUNCTION SYMBOL)))
                  (VALUES LIST &OPTIONAL))
  Derived type: (FUNCTION (T T &KEY (:KEY T) (:TEST T) (:TEST-NOT T))
                 (VALUES T &OPTIONAL))
  Documentation:
    Return the elements of LIST1 which are not in LIST2.
  Inline proclamation: MAYBE-INLINE (inline expansion available)
  Known attributes: call, foldable, flushable, unsafely-flushable
  Source file: SYS:SRC;CODE;LIST.LISP
; No value

SET-DIFFERENCE takes LIST1 and LIST2, then returns everything from LIST1 that isn't in LIST2.

(defun my-set-difference (x y)
  "SET-DIFFERENCE using conditional augmentation type recursion."
  (cond ((null x) nil)
        ((not (member (first x) y))
         (cons (first x)
               (my-set-difference (rest x) y)))
        (t (my-set-difference (rest x) y))))

CL-USER> (my-set-difference '(a a b b c c) '(a a v v c c))
----Enter MY-SET-DIFFERENCE
|     Arg-1 = (A A B B C C)
|     Arg-2 = (A A V V C C)
|   ----Enter MY-SET-DIFFERENCE
|   |     Arg-1 = (A B B C C)
|   |     Arg-2 = (A A V V C C)
|   |   ----Enter MY-SET-DIFFERENCE
|   |   |     Arg-1 = (B B C C)
|   |   |     Arg-2 = (A A V V C C)
|   |   |   ----Enter MY-SET-DIFFERENCE
|   |   |   |     Arg-1 = (B C C)
|   |   |   |     Arg-2 = (A A V V C C)
|   |   |   |   ----Enter MY-SET-DIFFERENCE
|   |   |   |   |     Arg-1 = (C C)
|   |   |   |   |     Arg-2 = (A A V V C C)
|   |   |   |   |   ----Enter MY-SET-DIFFERENCE
|   |   |   |   |   |     Arg-1 = (C)
|   |   |   |   |   |     Arg-2 = (A A V V C C)
|   |   |   |   |   |   ----Enter MY-SET-DIFFERENCE
|   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |     Arg-2 = (A A V V C C)
|   |   |   |   |   |    \--MY-SET-DIFFERENCE returned NIL
|   |   |   |   |    \--MY-SET-DIFFERENCE returned NIL
|   |   |   |    \--MY-SET-DIFFERENCE returned NIL
|   |   |    \--MY-SET-DIFFERENCE returned (B)
|   |    \--MY-SET-DIFFERENCE returned (B B)
|    \--MY-SET-DIFFERENCE returned (B B)
 \--MY-SET-DIFFERENCE returned (B B)
(B B)

It is just NOT MY-INTERSECTION.

Func: MY-SET-DIFFERENCE
End-test: (NULL X)
End-value: NIL
Aug-test: (NOT (MEMBER (FIRST X) Y)))
Aug-fun: CONS
Aug-val: (FIRST X)
Reduced-x: (REST X)

The typical end-test end-value combination tests for the empty list,
  NIL is returned if so.

The test for whether the function is recursed through augmentation
  checks if there is not any occurrence of the first element of X in Y.
If (FIRST X) does not show in Y, then it is consed to the recursed results.

The reduced-x uses REST to reduce list X,
  the list is reduced by one with each recursive input because FIRST takes the first element.


8.36 The function COUNT-ODD counts the number of odd elements in a list of numbers
  then returns that number. Write a version of COUNT-ODD using conditional augmentation.
  Write another version of COUNT-ODD using regular augmenting recursion.

(defun count-odd-cond-aug (x)
  "Counts how many odd numbers there are in the list with conditional augmentation."
  (cond ((null x) 0)
        ((oddp (first x))
         (+ 1 (count-odd-cond-aug (rest x))))
        (t (count-odd-cond-aug (rest x)))))

CL-USER> (count-odd-cond-aug '(1 2 3 4 5))
----Enter COUNT-ODD-COND-AUG
|     Arg-1 = (1 2 3 4 5)
|   ----Enter COUNT-ODD-COND-AUG
|   |     Arg-1 = (2 3 4 5)
|   |   ----Enter COUNT-ODD-COND-AUG
|   |   |     Arg-1 = (3 4 5)
|   |   |   ----Enter COUNT-ODD-COND-AUG
|   |   |   |     Arg-1 = (4 5)
|   |   |   |   ----Enter COUNT-ODD-COND-AUG
|   |   |   |   |     Arg-1 = (5)
|   |   |   |   |   ----Enter COUNT-ODD-COND-AUG
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |    \--COUNT-ODD-COND-AUG returned 0
|   |   |   |    \--COUNT-ODD-COND-AUG returned 1
|   |   |    \--COUNT-ODD-COND-AUG returned 1
|   |    \--COUNT-ODD-COND-AUG returned 2
|    \--COUNT-ODD-COND-AUG returned 2
 \--COUNT-ODD-COND-AUG returned 3
3

(defun count-odd-reg-aug (x)
  "Counts the number of odd numbers in the list using augmenting recursion."
  (cond ((null x) 0)
        (t (+ (if (oddp (first x))
                  1
                  0)
              (count-odd-reg-aug (rest x))))))

CL-USER> (count-odd-reg-aug '(1 2 3 4 5))
----Enter COUNT-ODD-REG-AUG
|     Arg-1 = (1 2 3 4 5)
|   ----Enter COUNT-ODD-REG-AUG
|   |     Arg-1 = (2 3 4 5)
|   |   ----Enter COUNT-ODD-REG-AUG
|   |   |     Arg-1 = (3 4 5)
|   |   |   ----Enter COUNT-ODD-REG-AUG
|   |   |   |     Arg-1 = (4 5)
|   |   |   |   ----Enter COUNT-ODD-REG-AUG
|   |   |   |   |     Arg-1 = (5)
|   |   |   |   |   ----Enter COUNT-ODD-REG-AUG
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |    \--COUNT-ODD-REG-AUG returned 0
|   |   |   |    \--COUNT-ODD-REG-AUG returned 1
|   |   |    \--COUNT-ODD-REG-AUG returned 1
|   |    \--COUNT-ODD-REG-AUG returned 2
|    \--COUNT-ODD-REG-AUG returned 2
 \--COUNT-ODD-REG-AUG returned 3
3

IF is a simple conditional expression:
 (IF condition true-part false-part)

So if the first element of X is odd, we add one.
  If it is not odd then we add zero.



8.12.4 Multiple Recursion

(DEFUN func (N)
  (COND (end-test-1 end-value-1)
        (end-test-2 end-value-2)
        (T (combiner (func first-reduced-n)
                     (func second-reduced-n)))))

A function is multiple recursive if it makes more than one recursive call with each invocation.

This is not the same as simultaneous recursion.
Simultaneous recursion reduces several variables simultaneously.
It does not involve multiple recursive calls with each invocation.
The keyword here is "several" variables.

Our multiple recursion template uses one variable N.

The Fibonacci function is a classic example of multiple recursion.

Fib(N) calls its self twice,
  once for Fib(N-1) and again for Fib(N-2).
The results of the two calls are combined using +.

(defun fib (n)
  "Fibonacci function, is multiple recursive."
  (cond ((equal n 0) 1)
        ((equal n 1) 1)
        (t (+ (fib (- n 1))
              (fib (- n 2))))))

CL-USER> (fib 5)
----Enter FIB
|     Arg-1 = 5
|   ----Enter FIB
|   |     Arg-1 = 4
|   |   ----Enter FIB
|   |   |     Arg-1 = 3
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 2
|   |   |   |   ----Enter FIB
|   |   |   |   |     Arg-1 = 1
|   |   |   |    \--FIB returned 1
|   |   |   |   ----Enter FIB
|   |   |   |   |     Arg-1 = 0
|   |   |   |    \--FIB returned 1
|   |   |    \--FIB returned 2
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 1
|   |   |    \--FIB returned 1
|   |    \--FIB returned 3
|   |   ----Enter FIB
|   |   |     Arg-1 = 2
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 1
|   |   |    \--FIB returned 1
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 0
|   |   |    \--FIB returned 1
|   |    \--FIB returned 2
|    \--FIB returned 5
|   ----Enter FIB
|   |     Arg-1 = 3
|   |   ----Enter FIB
|   |   |     Arg-1 = 2
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 1
|   |   |    \--FIB returned 1
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 0
|   |   |    \--FIB returned 1
|   |    \--FIB returned 2
|   |   ----Enter FIB
|   |   |     Arg-1 = 1
|   |    \--FIB returned 1
|    \--FIB returned 3
 \--FIB returned 8
8

Func: FIB
End-test-1: (EQUAL N 0)
End-value-1: 1
End-test-2: (EQUAL N 1)
End-test-2: 1
Combiner: +
First-reduced-n: (- N 1)
Second-reduced-n: (- N 2)

Notice that there is a second-reduced-n.
  Multiple recursion reduces one variable in FIB.
    This is an example of how is function is recursed multiple times,
      not simultaneously.

A good way to visualize multiple recursion
  is to look at shape of the nested calls in the trace output.


Let's define a terminal call as a call that does not recurse any further.

In all previous functions, successive calls were nested strictly one inside the other,
  and the innermost call was the only terminal call.
Then, the return values flowed in a straight line from the innermost call back to the outermost.

CL-USER> (fib 3)
----Enter FIB
|     Arg-1 = 3
|   ----Enter FIB
|   |     Arg-1 = 2
|NT1|   ----Enter FIB
|   |   |T1   Arg-1 = 1
|   |NT2 \--FIB returned 1
|   |   ----Enter FIB
|   |   |T2   Arg-1 = 0
|   |    \--FIB returned 1
|    \--FIB returned 2
|   ----Enter FIB
|   |T3   Arg-1 = 1
|    \--FIB returned 1
 \--FIB returned 3
3

But with a multiple recursive function such as FIB,
  each call produces *two* new calls.
  The two are nested within the parent call,
    but they cannot nest inside another.
  Instead they appear side-by-side within the parent.
Multiple recursive functions therefore have many terminal calls.

In (FIB 3) there are three terminal calls and two nonterminal calls.
  These can be traced directly, and are numbered and labeled terminal(T) and nonterminal(NT) above.

The terminal calls are nested within the nonterminal calls.
  Two within NT2.
  One within NT1.


--
EXERCISE
--
8.37 Define a simple function COMBINE that takes two numbers as input and returns their sum.
  Now replace the occurrence of + in FIB with COMBINE.
  Trace FIB and COMBINE and try evaluating (FIB 3) and (FIB 4).
  Explain the relationship between COMBINE, terminal calls, and nonterminal calls.

(defun combine (x y)
  "The user defined + function. For tracing and testing."
  (+ x y))

(defun fib (n)
  "The Fibonacci function, using the user defined COMBINE."
  (cond ((equal n 0) 1)
        ((equal n 1) 1)
        (t (combine (fib (- n 1))
                    (fib (- n 2))))))

CL-USER> (fib 3)
----Enter FIB
|     Arg-1 = 3
|   ----Enter FIB
|   |     Arg-1 = 2
|   |   ----Enter FIB
|   |   |     Arg-1 = 1
|   |    \--FIB returned 1
|   |   ----Enter FIB
|   |   |     Arg-1 = 0
|   |    \--FIB returned 1
|   |   ----Enter COMBINE
|   |   |     Arg-1 = 1
|   |   |     Arg-2 = 1
|   |    \--COMBINE returned 2
|    \--FIB returned 2
|   ----Enter FIB
|   |     Arg-1 = 1
|    \--FIB returned 1
|   ----Enter COMBINE
|   |     Arg-1 = 2
|   |     Arg-2 = 1
|    \--COMBINE returned 3
 \--FIB returned 3
3

CL-USER> (fib 4)
----Enter FIB
|     Arg-1 = 4
|   ----Enter FIB
|   |     Arg-1 = 3
|   |   ----Enter FIB
|   |   |     Arg-1 = 2
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 1
|   |   |    \--FIB returned 1
|   |   |   ----Enter FIB
|   |   |   |     Arg-1 = 0
|   |   |    \--FIB returned 1
|   |   |   ----Enter COMBINE
|   |   |   |     Arg-1 = 1
|   |   |   |     Arg-2 = 1
|   |   |    \--COMBINE returned 2
|   |    \--FIB returned 2
|   |   ----Enter FIB
|   |   |     Arg-1 = 1
|   |    \--FIB returned 1
|   |   ----Enter COMBINE
|   |   |     Arg-1 = 2
|   |   |     Arg-2 = 1
|   |    \--COMBINE returned 3
|    \--FIB returned 3
|   ----Enter FIB
|   |     Arg-1 = 2
|   |   ----Enter FIB
|   |   |     Arg-1 = 1
|   |    \--FIB returned 1
|   |   ----Enter FIB
|   |   |     Arg-1 = 0
|   |    \--FIB returned 1
|   |   ----Enter COMBINE
|   |   |     Arg-1 = 1
|   |   |     Arg-2 = 1
|   |    \--COMBINE returned 2
|    \--FIB returned 2
|   ----Enter COMBINE
|   |     Arg-1 = 3
|   |     Arg-2 = 2
|    \--COMBINE returned 5
 \--FIB returned 5
5

The relationship between COMBINE, terminal calls, and nonterminal calls:

COMBINE is nested within the nonterminal calls.
  The traces can be followed, compare with the output of (FIB 3) defined with +.

CL-USER> (fib 3)
----Enter FIB
|     Arg-1 = 3
|   ----Enter FIB
|   |     Arg-1 = 2
|NT1|   ----Enter FIB
|   |   |T1   Arg-1 = 1
|   |NT2 \--FIB returned 1
|   |   ----Enter FIB
|   |   |T2   Arg-1 = 0
|   |    \--FIB returned 1
|    \--FIB returned 2
|   ----Enter FIB
|   |T3   Arg-1 = 1
|    \--FIB returned 1
 \--FIB returned 3
3

CL-USER> (fib 3)
----Enter FIB
|     Arg-1 = 3
|   ----Enter FIB
|   |     Arg-1 = 2
|NT1|   ----Enter FIB
|   |   |T1   Arg-1 = 1
|   |NT2 \--FIB returned 1
|   |   ----Enter FIB
|   |   |T2   Arg-1 = 0
|   |    \--FIB returned 1
|   |   ----Enter COMBINE
|   |   |NT1  Arg-1 = 1
|   |   |     Arg-2 = 1
|   |    \--COMBINE returned 2
|    \--FIB returned 2
|   ----Enter FIB
|   |T3   Arg-1 = 1
|    \--FIB returned 1
|   ----Enter COMBINE
|   |NT2  Arg-1 = 2
|   |     Arg-2 = 1
|    \--COMBINE returned 3
 \--FIB returned 3
3

Every nonterminal call to FIB makes one call to COMBINE.
Every call to COMBINE combines the results of two more calls to FIB.

Since terminal calls to FIB always return one,
  we can prove that the total number of calls to COMBINE is equal to Fib(N)-1.

The proof is based on the realization that
  every binary tree with k terminal nodes has exactly k-1 nonterminal nodes:
    There are 3 FIB terminal nodes.
    There are 2 nonterminal COMBINE nodes.



---
8.13 TREES AND CAR/CDR RECURSION
---

(DEFUN func (X)
  "Template for CAR/CDR recursion."
  (COND (end-test-1 end-value-1)
        (end-test-2 end-value-2)
        (T (combiner (func (CAR X))
                     (func (CDR X))))))

Sometimes we want to process all the elements of a nested list,
  not just the top-level elements.

If the list is irregularly shaped:

(((GOLDILOCKS . AND)) (THE . 3) BEARS)

Organizing a method to process all of the elements may seem difficult.


When we write our function, we won't know how long or how deeply nested it inputs will be.

S> '(((goldilocks . and)) (the . 3) bears)

[*|*]--------->[*|*]------->[*|*]--->NIL
 |              |            |
 v              v            v
[*|*]--->NIL   [*|*]--->3   BEARS
 |              |
 v              v
[*|*]--->AND   THE
 |
 v
GOLDILOCKS

Result:  (((GOLDILOCKS . AND)) (THE . 3) BEARS)

The trick to solving this problem is not to think of the input as an irregularly shaped nested list,
  but rather as a binary tree:

                          [*|*]
                          /   \
                         /     \
                        /       \
                       /         \
                      /           \
                     /             \
                    /               \
                   /                 \
                  /                   \
                [*|*]                [*|*]
                /   \                /   \
               /    NIL             /     \
              /                    /       \
             /                    /         \
           [*|*]               [*|*]       [*|*]
           /   \               /   \       /   \
          /     \             /     \     /     \
     GOLDILOCKS AND         THE      3  BEARS   NIL

Binary trees are very regular:
  Each node is either an atom or a cons with two branches, the car and the cdr.

Therefore all our function would have to do is process the atoms,
  and call itself recursively on the car and cdr of each cons.

This technique is called CAR/CDR recursion;
  it is a special case of multiple recursion.

(DEFUN func (X)
  "Template for CAR/CDR recursion."
  (COND (end-test-1 end-value-1)
        (end-test-2 end-value-2)
        (T (combiner (func (CAR X))
                     (func (CDR X))))))

(defun atoms-to-q (x)
  "Translates all atoms in a tree to the symbol Q."
  (cond ((null x) nil)
        ((atom x) 'q)
        (t (cons (atoms-to-q (car x))
                 (atoms-to-q (cdr x))))))

S> (atoms-to-q '(hark (harold the angel) sings))

[*|*]--->[*|*]--------------------------->[*|*]--->NIL
 |        |                                |
 v        v                                v
 Q       [*|*]--->[*|*]--->[*|*]--->NIL    Q
          |        |        |
          v        v        v
          Q        Q        Q

Result:  (Q (Q Q Q) Q)

S> (atoms-to-q '(a (a . b) c (c . d) e (e . f)))

[*|*]--->[*|*]------->[*|*]--->[*|*]------->[*|*]--->[*|*]--->NIL
 |        |            |        |            |        |
 v        v            v        v            v        v
 Q       [*|*]--->Q    Q       [*|*]--->Q    Q       [*|*]--->Q
          |                     |                     |
          v                     v                     v
          Q                     Q                     Q

Result:  (Q (Q . Q) Q (Q . Q) Q (Q . Q))


Write the function FIND-NUMBER to search a tree and return the first number that appears in it,
  NIL otherwise.

We should use NUMBERP and ATOM as our end tests and OR as the combiner.

Func: FIND-NUMBER
End-test-1: (NUMBERP X)
End-value-1: X
End-test-2: (ATOM X)
End-value-2: NIL
Combiner: OR

(defun find-number (x)
  "Searches the tree returning the first number in it. NIL otherwise."
  (cond ((numberp x) x)
        ((atom x) nil)
        (t (or (find-number (car x))
               (find-number (cdr x))))))

CL-USER> (find-number '((a . b) a b c 3 v b (a . b)))
----Enter FIND-NUMBER
|     Arg-1 = ((A . B) A B C 3 V B ...)
|   ----Enter FIND-NUMBER
|   |     Arg-1 = (A . B)
|   |   ----Enter FIND-NUMBER
|   |   |     Arg-1 = A
|   |    \--FIND-NUMBER returned NIL
|   |   ----Enter FIND-NUMBER
|   |   |     Arg-1 = B
|   |    \--FIND-NUMBER returned NIL
|    \--FIND-NUMBER returned NIL
|   ----Enter FIND-NUMBER
|   |     Arg-1 = (A B C 3 V B (A . B))
|   |   ----Enter FIND-NUMBER
|   |   |     Arg-1 = A
|   |    \--FIND-NUMBER returned NIL
|   |   ----Enter FIND-NUMBER
|   |   |     Arg-1 = (B C 3 V B (A . B))
|   |   |   ----Enter FIND-NUMBER
|   |   |   |     Arg-1 = B
|   |   |    \--FIND-NUMBER returned NIL
|   |   |   ----Enter FIND-NUMBER
|   |   |   |     Arg-1 = (C 3 V B (A . B))
|   |   |   |   ----Enter FIND-NUMBER
|   |   |   |   |     Arg-1 = C
|   |   |   |    \--FIND-NUMBER returned NIL
|   |   |   |   ----Enter FIND-NUMBER
|   |   |   |   |     Arg-1 = (3 V B (A . B))
|   |   |   |   |   ----Enter FIND-NUMBER
|   |   |   |   |   |     Arg-1 = 3
|   |   |   |   |    \--FIND-NUMBER returned 3
|   |   |   |    \--FIND-NUMBER returned 3
|   |   |    \--FIND-NUMBER returned 3
|   |    \--FIND-NUMBER returned 3
|    \--FIND-NUMBER returned 3
 \--FIND-NUMBER returned 3
3

OR parses the car or the cdr of X until it finds the number.

These irregularly shaped list doesn't stop OR from finding the number,
  CAR and CDR direct OR two different directions.

In the case of FIND-NUMBER the whole list doesn't need to be searched.
 The recursion stops once the combiner OR finds that number and hands it to end-test-1.

Refer to the binary tree.


--
EXERCISES
--
8.38 What would be the effect of deleting the first COND clause in ATOMS-TO-Q?

(defun atoms-to-q (x)
  "Translates all atoms in a tree to the symbol Q."
  (cond ((null x) nil)
        ((atom x) 'q)
        (t (cons (atoms-to-q (car x))
                 (atoms-to-q (cdr x))))))

S> (atoms-to-q '(hark (harold the angel) sings))

[*|*]--->[*|*]--------------------------->[*|*]--->NIL
 |        |                                |
 v        v                                v
 Q       [*|*]--->[*|*]--->[*|*]--->NIL    Q
          |        |        |
          v        v        v
          Q        Q        Q

Result:  (Q (Q Q Q) Q)

If the first COND clause ((NULL X) NIL) is omitted from the function definition,
  the NILs at the ends of cons cell chains in the tree will be translated to Qs.

(defun atoms-to-q (x)
  "Translates all atoms in a tree to the symbol Q."
  (cond ((atom x) 'q)
        (t (cons (atoms-to-q (car x))
                 (atoms-to-q (cdr x))))))
S> (atoms-to-q '(hark (harold the angel) sings))

[*|*]--->[*|*]------------------------->[*|*]--->Q
 |        |                              |
 v        v                              v
 Q       [*|*]--->[*|*]--->[*|*]--->Q    Q
          |        |        |
          v        v        v
          Q        Q        Q

Result:  (Q (Q Q Q . Q) Q . Q)


TLDR; The NILs turn to Qs

With clause -
Result:  (Q (Q Q Q) Q)
Without clause -
Result:  (Q (Q Q Q . Q) Q . Q)


8.39 Write a function COUNT-ATOMS that returns the number of atoms in a tree.
  *Note*: The NILs should be counted as atoms.

(defun count-atoms (tree)
  "Counts the number of atoms in the tree, returns the total. Uses CAR/CDR recursion."
  (cond ((atom tree) 1)
        (t (+ (count-atoms (car tree))
              (count-atoms (cdr tree))))))

CL-USER> (count-atoms '(a (b) c))
----Enter COUNT-ATOMS
|     Arg-1 = (A (B) C)
|   ----Enter COUNT-ATOMS
|   |     Arg-1 = A
|    \--COUNT-ATOMS returned 1
|   ----Enter COUNT-ATOMS
|   |     Arg-1 = ((B) C)
|   |   ----Enter COUNT-ATOMS
|   |   |     Arg-1 = (B)
|   |   |   ----Enter COUNT-ATOMS
|   |   |   |     Arg-1 = B
|   |   |    \--COUNT-ATOMS returned 1
|   |   |   ----Enter COUNT-ATOMS
|   |   |   |     Arg-1 = NIL
|   |   |    \--COUNT-ATOMS returned 1
|   |    \--COUNT-ATOMS returned 2
|   |   ----Enter COUNT-ATOMS
|   |   |     Arg-1 = (C)
|   |   |   ----Enter COUNT-ATOMS
|   |   |   |     Arg-1 = C
|   |   |    \--COUNT-ATOMS returned 1
|   |   |   ----Enter COUNT-ATOMS
|   |   |   |     Arg-1 = NIL
|   |   |    \--COUNT-ATOMS returned 1
|   |    \--COUNT-ATOMS returned 2
|    \--COUNT-ATOMS returned 4
 \--COUNT-ATOMS returned 5
5

Look at what happens in the trace output once the nested (B) hits.
  Multiple recursion is what's happening there, that is the split in the tree.

The multiple recursion clearly splits and picks back up.
  Once a result is returned following the evaluation of the nested (B) by the split COUNT-ATOMS,
    the 'original' COUNT-ATOMS takes that return value and combines it with its evaluations.


8.40 Write COUNT-CONS, a function that returns the number of cons cells in a tree.

(defun count-cons (tree)
  "Counts the number of cons cells in the tree, returns the total."
  (cond ((atom tree) 0)
        (t (+ 1
              (count-cons (car tree))
              (count-cons (cdr tree))))))

CL-USER> (count-cons '(foo))
----Enter COUNT-CONS
|     Arg-1 = (FOO)
|   ----Enter COUNT-CONS
|   |     Arg-1 = FOO
|    \--COUNT-CONS returned 0
|   ----Enter COUNT-CONS
|   |     Arg-1 = NIL
|    \--COUNT-CONS returned 0
 \--COUNT-CONS returned 1
1
CL-USER> (count-cons '(foo bar))
----Enter COUNT-CONS
|     Arg-1 = (FOO BAR)
|   ----Enter COUNT-CONS
|   |     Arg-1 = FOO
|    \--COUNT-CONS returned 0
|   ----Enter COUNT-CONS
|   |     Arg-1 = (BAR)
|   |   ----Enter COUNT-CONS
|   |   |     Arg-1 = BAR
|   |    \--COUNT-CONS returned 0
|   |   ----Enter COUNT-CONS
|   |   |     Arg-1 = NIL
|   |    \--COUNT-CONS returned 0
|    \--COUNT-CONS returned 1
 \--COUNT-CONS returned 2
2
CL-USER> (count-cons '((foo)))
----Enter COUNT-CONS
|     Arg-1 = ((FOO))
|   ----Enter COUNT-CONS
|   |     Arg-1 = (FOO)
|   |   ----Enter COUNT-CONS
|   |   |     Arg-1 = FOO
|   |    \--COUNT-CONS returned 0
|   |   ----Enter COUNT-CONS
|   |   |     Arg-1 = NIL
|   |    \--COUNT-CONS returned 0
|    \--COUNT-CONS returned 1
|   ----Enter COUNT-CONS
|   |     Arg-1 = NIL
|    \--COUNT-CONS returned 0
 \--COUNT-CONS returned 2
2
CL-USER> (count-cons 'fred)
----Enter COUNT-CONS
|     Arg-1 = FRED
 \--COUNT-CONS returned 0
0


8.41 Write function SUM-TREE that returns the sum of all the numbers appearing in a tree.
  Non-numbers should be ignored.

(defun sum-tree (tree)
  "Finds the numbers in the TREE, adds them up and returns that value."
  (cond ((numberp tree) tree)
        ((atom tree) 0)
        (t (+ (sum-tree (car tree))
              (sum-tree (cdr tree))))))

CL-USER> (sum-tree '((3 bears) (3 bowls) (1 girl)))
----Enter SUM-TREE
|     Arg-1 = ((3 BEARS) (3 BOWLS) (1 GIRL))
|   ----Enter SUM-TREE
|   |     Arg-1 = (3 BEARS)
|   |   ----Enter SUM-TREE
|   |   |     Arg-1 = 3
|   |    \--SUM-TREE returned 3
|   |   ----Enter SUM-TREE
|   |   |     Arg-1 = (BEARS)
|   |   |   ----Enter SUM-TREE
|   |   |   |     Arg-1 = BEARS
|   |   |    \--SUM-TREE returned 0
|   |   |   ----Enter SUM-TREE
|   |   |   |     Arg-1 = NIL
|   |   |    \--SUM-TREE returned 0
|   |    \--SUM-TREE returned 0
|    \--SUM-TREE returned 3
|   ----Enter SUM-TREE
|   |     Arg-1 = ((3 BOWLS) (1 GIRL))
|   |   ----Enter SUM-TREE
|   |   |     Arg-1 = (3 BOWLS)
|   |   |   ----Enter SUM-TREE
|   |   |   |     Arg-1 = 3
|   |   |    \--SUM-TREE returned 3
|   |   |   ----Enter SUM-TREE
|   |   |   |     Arg-1 = (BOWLS)
|   |   |   |   ----Enter SUM-TREE
|   |   |   |   |     Arg-1 = BOWLS
|   |   |   |    \--SUM-TREE returned 0
|   |   |   |   ----Enter SUM-TREE
|   |   |   |   |     Arg-1 = NIL
|   |   |   |    \--SUM-TREE returned 0
|   |   |    \--SUM-TREE returned 0
|   |    \--SUM-TREE returned 3
|   |   ----Enter SUM-TREE
|   |   |     Arg-1 = ((1 GIRL))
|   |   |   ----Enter SUM-TREE
|   |   |   |     Arg-1 = (1 GIRL)
|   |   |   |   ----Enter SUM-TREE
|   |   |   |   |     Arg-1 = 1
|   |   |   |    \--SUM-TREE returned 1
|   |   |   |   ----Enter SUM-TREE
|   |   |   |   |     Arg-1 = (GIRL)
|   |   |   |   |   ----Enter SUM-TREE
|   |   |   |   |   |     Arg-1 = GIRL
|   |   |   |   |    \--SUM-TREE returned 0
|   |   |   |   |   ----Enter SUM-TREE
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |    \--SUM-TREE returned 0
|   |   |   |    \--SUM-TREE returned 0
|   |   |    \--SUM-TREE returned 1
|   |   |   ----Enter SUM-TREE
|   |   |   |     Arg-1 = NIL
|   |   |    \--SUM-TREE returned 0
|   |    \--SUM-TREE returned 1
|    \--SUM-TREE returned 4
 \--SUM-TREE returned 7
7

*Note* - SUM-TREE checks the empty list last (a non-terminal node),
  resulting in a 0 value before working back up.


8.42 Write MY-SUBST, a recursive version of the SUBST funciton.

Remind us of what SUBST is ...

CL-USER> (describe 'subst)
COMMON-LISP:SUBST
  [symbol]

SUBST names a compiled function:
  Lambda-list: (SB-IMPL::NEW SB-IMPL::OLD SB-IMPL::TREE &KEY
                SB-IMPL::KEY (SB-IMPL::TEST #'EQL SB-IMPL::TESTP)
                (SB-IMPL::TEST-NOT #'EQL SB-IMPL::NOTP))
  Dynamic-extent arguments: keyword=(:KEY :TEST :TEST-NOT)
  Declared type: (FUNCTION
                  (T T T &KEY (:TEST (OR FUNCTION SYMBOL))
                   (:TEST-NOT (OR FUNCTION SYMBOL))
                   (:KEY (OR FUNCTION SYMBOL)))
                  (VALUES T &OPTIONAL))
  Derived type: (FUNCTION
                 (T T T &KEY (:KEY #1=(OR FUNCTION SYMBOL)) (:TEST #1#)
                  (:TEST-NOT #1#))
                 (VALUES T &OPTIONAL))
  Documentation:
    Substitutes new for subtrees matching old.
  Inline proclamation: MAYBE-INLINE (inline expansion available)
  Known attributes: call, flushable, unsafely-flushable
  Source file: SYS:SRC;CODE;LIST.LISP
; No value

SUBST substitutes the new-element (first input) for old-element (second input) into the tree (third input).

(defun my-subst (new old tree)
  "Substitutes NEW for OLD in the TREE."
  (cond ((equal tree old) new)
        ((atom tree) tree)
        (t (cons (my-subst
                  new old (car tree))
                 (my-subst
                  new old (cdr tree))))))

CL-USER> (my-subst 'a 'b '((a b) (b a)))
----Enter MY-SUBST
|     Arg-1 = A
|     Arg-2 = B
|     Arg-3 = ((A B) (B A))
|   ----Enter MY-SUBST
|   |     Arg-1 = A
|   |     Arg-2 = B
|   |     Arg-3 = (A B)
|   |   ----Enter MY-SUBST
|   |   |     Arg-1 = A
|   |   |     Arg-2 = B
|   |   |     Arg-3 = A
|   |    \--MY-SUBST returned A
|   |   ----Enter MY-SUBST
|   |   |     Arg-1 = A
|   |   |     Arg-2 = B
|   |   |     Arg-3 = (B)
|   |   |   ----Enter MY-SUBST
|   |   |   |     Arg-1 = A
|   |   |   |     Arg-2 = B
|   |   |   |     Arg-3 = B
|   |   |    \--MY-SUBST returned A
|   |   |   ----Enter MY-SUBST
|   |   |   |     Arg-1 = A
|   |   |   |     Arg-2 = B
|   |   |   |     Arg-3 = NIL
|   |   |    \--MY-SUBST returned NIL
|   |    \--MY-SUBST returned (A)
|    \--MY-SUBST returned (A A)
|   ----Enter MY-SUBST
|   |     Arg-1 = A
|   |     Arg-2 = B
|   |     Arg-3 = ((B A))
|   |   ----Enter MY-SUBST
|   |   |     Arg-1 = A
|   |   |     Arg-2 = B
|   |   |     Arg-3 = (B A)
|   |   |   ----Enter MY-SUBST
|   |   |   |     Arg-1 = A
|   |   |   |     Arg-2 = B
|   |   |   |     Arg-3 = B
|   |   |    \--MY-SUBST returned A
|   |   |   ----Enter MY-SUBST
|   |   |   |     Arg-1 = A
|   |   |   |     Arg-2 = B
|   |   |   |     Arg-3 = (A)
|   |   |   |   ----Enter MY-SUBST
|   |   |   |   |     Arg-1 = A
|   |   |   |   |     Arg-2 = B
|   |   |   |   |     Arg-3 = A
|   |   |   |    \--MY-SUBST returned A
|   |   |   |   ----Enter MY-SUBST
|   |   |   |   |     Arg-1 = A
|   |   |   |   |     Arg-2 = B
|   |   |   |   |     Arg-3 = NIL
|   |   |   |    \--MY-SUBST returned NIL
|   |   |    \--MY-SUBST returned (A)
|   |    \--MY-SUBST returned (A A)
|   |   ----Enter MY-SUBST
|   |   |     Arg-1 = A
|   |   |     Arg-2 = B
|   |   |     Arg-3 = NIL
|   |    \--MY-SUBST returned NIL
|    \--MY-SUBST returned ((A A))
 \--MY-SUBST returned ((A A) (A A))
((A A) (A A))

DTRACE is the shit.


8.43 Write FLATTEN, a function that returns all elements in the list in a single, top-level list.

(defun flatten (x)
  "Returns all elements from input into a single top-level list."
  (cond ((atom x) (list x))
        (t (append (flatten (car x))
                   (and (cdr x) (flatten (cdr x)))))))

CL-USER> (flatten '((a (b) c)))
----Enter FLATTEN
|     Arg-1 = ((A (B) C))
|   ----Enter FLATTEN
|   |     Arg-1 = (A (B) C)
|   |   ----Enter FLATTEN
|   |   |     Arg-1 = A
|   |    \--FLATTEN returned (A)
|   |   ----Enter FLATTEN
|   |   |     Arg-1 = ((B) C)
|   |   |   ----Enter FLATTEN
|   |   |   |     Arg-1 = (B)
|   |   |   |   ----Enter FLATTEN
|   |   |   |   |     Arg-1 = B
|   |   |   |    \--FLATTEN returned (B)
|   |   |    \--FLATTEN returned (B)
|   |   |   ----Enter FLATTEN
|   |   |   |     Arg-1 = (C)
|   |   |   |   ----Enter FLATTEN
|   |   |   |   |     Arg-1 = C
|   |   |   |    \--FLATTEN returned (C)
|   |   |    \--FLATTEN returned (C)
|   |    \--FLATTEN returned (B C)
|    \--FLATTEN returned (A B C)
 \--FLATTEN returned (A B C)
(A B C)

and the same trace but with user created primitives:

CL-USER> (flatten '((a (b) c)))
----Enter FLATTEN
|     Arg-1 = ((A (B) C))
|   ----Enter MY-ATOM
|   |     Arg-1 = ((A (B) C))
|    \--MY-ATOM returned NIL
|   ----Enter FLATTEN
|   |     Arg-1 = (A (B) C)
|   |   ----Enter MY-ATOM
|   |   |     Arg-1 = (A (B) C)
|   |    \--MY-ATOM returned NIL
|   |   ----Enter FLATTEN
|   |   |     Arg-1 = A
|   |   |   ----Enter MY-ATOM
|   |   |   |     Arg-1 = A
|   |   |    \--MY-ATOM returned T
|   |   |   ----Enter MY-LIST
|   |   |   |     Arg-1 = A
|   |   |    \--MY-LIST returned (A)
|   |    \--FLATTEN returned (A)
|   |   ----Enter FLATTEN
|   |   |     Arg-1 = ((B) C)
|   |   |   ----Enter MY-ATOM
|   |   |   |     Arg-1 = ((B) C)
|   |   |    \--MY-ATOM returned NIL
|   |   |   ----Enter FLATTEN
|   |   |   |     Arg-1 = (B)
|   |   |   |   ----Enter MY-ATOM
|   |   |   |   |     Arg-1 = (B)
|   |   |   |    \--MY-ATOM returned NIL
|   |   |   |   ----Enter FLATTEN
|   |   |   |   |     Arg-1 = B
|   |   |   |   |   ----Enter MY-ATOM
|   |   |   |   |   |     Arg-1 = B
|   |   |   |   |    \--MY-ATOM returned T
|   |   |   |   |   ----Enter MY-LIST
|   |   |   |   |   |     Arg-1 = B
|   |   |   |   |    \--MY-LIST returned (B)
|   |   |   |    \--FLATTEN returned (B)
|   |   |    \--FLATTEN returned (B)
|   |   |   ----Enter FLATTEN
|   |   |   |     Arg-1 = (C)
|   |   |   |   ----Enter MY-ATOM
|   |   |   |   |     Arg-1 = (C)
|   |   |   |    \--MY-ATOM returned NIL
|   |   |   |   ----Enter FLATTEN
|   |   |   |   |     Arg-1 = C
|   |   |   |   |   ----Enter MY-ATOM
|   |   |   |   |   |     Arg-1 = C
|   |   |   |   |    \--MY-ATOM returned T
|   |   |   |   |   ----Enter MY-LIST
|   |   |   |   |   |     Arg-1 = C
|   |   |   |   |    \--MY-LIST returned (C)
|   |   |   |    \--FLATTEN returned (C)
|   |   |    \--FLATTEN returned (C)
|   |    \--FLATTEN returned (B C)
|    \--FLATTEN returned (A B C)
 \--FLATTEN returned (A B C)
(A B C)

Look at the end when the recursed values are being combined to the final return value.

When the function splits to its cdr side, and removes the NILs.


8.44 Write function TREE-DEPTH that returns the maximum depth of a binary tree.

(defun tree-depth (tree)
  "Returns the maximum depth of a binary tree."
  (cond ((atom tree) 0)
        (t (+ 1 (max (tree-depth (car tree))
                     (tree-depth (cdr tree)))))))

CL-USER> (tree-depth '(a . b))
----Enter TREE-DEPTH
|     Arg-1 = (A . B)
|   ----Enter TREE-DEPTH
|   |     Arg-1 = A
|    \--TREE-DEPTH returned 0
|   ----Enter TREE-DEPTH
|   |     Arg-1 = B
|    \--TREE-DEPTH returned 0
 \--TREE-DEPTH returned 1
1
CL-USER> (tree-depth '((a . b) . (c . d)))
----Enter TREE-DEPTH
|     Arg-1 = ((A . B) C . D)
|   ----Enter TREE-DEPTH
|   |     Arg-1 = (A . B)
|   |   ----Enter TREE-DEPTH
|   |   |     Arg-1 = A
|   |    \--TREE-DEPTH returned 0
|   |   ----Enter TREE-DEPTH
|   |   |     Arg-1 = B
|   |    \--TREE-DEPTH returned 0
|    \--TREE-DEPTH returned 1
|   ----Enter TREE-DEPTH
|   |     Arg-1 = (C . D)
|   |   ----Enter TREE-DEPTH
|   |   |     Arg-1 = C
|   |    \--TREE-DEPTH returned 0
|   |   ----Enter TREE-DEPTH
|   |   |     Arg-1 = D
|   |    \--TREE-DEPTH returned 0
|    \--TREE-DEPTH returned 1
 \--TREE-DEPTH returned 2
2


8.45 Write function PAREN-DEPTH that returns the maximum depth of nested parenthesis in a list.
  *Hint* This problem can be solved by CAR/CDR recursion, but the CAR/CDR cases won;t be symmetric.
    This basically means it uses FIRST and REST instead of CAR and CDR.

(defun paren-depth (list)
  "Returns the maximum depth of nested parenthesis in a list."
  (cond ((atom list) 0)
        (t (max (+ 1 (paren-depth (first list)))
                (paren-depth (rest list))))))

CL-USER> (paren-depth '(a b c))
----Enter PAREN-DEPTH
|     Arg-1 = (A B C)
|   ----Enter PAREN-DEPTH
|   |     Arg-1 = A
|    \--PAREN-DEPTH returned 0
|   ----Enter PAREN-DEPTH
|   |     Arg-1 = (B C)
|   |   ----Enter PAREN-DEPTH
|   |   |     Arg-1 = B
|   |    \--PAREN-DEPTH returned 0
|   |   ----Enter PAREN-DEPTH
|   |   |     Arg-1 = (C)
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = C
|   |   |    \--PAREN-DEPTH returned 0
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = NIL
|   |   |    \--PAREN-DEPTH returned 0
|   |    \--PAREN-DEPTH returned 1
|    \--PAREN-DEPTH returned 1
 \--PAREN-DEPTH returned 1
1
CL-USER> (paren-depth '(a b ((c) d) e))
----Enter PAREN-DEPTH
|     Arg-1 = (A B ((C) D) E)
|   ----Enter PAREN-DEPTH
|   |     Arg-1 = A
|    \--PAREN-DEPTH returned 0
|   ----Enter PAREN-DEPTH
|   |     Arg-1 = (B ((C) D) E)
|   |   ----Enter PAREN-DEPTH
|   |   |     Arg-1 = B
|   |    \--PAREN-DEPTH returned 0
|   |   ----Enter PAREN-DEPTH
|   |   |     Arg-1 = (((C) D) E)
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = ((C) D)
|   |   |   |   ----Enter PAREN-DEPTH
|   |   |   |   |     Arg-1 = (C)
|   |   |   |   |   ----Enter PAREN-DEPTH
|   |   |   |   |   |     Arg-1 = C
|   |   |   |   |    \--PAREN-DEPTH returned 0
|   |   |   |   |   ----Enter PAREN-DEPTH
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |    \--PAREN-DEPTH returned 0
|   |   |   |    \--PAREN-DEPTH returned 1
|   |   |   |   ----Enter PAREN-DEPTH
|   |   |   |   |     Arg-1 = (D)
|   |   |   |   |   ----Enter PAREN-DEPTH
|   |   |   |   |   |     Arg-1 = D
|   |   |   |   |    \--PAREN-DEPTH returned 0
|   |   |   |   |   ----Enter PAREN-DEPTH
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |    \--PAREN-DEPTH returned 0
|   |   |   |    \--PAREN-DEPTH returned 1
|   |   |    \--PAREN-DEPTH returned 2
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = (E)
|   |   |   |   ----Enter PAREN-DEPTH
|   |   |   |   |     Arg-1 = E
|   |   |   |    \--PAREN-DEPTH returned 0
|   |   |   |   ----Enter PAREN-DEPTH
|   |   |   |   |     Arg-1 = NIL
|   |   |   |    \--PAREN-DEPTH returned 0
|   |   |    \--PAREN-DEPTH returned 1
|   |    \--PAREN-DEPTH returned 3
|    \--PAREN-DEPTH returned 3
 \--PAREN-DEPTH returned 3
3

FIRST and REST are used for symmetry.

The difference between PAREN-DEPTH and TREE-DEPTH is where MAX and + 1 are swapped in the combiner.

CL-USER> (tree-depth '(a b c))
----Enter TREE-DEPTH
|     Arg-1 = (A B C)
|   ----Enter TREE-DEPTH
|   |     Arg-1 = A
|    \--TREE-DEPTH returned 0
|   ----Enter TREE-DEPTH
|   |     Arg-1 = (B C)
|   |   ----Enter TREE-DEPTH
|   |   |     Arg-1 = B
|   |    \--TREE-DEPTH returned 0
|   |   ----Enter TREE-DEPTH
|   |   |     Arg-1 = (C)
|   |   |   ----Enter TREE-DEPTH
|   |   |   |     Arg-1 = C
|   |   |    \--TREE-DEPTH returned 0
|   |   |   ----Enter TREE-DEPTH
|   |   |   |     Arg-1 = NIL
|   |   |    \--TREE-DEPTH returned 0
|   |    \--TREE-DEPTH returned 1
|    \--TREE-DEPTH returned 2
 \--TREE-DEPTH returned 3
3
CL-USER> (paren-depth '(a b c))
----Enter PAREN-DEPTH
|     Arg-1 = (A B C)
|   ----Enter PAREN-DEPTH
|   |     Arg-1 = A
|    \--PAREN-DEPTH returned 0
|   ----Enter PAREN-DEPTH
|   |     Arg-1 = (B C)
|   |   ----Enter PAREN-DEPTH
|   |   |     Arg-1 = B
|   |    \--PAREN-DEPTH returned 0
|   |   ----Enter PAREN-DEPTH
|   |   |     Arg-1 = (C)
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = C
|   |   |    \--PAREN-DEPTH returned 0
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = NIL
|   |   |    \--PAREN-DEPTH returned 0
|   |    \--PAREN-DEPTH returned 1
|    \--PAREN-DEPTH returned 1
 \--PAREN-DEPTH returned 1
1

During recursion, TREE-DEPTH adds one to the return value for every element.

PAREN-DEPTH only adds one to the return value for closing NILs back up to top level:

CL-USER> (paren-depth '(a (b) c))
----Enter PAREN-DEPTH
|     Arg-1 = (A (B) C)
|   ----Enter PAREN-DEPTH
|   |     Arg-1 = A
|    \--PAREN-DEPTH returned 0
|   ----Enter PAREN-DEPTH
|   |     Arg-1 = ((B) C)
|   |   ----Enter PAREN-DEPTH
|   |   |     Arg-1 = (B)
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = B
|   |   |    \--PAREN-DEPTH returned 0
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = NIL
|   |   |    \--PAREN-DEPTH returned 0
|   |    \--PAREN-DEPTH returned 1
|   |   ----Enter PAREN-DEPTH
|   |   |     Arg-1 = (C)
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = C
|   |   |    \--PAREN-DEPTH returned 0
|   |   |   ----Enter PAREN-DEPTH
|   |   |   |     Arg-1 = NIL
|   |   |    \--PAREN-DEPTH returned 0
|   |    \--PAREN-DEPTH returned 1
|    \--PAREN-DEPTH returned 2
 \--PAREN-DEPTH returned 2
2

One only return following those closing NILs confirmed.



---
8.14 USING HELPING FUNCTIONS
---

For some problems it is useful to structure the solution as a helping function plus a recursive function.

The recursive function does most of the work.
The helping function is the one that we call from top-level;
  it performs some special service either at the beginning or the end of the recursion.

Let's write a function COUNT-UP that counts from one up to n:

(count-up 5)  =>  (1 2 3 4 5)
(count-up 0)  =>  nil

The inner-most recursive call is the one that must terminate the recusrion
  when the input reaches five, not zero.

So then we must need to know how to stop the function during this recursion.

The easiest way is to supply the original value of N to the recursive function so it can decide when to stop.

We must also supply an extra argument;
  a counter that tells the function how far along it is in recursion.

The job of the helping function is to provide the initial value for the counter:

CL-USER> (count-up 3)
----Enter COUNT-UP
|     Arg-1 = 3
|   ----Enter COUNT-UP-RECURSIVELY
|   |     Arg-1 = 1
|   |     Arg-2 = 3
|   |   ----Enter COUNT-UP-RECURSIVELY
|   |   |     Arg-1 = 2
|   |   |     Arg-2 = 3
|   |   |   ----Enter COUNT-UP-RECURSIVELY
|   |   |   |     Arg-1 = 3
|   |   |   |     Arg-2 = 3
|   |   |   |   ----Enter COUNT-UP-RECURSIVELY
|   |   |   |   |    Arg-1 = 4
|   |   |   |   |     Arg-2 = 3
|   |   |   |    \--COUNT-UP-RECURSIVELY returned NIL
|   |   |    \--COUNT-UP-RECURSIVELY returned (3)
|   |    \--COUNT-UP-RECURSIVELY returned (2 3)
|    \--COUNT-UP-RECURSIVELY returned (1 2 3)
 \--COUNT-UP returned (1 2 3)
(1 2 3)

Where Arg-1 hits 4,
  that's greater than the input number.

COUNT-UP-RECURSIVELY returns NIL.

The end-test-1 (> CNT N) in COUNT-UP-RECURSIVELY
  tells the function to stop recursively counting once CNT is greater than N.


--
EXERCISES
--
8.46 Another way to solve this problem of counting upward
  is to add an element to the end of the list with each recursive call
    instead of adding elements to the beginnning.
  This approach doesn't require a helpong function.
  Write COUNT-UP this way.

(defun count-up-no-help (n)
  "Counts up to N and lists it. Does not require the helper function."
  (cond ((zerop n) nil)
        (t (append (count-up (- n 1))
                   (list n)))))

CL-USER> (count-up-no-help 3)
----Enter COUNT-UP-NO-HELP
|     Arg-1 = 3
|   ----Enter COUNT-UP-NO-HELP
|   |     Arg-1 = 2
|   |   ----Enter COUNT-UP-NO-HELP
|   |   |     Arg-1 = 1
|   |   |   ----Enter COUNT-UP-NO-HELP
|   |   |   |     Arg-1 = 0
|   |   |    \--COUNT-UP-NO-HELP returned NIL
|   |    \--COUNT-UP-NO-HELP returned (1)
|    \--COUNT-UP-NO-HELP returned (1 2)
 \--COUNT-UP-NO-HELP returned (1 2 3)
(1 2 3)

COUNT-UP-NO-HELP does its counting by 1 2 3 . . 7

COUNT-UP does its counting from the input number 7 6 5 . . 1

CL-USER> (count-up 3)
----Enter COUNT-UP
|     Arg-1 = 3
|   ----Enter COUNT-UP-RECURSIVELY
|   |     Arg-1 = 1
|   |     Arg-2 = 3
|   |   ----Enter COUNT-UP-RECURSIVELY
|   |   |     Arg-1 = 2
|   |   |     Arg-2 = 3
|   |   |   ----Enter COUNT-UP-RECURSIVELY
|   |   |   |     Arg-1 = 3
|   |   |   |     Arg-2 = 3
|   |   |   |   ----Enter COUNT-UP-RECURSIVELY
|   |   |   |   |     Arg-1 = 4
|   |   |   |   |     Arg-2 = 3
|   |   |   |    \--COUNT-UP-RECURSIVELY returned NIL
|   |   |    \--COUNT-UP-RECURSIVELY returned (3)
|   |    \--COUNT-UP-RECURSIVELY returned (2 3)
|    \--COUNT-UP-RECURSIVELY returned (1 2 3)
 \--COUNT-UP returned (1 2 3)
(1 2 3)

COUNT-UP-NO-HELP uses end-test-1 and end-value-1 ((zerop n) nil) to halt recursion at zero.


8.47 Write MAKE-LOAF, a function that returns a loaf of size N.

(IF condition true-part false-part)

(defun make-loaf (n)
  "Give it a number, returns a loaf of that many."
  (if (zerop n) nil
      (cons 'x (make-loaf (- n 1)))))

IF N is true for being equal to zero,
  close the list with NIL and return it.

    If N is not zero cons an X then recurse ...

IF N is true for being equal to ...
  ...

    (Recursion) Subtract on from N.
      Cons an X.

...
  ...


CL-USER> (make-loaf 4)
----Enter MAKE-LOAF
|     Arg-1 = 4
|   ----Enter MAKE-LOAF
|   |     Arg-1 = 3
|   |   ----Enter MAKE-LOAF
|   |   |     Arg-1 = 2
|   |   |   ----Enter MAKE-LOAF
|   |   |   |     Arg-1 = 1
|   |   |   |   ----Enter MAKE-LOAF
|   |   |   |   |     Arg-1 = 0
|   |   |   |    \--MAKE-LOAF returned NIL
|   |   |    \--MAKE-LOAF returned (X)
|   |    \--MAKE-LOAF returned (X X)
|    \--MAKE-LOAF returned (X X X)
 \--MAKE-LOAF returned (X X X X)
(X X X X)


8.48 Write recursive function BURY that buries an item under n levels of parenthesis.
  Which recursion template did you use?

(defun bury (x n)
  "Nests X N many times in parenthesis."
  (cond ((zerop n) x)
        (t (list (bury x (- n 1))))))

If the input is not a zero list and recurse that many times to zero.
  Once zero is reached list X.
    Go all the way back up with your results and return what you have.

CL-USER> (bury 'fred 5)
----Enter BURY
|     Arg-1 = FRED
|     Arg-2 = 5
|   ----Enter BURY
|   |     Arg-1 = FRED
|   |     Arg-2 = 4
|   |   ----Enter BURY
|   |   |     Arg-1 = FRED
|   |   |     Arg-2 = 3
|   |   |   ----Enter BURY
|   |   |   |     Arg-1 = FRED
|   |   |   |     Arg-2 = 2
|   |   |   |   ----Enter BURY
|   |   |   |   |     Arg-1 = FRED
|   |   |   |   |     Arg-2 = 1
|   |   |   |   |   ----Enter BURY
|   |   |   |   |   |     Arg-1 = FRED
|   |   |   |   |   |     Arg-2 = 0
|   |   |   |   |    \--BURY returned FRED
|   |   |   |    \--BURY returned (FRED)
|   |   |    \--BURY returned ((FRED))
|   |    \--BURY returned (((FRED)))
|    \--BURY returned ((((FRED))))
 \--BURY returned ((((#))))
(((((FRED)))))


8.49 Write PAIRINGS, a function that PAIRS the elements from two lists of equal length.

(defun pairings (x y)
  "Pairs coinciding elements from two lists of the same length."
  (cond ((null x) nil)
        (t (cons (list (first x) (first y))
                 (pairings (rest x)
                           (rest y))))))

*Note* Replacing FIRST and REST with CAR and CDR seems to be identical.

S> (pairings '(a b c) '(1 2 3))

[*|*]------------------>[*|*]------------------>[*|*]--->NIL
 |                       |                       |
 v                       v                       v
[*|*]--->[*|*]--->NIL   [*|*]--->[*|*]--->NIL   [*|*]--->[*|*]--->NIL
 |        |              |        |              |        |
 v        v              v        v              v        v
 A        1              B        2              C        3

Result:  ((A 1) (B 2) (C 3))

S> (pairings-testing '(a b c) '(1 2 3))

[*|*]------------------>[*|*]------------------>[*|*]--->NIL
 |                       |                       |
 v                       v                       v
[*|*]--->[*|*]--->NIL   [*|*]--->[*|*]--->NIL   [*|*]--->[*|*]--->NIL
 |        |              |        |              |        |
 v        v              v        v              v        v
 A        1              B        2              C        3

Result:  ((A 1) (B 2) (C 3))


8.50 Write SUBLISTS, a function that returns the successive sublists of a list.

(defun sublists (x)
  "Takes a list and returns successive sublists of the list elements."
  (cond ((null x) nil)
        (t (cons x (sublists (rest x))))))

CL-USER> (sublists '(1 2 3))
----Enter SUBLISTS
|     Arg-1 = (1 2 3)
|   ----Enter SUBLISTS
|   |     Arg-1 = (2 3)
|   |   ----Enter SUBLISTS
|   |   |     Arg-1 = (3)
|   |   |   ----Enter SUBLISTS
|   |   |   |     Arg-1 = NIL
|   |   |    \--SUBLISTS returned NIL
|   |    \--SUBLISTS returned ((3))
|    \--SUBLISTS returned ((2 . #1=(3)) #1#)
 \--SUBLISTS returned ((1 . #1=(2 . #2=(3))) #1# #2#)
((1 2 3) (2 3) (3))

S> (sublists '(1 2 3))

[*|*]--------------------------->[*|*]------------------>[*|*]--->NIL
 |                                |                       |
 v                                v                       v
[*|*]--->[*|*]--->[*|*]--->NIL   [*|*]--->[*|*]--->NIL   [*|*]--->NIL
 |        |        |              |        |              |
 v        v        v              v        v              v
 1        2        3              2        3              3

Result:  ((1 2 3) (2 3) (3))

Here tracing almost the whole thing with testing functions:

CL-USER> (sublists-testing '(1 2 3))
----Enter SUBLISTS-TESTING
|     Arg-1 = (1 2 3)
|   ----Enter MY-REST
|   |     Arg-1 = (1 2 3)
|    \--MY-REST returned (2 3)
|   ----Enter SUBLISTS
|   |     Arg-1 = (2 3)
|   |   ----Enter SUBLISTS
|   |   |     Arg-1 = (3)
|   |   |   ----Enter SUBLISTS
|   |   |   |     Arg-1 = NIL
|   |   |    \--SUBLISTS returned NIL
|   |    \--SUBLISTS returned ((3))
|    \--SUBLISTS returned ((2 . #1=(3)) #1#)
|   ----Enter MY-CONS
|   |     Arg-1 = (1 2 3)
|   |     Arg-2 = ((2 . #1=(3)) #1#)
|    \--MY-CONS returned ((1 . #1=(2 . #2=(3))) #1# #2#)
 \--SUBLISTS-TESTING returned ((1 . #1=(2 . #2=(3))) #1# #2#)
((1 2 3) (2 3) (3))


8.51 The simplest way to write MY-REVERSE (a recursive version of REVERSE)
  is with a helping function plus a recursive function of two inputs.
  Write this type version of MY-REVERSE.

(defun my-reverse (x)
  "Helper function for REVERSE-RECURSIVELY."
  (reverse-recursively x nil))

(defun reverse-recursively (x y)
  "Recursive version of REVERSE. Utilized by helper function MY-REVERSE."
  (cond ((null x) y)
        (t (reverse-recursively
            (rest x)
            (cons (first x) y)))))

CL-USER> (my-reverse '(d c b a))
----Enter MY-REVERSE
|     Arg-1 = (D C B A)
|   ----Enter REVERSE-RECURSIVELY
|   |     Arg-1 = (D C B A)
|   |     Arg-2 = NIL
|   |   ----Enter REVERSE-RECURSIVELY
|   |   |     Arg-1 = (C B A)
|   |   |     Arg-2 = (D)
|   |   |   ----Enter REVERSE-RECURSIVELY
|   |   |   |     Arg-1 = (B A)
|   |   |   |     Arg-2 = (C D)
|   |   |   |   ----Enter REVERSE-RECURSIVELY
|   |   |   |   |     Arg-1 = (A)
|   |   |   |   |     Arg-2 = (B C D)
|   |   |   |   |   ----Enter REVERSE-RECURSIVELY
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = (A B C D)
|   |   |   |   |    \--REVERSE-RECURSIVELY returned (A B C D)
|   |   |   |    \--REVERSE-RECURSIVELY returned (A B C D)
|   |   |    \--REVERSE-RECURSIVELY returned (A B C D)
|   |    \--REVERSE-RECURSIVELY returned (A B C D)
|    \--REVERSE-RECURSIVELY returned (A B C D)
 \--MY-REVERSE returned (A B C D)
(A B C D)

With each recursive call, REVERSE-RECURSIVELY builds its return value
  by taking the first list element from input and consing it to a new list.

This list is built from bottom-up by taking each element as they come
  and consing them in front of the previous one.

The return value will be the mirror of the input in this way.

*NOTE*
CL-USER> (describe 'reverse)

COMMON-LISP:REVERSE
  [symbol]

REVERSE names a compiled function:
  Lambda-list: (SEQUENCE)
  Declared type: (FUNCTION (SEQUENCE)
                  (VALUES
                   (OR (SIMPLE-ARRAY * (*)) CONS NULL
                       SB-KERNEL:EXTENDED-SEQUENCE)
                   &OPTIONAL))
  Derived type: (FUNCTION (T) *)
  Documentation:
    Return a new sequence containing the same elements but in reverse order.
  Known attributes: flushable, unsafely-flushable
  Source file: SYS:SRC;CODE;SEQ.LISP
; No value

What exactly is REVERSE?

What exactly is NREVERSE?

CL-USER> (describe 'nreverse)
COMMON-LISP:NREVERSE
  [symbol]

NREVERSE names a compiled function:
  Lambda-list: (SEQUENCE)
  Declared type: (FUNCTION (SEQUENCE) (VALUES SEQUENCE &OPTIONAL))
  Derived type: (FUNCTION (T) (VALUES SEQUENCE &OPTIONAL))
  Documentation:
    Return a sequence of the same elements in reverse order; the argument
       is destroyed.
  Known attributes: important-result
  Source file: SYS:SRC;CODE;SEQ.LISP
; No value


8.52 Write MY-UNION, a recursive version of UNION.

(defun my-union (x y)
  "Helper function for UNION-RECURSIVELY."
  (append x (union-recuraively x y)))

(defun union-recursively (x y)
  "Recursive version of UNION. Used by helper function MY-UNION."
  (cond ((null y) nil)
        ((member (first y) x)
         (union-recursively x (rest y)))
        (t (cons (first y)
                 (union-recursively
                  x
                  (rest y))))))

CL-USER> (my-union '(a b c) '(1 2 3))
----Enter MY-UNION
|     Arg-1 = (A B C)
|     Arg-2 = (1 2 3)
|   ----Enter UNION-RECURSIVELY
|   |     Arg-1 = (A B C)
|   |     Arg-2 = (1 2 3)
|   |   ----Enter UNION-RECURSIVELY
|   |   |     Arg-1 = (A B C)
|   |   |     Arg-2 = (2 3)
|   |   |   ----Enter UNION-RECURSIVELY
|   |   |   |     Arg-1 = (A B C)
|   |   |   |     Arg-2 = (3)
|   |   |   |   ----Enter UNION-RECURSIVELY
|   |   |   |   |     Arg-1 = (A B C)
|   |   |   |   |     Arg-2 = NIL
|   |   |   |    \--UNION-RECURSIVELY returned NIL
|   |   |    \--UNION-RECURSIVELY returned (3)
|   |    \--UNION-RECURSIVELY returned (2 3)
|    \--UNION-RECURSIVELY returned (1 2 3)
 \--MY-UNION returned (A B C 1 2 3)
(A B C 1 2 3)

Recall that UNION randomly returns the elements that appear in either list.

MY-UNION returns the elements that appear in either list as they come in.


8.53 Write LARGEST-EVEN, a recursive function that returns the largest even number in a list of non-negative integers. Use the built-in MAX function, which returns the largest of its inputs.

(defun largest-even (x)
  "Recursive function that returns the largest even number in a list of non-negative integers."
  (cond ((null x) 0)
        ((oddp (first x))
         (largest-even (rest x)))
        (t (max (first x)
                (largest-even (rest x))))))


8.54 Write recursive function HUGE that raises a number to its own power. Do not use REDUCE.

(defun huge-helper (x n)
  "Helper function to HUGE."
  (cond ((equal n 0) 1)
        (t (* x (huge-helper x (- n 1))))))

(defun huge (x)
  "Recursive function that raises a number to its own power."
  (huge-helper x x))

CL-USER> (huge 3)
----Enter HUGE
|     Arg-1 = 3
|   ----Enter HUGE-HELPER
|   |     Arg-1 = 3
|   |     Arg-2 = 3
|   |   ----Enter HUGE-HELPER
|   |   |     Arg-1 = 3
|   |   |     Arg-2 = 2
|   |   |   ----Enter HUGE-HELPER
|   |   |   |     Arg-1 = 3
|   |   |   |     Arg-2 = 1
|   |   |   |   ----Enter HUGE-HELPER
|   |   |   |   |     Arg-1 = 3
|   |   |   |   |     Arg-2 = 0
|   |   |   |    \--HUGE-HELPER returned 1
|   |   |    \--HUGE-HELPER returned 3
|   |    \--HUGE-HELPER returned 9
|    \--HUGE-HELPER returned 27
 \--HUGE returned 27
27



---
8.15 RECURSION IN ART AND LITERATURE
---

TLDR; Recursion has shown up cleverly in art and literature.


SUMMARY

Recursion is a very powerful control structure, and one of the most important ideas in computer science.
A function is said to be recursive if it calls itself.
To write a recursive function, we must solve three problems posed by the Dragon's Three Rules of Recursion:

1. Know when to stop.
2. decide how to take one step.
3. Break the journey down into that step plus a smaller journey.

We have seen a number of recursion templates in this chapter.
Recursion templates capture the essence of certain stereotypical recursive solutions.
They can be used for writing new functions, or for analysing existing functions.

The templates we have seen so far are:

1. Double-test tail recursion
2. Single-test tail recursion
3. Single-test augmenting recursion
4. List-consing recursion
5. Simultaneous recursion on several variables
6. Conditional augmentation
7. Multiple recursive calls
8. CAR/CDR Recursion


REVIEW EXERCISES

8.55 What distinguishes a recursive function from a non-recursive one?

Recursive functions call on themselves or another function that calls it in turn.
Non-recursive functions rely on other functions  (i.e applicative).


8.56 Write every other a recursive  function that returns every other element of a list.

 (defun every-other (x)
  "Recursive function that returns every other element of the input list."
  (cond ((null x) nil)
        (t (cons * (first x)
                 (every-other (rest (rest x)))))))

CL-USER> (every-other '(a b c d e))
----Enter EVERY-OTHER
|     Arg-1 = (A B C D E)
|   ----Enter EVERY-OTHER
|   |     Arg-1 = (C D E)
|   |   ----Enter EVERY-OTHER
|   |   |     Arg-1 = (E)
|   |   |   ----Enter EVERY-OTHER
|   |   |   |     Arg-1 = NIL
|   |   |    \--EVERY-OTHER returned NIL
|   |    \--EVERY-OTHER returned (E)
|    \--EVERY-OTHER returned (C E)
 \--EVERY-OTHER returned (A C E)
(A C E)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Come back to these review exercises.
;;    Move onto other topics.
;;      Keep moving rapidly and comeback from bottom-up the way lisp programmers
;;        do.
;;


---
Lisp Toolkit: The Debugger
---
*NOTE*
The debugger used in this book is different than the one we are using in SLIME, SLDB.
Check the slime user manual for the needed commands.

What's the first command you learned in the debugger ..?

  -> Q
    - or -

  > :A

  ctrl-c/g

We can use the BREAK function to enter the debugger at a strategic point in the computation.

The argument BREAK is a message, in string quotes, to be printed when the debugger is entered.

A modified FACT that demonstrates the use of BREAK:

(defun fact (n)
  "Modified FACT using BREAK to enter the debugger."
  (cond ((zerop n) (break "N is zero."))
        (t (* n (fact (- n 1))))))

One of the things we can do in the debugger is display a backtrace of the control stack.
  The control stack shows all the recursive calls that are currently stacked up.
    It is Lisp's way of keeping track of a collection of nested function calls.
  A stack frame is an entry on the stack that describes one of these function calls.

The BK command shows the backtrace of the control stack.

CL-USER> (fact 5)

Backtrace:
  0: (FACT 1)
      Locals:
        N = 1
  1: (FACT 2)
      Locals:
        N = 2
  2: (FACT 3)
      Locals:
        N = 3
  3: (FACT 4)
      Locals:
        N = 4
  4: (FACT 5)
      Locals:
        N = 5
  5: (SB-INT:SIMPLE-EVAL-IN-LEXENV (FACT 5) #<NULL-LEXENV>)
      Locals:
        SB-KERNEL:LEXENV = #<NULL-LEXENV>
        SB-IMPL::ORIGINAL-EXP = (FACT 5)
  6: (EVAL (FACT 5))
      Locals:
        SB-IMPL::ORIGINAL-EXP = (FACT 5)

BKFV gives a display of function names and their local variables.
  (Seems to be the standard in my Lisp.)



---
Keyboard Exercise
---

This exercise requires us to extract different sorts of information from a genealogical database.
The database gives information for five generations of a family.

Typically generations of things can be structured as trees,
  the structure representing this family structure is not structured in any sort of way.
    It kind of has two lines of people in series in the centre,
      Those two lines cascading off into terminal nodes in the structure.


*LISTEN*

  Marie has married her first cousin Nigel.

  Wanda has one child with Vincent and another with Ivan.

  Zelda and Robert are Yvette's parents, and have two grandparents in common.
    .. could be why Yvette turned out so odd.

  Only Tamara Knows who Frederick's father is, and she's not telling.


Each person in the database is represented by an entry in form:

  (name father mother)

When someone's father or mother is unknown, a value of NIL is used.

Functions written don't need to be recursive unless specified.

For functions that return lists of names, order of names returned isn't important.

There should not be any duplicates returned.


(setf family
      '((colin nil nil)
        (deidre nil nil)
        (arthur nil nil)
        (kate nil nil)
        (frank nil nil)
        (linda nil nil)
        (suzanne colin deidre)
        (bruce arthur kate)
        (charles arhtur kate)
        (david arthur kate)
        (ellen arthur kate)
        (george frank linda)
        (hillary frank linda)
        (andre nil nil)
        (tamara bruce suzanne)
        (vincent bruce suzanne)
        (wanda nil nil)
        (ivan george ellen)
        (julie george ellen)
        (marie george ellen)
        (nigel andre hillary)
        (frederick nil tamara)
        (zelda vincent wanda)
        (joshua ivan wanda)
        (quentin nil nil)
        (robert quentin julie)
        (olivia nigel marie)
        (peter nigel marie)
        (erica nil nil)
        (yvette robert zelda)
        (diane peter erica)))


EXERCISE
8.60 If the genealogy database is already stored on the computer for you,
load the file containing it. Store it in the global variable FAMILY.

Alist entry form:
(name father mother)

a. Write the functions FATHER, MOTHER, PARENTS, and CHILDREN that return a person's father, mother, a list of his or her children, respectively. If an input is NIL, NIL should be returned. This feature will be useful later when we write some recursive functions.

(defun father (x)
  "Returns the father of an entry in the alist FAMILY."
  (second (assoc x family)))

CL-USER> (father 'peter)
NIGEL
CL-USER> (father 'yvette)
ROBERT
CL-USER> (father 'colin)
NIL

(defun mother (x)
  "Returns the mother of an entry in the alist FAMILY."
  (third (assoc x family)))

CL-USER> (mother 'erica)
NIL
CL-USER> (mother 'nigel)
HILLARY
CL-USER> (mother 'olivia)
MARIE

(defun parents (x)
  "Returns the parents of X in the alist FAMILY."
  (union (and (father x) (list (father x)))
         (and (father x) (list (father x)))))

CL-USER> (parents zelda)
; Evaluation aborted on #<UNBOUND-VARIABLE ZELDA {100381D2E3}>.
CL-USER> (parents 'zelda)
(VINCENT WANDA)
CL-USER> (parents 'olivia)
(NIGEL MARIE)
CL-USER> (parents 'erica)
NIL


b. Write SIBLINGS, a function that returns a list of a person's siblings,
  including genetic half-siblings.

(defun children (parent)
  "Returns all offspring of a parent from the FAMILY alist."
  (and parent
       (mapcar #'first
               (remove-if-not
                #'(lambda (entry)
                    (member parent (rest entry)))
                family))))

(defun siblings (x)
  "Returns the siblings of X from the FAMILY alist."
  (set-difference (union (children (father x))
                         (children (mother x)))
                  (list x)))

  Describe how this function operates on its input ..

    (defun children (parent)
    "Returns all offspring of a parent from the FAMILY alist."
    (and parent
         (mapcar #'first
                 (remove-if-not
                  #'(lambda (entry)
                      (member parent (rest entry)))
                  family))))    ; FAMILY is the alist the function is taking input from.

          *NOTE* Remember the entry form: (name father mother)

      FAMILY))))

            The alist supplying MAPCAR with entries.


      #'(LAMBDA (ENTRY)
          (MEMBER PARENT (REST ENTRY)))

            This is one of two applicative operators applies by MAPCAR.
            It takes the rest of an entry and tests whether PARENT is a MEMBER.
              MEMBER is a traditional predicate that returns the satisfying element,
                including the following list elements.

      (REMOVE-IF-NOT ...

            Removes the entry elements that do not satisfy the MEMBER test.
            If an entry passes the test, it moves up to the next applicative operator.

      #'FIRST

            Final applicative operator MAPCAR applies.
            Takes the FIRST element of its input entry (which is the child)
              and lists it.

      (MAPCAR ...

            MAPCAR is the applicative operator driving the function definition.
            It takes entries from the FAMILY alist and operates on them with LAMBDA and FIRST.
            Useless entries are removed first, entries with the correct elements are passed up.
            FIRST takes the passing entries, extracts the first element and lists it.


      (AND PARENT ...

            AND returns the names passed by MAPCAR as a list
              until the applicative operator returns NIL.


b. Write SIBLINGS, a function that returns a list of a person's siblings,
  including genetic half-siblings.

  (defun siblings (x)
  "Returns the siblings of X from the FAMILY alist."
  (set-difference (union (children (father x))
                         (children (mother x)))
                  (list x)))

 CL-USER> (siblings 'bruce)
----Enter SIBLINGS
|     Arg-1 = BRUCE
|   ----Enter FATHER
|   |     Arg-1 = BRUCE
|    \--FATHER returned ARTHUR
|   ----Enter CHILDREN
|   |     Arg-1 = ARTHUR
|    \--CHILDREN returned (BRUCE DAVID ELLEN)
|   ----Enter MOTHER
|   |     Arg-1 = BRUCE
|    \--MOTHER returned KATE
|   ----Enter CHILDREN
|   |     Arg-1 = KATE
|    \--CHILDREN returned (BRUCE CHARLES DAVID ELLEN)
 \--SIBLINGS returned (ELLEN DAVID CHARLES)
(ELLEN DAVID CHARLES)
CL-USER> (siblings 'zelda)
----Enter SIBLINGS
|     Arg-1 = ZELDA
|   ----Enter FATHER
|   |     Arg-1 = ZELDA
|    \--FATHER returned VINCENT
|   ----Enter CHILDREN
|   |     Arg-1 = VINCENT
|    \--CHILDREN returned (ZELDA)
|   ----Enter MOTHER
|   |     Arg-1 = ZELDA
|    \--MOTHER returned WANDA
|   ----Enter CHILDREN
|   |     Arg-1 = WANDA
|    \--CHILDREN returned (ZELDA JOSHUA)
 \--SIBLINGS returned (JOSHUA)
(JOSHUA)

  Breaking the function definition down ..

  (LIST X)))

    The input is initially listed and given to SET-DIFFERENCE


  (UNION (CHILDREN (FATHER X))
         (CHILDREN (MOTHER X)))

    The mother and father of input is found first.
    Next the children of the mother are found,
      then the children of the father. (They may have children in other relationships.)
    UNION takes those resulting children, puts them in a list then hands that to SET-DIFFERENCE.


  (SET-DIFFERENCE ...

    Takes X as a list and the children of both parents as another list.
    X is removed, the remaining elements are listed as the return value.


c. Write MAPUNION, an applicative operator that takes a function and a list as input, applies the function to every element of the list, and computes the union of all the results.
HINT: MAPUNION can be defined as a combination of two applicative operators we already know.

  (defun mapunion (fn x)
    "Applicative operator; computes the union of all results."
    (and x (reduce #'union (mapcar fn x))))

  CL-USER> (mapunion #'rest '((1 a b c) (2 e f g) (3 f a b c d)))
  ----Enter MAPUNION
  |     Arg-1 = #<FUNCTION REST>
  |     Arg-2 = ((1 A B C) (2 E F G) (3 F A B C D))
   \--MAPUNION returned (G E F A B C D)
  (G E F A B C D)

  EXPLANATION:

    (MAPCAR FN X))))

      Applies the input function to each element of list X.


    (REDUCE #'UNION ...

      UNION is applied to each input list.
      REDUCE takes away duplicates in the result.


    (AND X ..

      AND evaluates all clauses until it hits a NIL,
        in this example AND doesn't find a NIL.
      Since no NIL is found AND returns its last input.


d. Write GRANDPARENTS, a function that returns the set of a person's grandparents. Use MAPUNION.

  (defun grandparents (x)
    "Returns the set of a persons grandparents from the FAMILY alist."
    (mapunion #'parents (parents x)))

CL-USER> (grandparents 'olivia)
----Enter GRANDPARENTS
|     Arg-1 = OLIVIA
|   ----Enter PARENTS
|   |     Arg-1 = OLIVIA
|   |   ----Enter FATHER
|   |   |     Arg-1 = OLIVIA
|   |    \--FATHER returned NIGEL
|   |   ----Enter FATHER
|   |   |     Arg-1 = OLIVIA
|   |    \--FATHER returned NIGEL
|   |   ----Enter MOTHER
|   |   |     Arg-1 = OLIVIA
|   |    \--MOTHER returned MARIE
|   |   ----Enter MOTHER
|   |   |     Arg-1 = OLIVIA
|   |    \--MOTHER returned MARIE
|    \--PARENTS returned (NIGEL MARIE)
|   ----Enter MAPUNION
|   |     Arg-1 = #<CLOSURE (LAMBDA (&REST DTRACE::ARGUMENT-LIST) :IN DTRACE::TRACE-FUNCTION) {1003FFD7AB}>
|   |     Arg-2 = (NIGEL MARIE)
|   |   ----Enter PARENTS
|   |   |     Arg-1 = NIGEL
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = NIGEL
|   |   |    \--FATHER returned ANDRE
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = NIGEL
|   |   |    \--FATHER returned ANDRE
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = NIGEL
|   |   |    \--MOTHER returned HILLARY
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = NIGEL
|   |   |    \--MOTHER returned HILLARY
|   |    \--PARENTS returned (ANDRE HILLARY)
|   |   ----Enter PARENTS
|   |   |     Arg-1 = MARIE
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = MARIE
|   |   |    \--FATHER returned GEORGE
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = MARIE
|   |   |    \--FATHER returned GEORGE
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = MARIE
|   |   |    \--MOTHER returned ELLEN
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = MARIE
|   |   |    \--MOTHER returned ELLEN
|   |    \--PARENTS returned (GEORGE ELLEN)
|    \--MAPUNION returned (HILLARY ANDRE GEORGE ELLEN)
 \--GRANDPARENTS returned (HILLARY ANDRE GEORGE ELLEN)
(HILLARY ANDRE GEORGE ELLEN)

  GRANDPARENTS is a recursive function that uses the MAPUNION funciton as an
    applicative operator within its function body definition.


e. Write COUSINS, a function that returns the set of a persons genetically related first cousins,
in other words, the children of any of their parents siblings. Use mapunion.

  (defun cousins (x)
    "Returns the first cousins of X from the FAMILY alist."
    (mapunion #'children
              (mapunion #'siblings (parents x))))

CL-USER> (cousins 'julie)
----Enter COUSINS
|     Arg-1 = JULIE
|   ----Enter PARENTS
|   |     Arg-1 = JULIE
|   |   ----Enter FATHER
|   |   |     Arg-1 = JULIE
|   |    \--FATHER returned GEORGE
|   |   ----Enter FATHER
|   |   |     Arg-1 = JULIE
|   |    \--FATHER returned GEORGE
|   |   ----Enter MOTHER
|   |   |     Arg-1 = JULIE
|   |    \--MOTHER returned ELLEN
|   |   ----Enter MOTHER
|   |   |     Arg-1 = JULIE
|   |    \--MOTHER returned ELLEN
|    \--PARENTS returned (GEORGE ELLEN)
|   ----Enter MAPUNION
|   |     Arg-1 = #<CLOSURE (LAMBDA (&REST DTRACE::ARGUMENT-LIST) :IN DTRACE::TRACE-FUNCTION) {1003FFE45B}>
|   |     Arg-2 = (GEORGE ELLEN)
|   |   ----Enter SIBLINGS
|   |   |     Arg-1 = GEORGE
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = GEORGE
|   |   |    \--FATHER returned FRANK
|   |   |   ----Enter CHILDREN
|   |   |   |     Arg-1 = FRANK
|   |   |    \--CHILDREN returned (GEORGE HILLARY)
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = GEORGE
|   |   |    \--MOTHER returned LINDA
|   |   |   ----Enter CHILDREN
|   |   |   |     Arg-1 = LINDA
|   |   |    \--CHILDREN returned (GEORGE HILLARY)
|   |    \--SIBLINGS returned (HILLARY)
|   |   ----Enter SIBLINGS
|   |   |     Arg-1 = ELLEN
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = ELLEN
|   |   |    \--FATHER returned ARTHUR
|   |   |   ----Enter CHILDREN
|   |   |   |     Arg-1 = ARTHUR
|   |   |    \--CHILDREN returned (BRUCE DAVID ELLEN)
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = ELLEN
|   |   |    \--MOTHER returned KATE
|   |   |   ----Enter CHILDREN
|   |   |   |     Arg-1 = KATE
|   |   |    \--CHILDREN returned (BRUCE CHARLES DAVID ELLEN)
|   |    \--SIBLINGS returned (DAVID BRUCE CHARLES)
|    \--MAPUNION returned (CHARLES BRUCE DAVID HILLARY)
|   ----Enter MAPUNION
|   |     Arg-1 = #<CLOSURE (LAMBDA (&REST DTRACE::ARGUMENT-LIST) :IN DTRACE::TRACE-FUNCTION) {1003FFB1AB}>
|   |     Arg-2 = (CHARLES BRUCE DAVID HILLARY)
|   |   ----Enter CHILDREN
|   |   |     Arg-1 = CHARLES
|   |    \--CHILDREN returned NIL
|   |   ----Enter CHILDREN
|   |   |     Arg-1 = BRUCE
|   |    \--CHILDREN returned (TAMARA VINCENT)
|   |   ----Enter CHILDREN
|   |   |     Arg-1 = DAVID
|   |    \--CHILDREN returned NIL
|   |   ----Enter CHILDREN
|   |   |     Arg-1 = HILLARY
|   |    \--CHILDREN returned (NIGEL)
|    \--MAPUNION returned (VINCENT TAMARA NIGEL)
 \--COUSINS returned (VINCENT TAMARA NIGEL)
(VINCENT TAMARA NIGEL)

   MAPUNION is expanding these functions very nicely.
   *NOTE* CHILDREN provides the context to the FAMILY alist.


f. Write the two-input recursive predicate DESCENDED-FROM, returning a true value
if the first person is descended from the second.

  (defun descended-from (p1 p2)
    "Returns a true value if P1 is descended from P2."
    (cond ((null p1) nil)
          ((member p2 (parents p1)) t)
          (t (or (descended-from
                  (father p1) p2)
                 (descended-from
                  (mother p1) p2)))))

CL-USER> (descended-from 'tamara 'arthur)
----Enter DESCENDED-FROM
|     Arg-1 = TAMARA
|     Arg-2 = ARTHUR
|   ----Enter PARENTS
|   |     Arg-1 = TAMARA
|   |   ----Enter FATHER
|   |   |     Arg-1 = TAMARA
|   |    \--FATHER returned BRUCE
|   |   ----Enter FATHER
|   |   |     Arg-1 = TAMARA
|   |    \--FATHER returned BRUCE
|   |   ----Enter MOTHER
|   |   |     Arg-1 = TAMARA
|   |    \--MOTHER returned SUZANNE
|   |   ----Enter MOTHER
|   |   |     Arg-1 = TAMARA
|   |    \--MOTHER returned SUZANNE
|    \--PARENTS returned (BRUCE SUZANNE)
|   ----Enter FATHER
|   |     Arg-1 = TAMARA
|    \--FATHER returned BRUCE
|   ----Enter DESCENDED-FROM
|   |     Arg-1 = BRUCE
|   |     Arg-2 = ARTHUR
|   |   ----Enter PARENTS
|   |   |     Arg-1 = BRUCE
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = BRUCE
|   |   |    \--FATHER returned ARTHUR
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = BRUCE
|   |   |    \--FATHER returned ARTHUR
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = BRUCE
|   |   |    \--MOTHER returned KATE
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = BRUCE
|   |   |    \--MOTHER returned KATE
|   |    \--PARENTS returned (ARTHUR KATE)
|    \--DESCENDED-FROM returned T
 \--DESCENDED-FROM returned T
T

  The DTRACE output is becoming quite clear.


g. Write recursive function ANCESTORS that returns a person's set of ancestors.

  (defun ancestors (x)
    "Returns the ancestors of a person from the FAMILY alist."
    (cond ((null x) nil)
          (t (union
              (parents x)
              (union (ancestors (father x))
                     (ancestors (mother x)))))))

CL-USER> (ancestors 'marie)
----Enter ANCESTORS
|     Arg-1 = MARIE
|   ----Enter PARENTS
|   |     Arg-1 = MARIE
|   |   ----Enter FATHER
|   |   |     Arg-1 = MARIE
|   |    \--FATHER returned GEORGE
|   |   ----Enter FATHER
|   |   |     Arg-1 = MARIE
|   |    \--FATHER returned GEORGE
|   |   ----Enter MOTHER
|   |   |     Arg-1 = MARIE
|   |    \--MOTHER returned ELLEN
|   |   ----Enter MOTHER
|   |   |     Arg-1 = MARIE
|   |    \--MOTHER returned ELLEN
|    \--PARENTS returned (GEORGE ELLEN)
|   ----Enter FATHER
|   |     Arg-1 = MARIE
|    \--FATHER returned GEORGE
|   ----Enter ANCESTORS
|   |     Arg-1 = GEORGE
|   |   ----Enter PARENTS
|   |   |     Arg-1 = GEORGE
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = GEORGE
|   |   |    \--FATHER returned FRANK
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = GEORGE
|   |   |    \--FATHER returned FRANK
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = GEORGE
|   |   |    \--MOTHER returned LINDA
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = GEORGE
|   |   |    \--MOTHER returned LINDA
|   |    \--PARENTS returned (FRANK LINDA)
|   |   ----Enter FATHER
|   |   |     Arg-1 = GEORGE
|   |    \--FATHER returned FRANK
|   |   ----Enter ANCESTORS
|   |   |     Arg-1 = FRANK
|   |   |   ----Enter PARENTS
|   |   |   |     Arg-1 = FRANK
|   |   |   |   ----Enter FATHER
|   |   |   |   |     Arg-1 = FRANK
|   |   |   |    \--FATHER returned NIL
|   |   |   |   ----Enter MOTHER
|   |   |   |   |     Arg-1 = FRANK
|   |   |   |    \--MOTHER returned NIL
|   |   |    \--PARENTS returned NIL
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = FRANK
|   |   |    \--FATHER returned NIL
|   |   |   ----Enter ANCESTORS
|   |   |   |     Arg-1 = NIL
|   |   |    \--ANCESTORS returned NIL
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = FRANK
|   |   |    \--MOTHER returned NIL
|   |   |   ----Enter ANCESTORS
|   |   |   |     Arg-1 = NIL
|   |   |    \--ANCESTORS returned NIL
|   |    \--ANCESTORS returned NIL
|   |   ----Enter MOTHER
|   |   |     Arg-1 = GEORGE
|   |    \--MOTHER returned LINDA
|   |   ----Enter ANCESTORS
|   |   |     Arg-1 = LINDA
|   |   |   ----Enter PARENTS
|   |   |   |     Arg-1 = LINDA
|   |   |   |   ----Enter FATHER
|   |   |   |   |     Arg-1 = LINDA
|   |   |   |    \--FATHER returned NIL
|   |   |   |   ----Enter MOTHER
|   |   |   |   |     Arg-1 = LINDA
|   |   |   |    \--MOTHER returned NIL
|   |   |    \--PARENTS returned NIL
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = LINDA
|   |   |    \--FATHER returned NIL
|   |   |   ----Enter ANCESTORS
|   |   |   |     Arg-1 = NIL
|   |   |    \--ANCESTORS returned NIL
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = LINDA
|   |   |    \--MOTHER returned NIL
|   |   |   ----Enter ANCESTORS
|   |   |   |     Arg-1 = NIL
|   |   |    \--ANCESTORS returned NIL
|   |    \--ANCESTORS returned NIL
|    \--ANCESTORS returned (LINDA FRANK)
|   ----Enter MOTHER
|   |     Arg-1 = MARIE
|    \--MOTHER returned ELLEN
|   ----Enter ANCESTORS
|   |     Arg-1 = ELLEN
|   |   ----Enter PARENTS
|   |   |     Arg-1 = ELLEN
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = ELLEN
|   |   |    \--FATHER returned ARTHUR
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = ELLEN
|   |   |    \--FATHER returned ARTHUR
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = ELLEN
|   |   |    \--MOTHER returned KATE
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = ELLEN
|   |   |    \--MOTHER returned KATE
|   |    \--PARENTS returned (ARTHUR KATE)
|   |   ----Enter FATHER
|   |   |     Arg-1 = ELLEN
|   |    \--FATHER returned ARTHUR
|   |   ----Enter ANCESTORS
|   |   |     Arg-1 = ARTHUR
|   |   |   ----Enter PARENTS
|   |   |   |     Arg-1 = ARTHUR
|   |   |   |   ----Enter FATHER
|   |   |   |   |     Arg-1 = ARTHUR
|   |   |   |    \--FATHER returned NIL
|   |   |   |   ----Enter MOTHER
|   |   |   |   |     Arg-1 = ARTHUR
|   |   |   |    \--MOTHER returned NIL
|   |   |    \--PARENTS returned NIL
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = ARTHUR
|   |   |    \--FATHER returned NIL
|   |   |   ----Enter ANCESTORS
|   |   |   |     Arg-1 = NIL
|   |   |    \--ANCESTORS returned NIL
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = ARTHUR
|   |   |    \--MOTHER returned NIL
|   |   |   ----Enter ANCESTORS
|   |   |   |     Arg-1 = NIL
|   |   |    \--ANCESTORS returned NIL
|   |    \--ANCESTORS returned NIL
|   |   ----Enter MOTHER
|   |   |     Arg-1 = ELLEN
|   |    \--MOTHER returned KATE
|   |   ----Enter ANCESTORS
|   |   |     Arg-1 = KATE
|   |   |   ----Enter PARENTS
|   |   |   |     Arg-1 = KATE
|   |   |   |   ----Enter FATHER
|   |   |   |   |     Arg-1 = KATE
|   |   |   |    \--FATHER returned NIL
|   |   |   |   ----Enter MOTHER
|   |   |   |   |     Arg-1 = KATE
|   |   |   |    \--MOTHER returned NIL
|   |   |    \--PARENTS returned NIL
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = KATE
|   |   |    \--FATHER returned NIL
|   |   |   ----Enter ANCESTORS
|   |   |   |     Arg-1 = NIL
|   |   |    \--ANCESTORS returned NIL
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = KATE
|   |   |    \--MOTHER returned NIL
|   |   |   ----Enter ANCESTORS
|   |   |   |     Arg-1 = NIL
|   |   |    \--ANCESTORS returned NIL
|   |    \--ANCESTORS returned NIL
|    \--ANCESTORS returned (KATE ARTHUR)
 \--ANCESTORS returned (ARTHUR KATE LINDA FRANK GEORGE ELLEN)
(ARTHUR KATE LINDA FRANK GEORGE ELLEN)

  This recursive function recurses until it finds all of a person's parents plus
    his parents ancestors.


h. Write the recursive function GENERATION-GAP that returns the number of generations separating
a person and one of his or her ancestors.

  (defun generation-gap (x y)
  "Returns the number of generations separating one and an ancestor using the FAMILY alist."
  (g-gap-helper x y 0))

(defun g-gap-helper (x y n)
  "Helper function to GENERATION-GAP."
  (cond ((null x) nil)
        ((equal x y) n)
        (t (or (g-gap-helper
                (father x) y (+ 1 n))
               (g-gap-helper
                (mother x) y (+ 1 n))))))

CL-USER> (generation-gap 'suzanne 'colin)
----Enter GENERATION-GAP
|     Arg-1 = SUZANNE
|     Arg-2 = COLIN
|   ----Enter G-GAP-HELPER
|   |     Arg-1 = SUZANNE
|   |     Arg-2 = COLIN
|   |     Arg-3 = 0
|   |   ----Enter FATHER
|   |   |     Arg-1 = SUZANNE
|   |    \--FATHER returned COLIN
|   |   ----Enter G-GAP-HELPER
|   |   |     Arg-1 = COLIN
|   |   |     Arg-2 = COLIN
|   |   |     Arg-3 = 1
|   |    \--G-GAP-HELPER returned 1
|    \--G-GAP-HELPER returned 1
 \--GENERATION-GAP returned 1
1
CL-USER> (generation-gap 'frederick 'colin)
----Enter GENERATION-GAP
|     Arg-1 = FREDERICK
|     Arg-2 = COLIN
|   ----Enter G-GAP-HELPER
|   |     Arg-1 = FREDERICK
|   |     Arg-2 = COLIN
|   |     Arg-3 = 0
|   |   ----Enter FATHER
|   |   |     Arg-1 = FREDERICK
|   |    \--FATHER returned NIL
|   |   ----Enter G-GAP-HELPER
|   |   |     Arg-1 = NIL
|   |   |     Arg-2 = COLIN
|   |   |     Arg-3 = 1
|   |    \--G-GAP-HELPER returned NIL
|   |   ----Enter MOTHER
|   |   |     Arg-1 = FREDERICK
|   |    \--MOTHER returned TAMARA
|   |   ----Enter G-GAP-HELPER
|   |   |     Arg-1 = TAMARA
|   |   |     Arg-2 = COLIN
|   |   |     Arg-3 = 1
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = TAMARA
|   |   |    \--FATHER returned BRUCE
|   |   |   ----Enter G-GAP-HELPER
|   |   |   |     Arg-1 = BRUCE
|   |   |   |     Arg-2 = COLIN
|   |   |   |     Arg-3 = 2
|   |   |   |   ----Enter FATHER
|   |   |   |   |     Arg-1 = BRUCE
|   |   |   |    \--FATHER returned ARTHUR
|   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |     Arg-1 = ARTHUR
|   |   |   |   |     Arg-2 = COLIN
|   |   |   |   |     Arg-3 = 3
|   |   |   |   |   ----Enter FATHER
|   |   |   |   |   |     Arg-1 = ARTHUR
|   |   |   |   |    \--FATHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = COLIN
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |   |   ----Enter MOTHER
|   |   |   |   |   |     Arg-1 = ARTHUR
|   |   |   |   |    \--MOTHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = COLIN
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |   ----Enter MOTHER
|   |   |   |   |     Arg-1 = BRUCE
|   |   |   |    \--MOTHER returned KATE
|   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |     Arg-1 = KATE
|   |   |   |   |     Arg-2 = COLIN
|   |   |   |   |     Arg-3 = 3
|   |   |   |   |   ----Enter FATHER
|   |   |   |   |   |     Arg-1 = KATE
|   |   |   |   |    \--FATHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = COLIN
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |   |   ----Enter MOTHER
|   |   |   |   |   |     Arg-1 = KATE
|   |   |   |   |    \--MOTHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = COLIN
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |    \--G-GAP-HELPER returned NIL
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = TAMARA
|   |   |    \--MOTHER returned SUZANNE
|   |   |   ----Enter G-GAP-HELPER
|   |   |   |     Arg-1 = SUZANNE
|   |   |   |     Arg-2 = COLIN
|   |   |   |     Arg-3 = 2
|   |   |   |   ----Enter FATHER
|   |   |   |   |     Arg-1 = SUZANNE
|   |   |   |    \--FATHER returned COLIN
|   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |     Arg-1 = COLIN
|   |   |   |   |     Arg-2 = COLIN
|   |   |   |   |     Arg-3 = 3
|   |   |   |    \--G-GAP-HELPER returned 3
|   |   |    \--G-GAP-HELPER returned 3
|   |    \--G-GAP-HELPER returned 3
|    \--G-GAP-HELPER returned 3
 \--GENERATION-GAP returned 3
3
CL-USER> (generation-gap 'frederick 'linda)
----Enter GENERATION-GAP
|     Arg-1 = FREDERICK
|     Arg-2 = LINDA
|   ----Enter G-GAP-HELPER
|   |     Arg-1 = FREDERICK
|   |     Arg-2 = LINDA
|   |     Arg-3 = 0
|   |   ----Enter FATHER
|   |   |     Arg-1 = FREDERICK
|   |    \--FATHER returned NIL
|   |   ----Enter G-GAP-HELPER
|   |   |     Arg-1 = NIL
|   |   |     Arg-2 = LINDA
|   |   |     Arg-3 = 1
|   |    \--G-GAP-HELPER returned NIL
|   |   ----Enter MOTHER
|   |   |     Arg-1 = FREDERICK
|   |    \--MOTHER returned TAMARA
|   |   ----Enter G-GAP-HELPER
|   |   |     Arg-1 = TAMARA
|   |   |     Arg-2 = LINDA
|   |   |     Arg-3 = 1
|   |   |   ----Enter FATHER
|   |   |   |     Arg-1 = TAMARA
|   |   |    \--FATHER returned BRUCE
|   |   |   ----Enter G-GAP-HELPER
|   |   |   |     Arg-1 = BRUCE
|   |   |   |     Arg-2 = LINDA
|   |   |   |     Arg-3 = 2
|   |   |   |   ----Enter FATHER
|   |   |   |   |     Arg-1 = BRUCE
|   |   |   |    \--FATHER returned ARTHUR
|   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |     Arg-1 = ARTHUR
|   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |     Arg-3 = 3
|   |   |   |   |   ----Enter FATHER
|   |   |   |   |   |     Arg-1 = ARTHUR
|   |   |   |   |    \--FATHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |   |   ----Enter MOTHER
|   |   |   |   |   |     Arg-1 = ARTHUR
|   |   |   |   |    \--MOTHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |   ----Enter MOTHER
|   |   |   |   |     Arg-1 = BRUCE
|   |   |   |    \--MOTHER returned KATE
|   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |     Arg-1 = KATE
|   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |     Arg-3 = 3
|   |   |   |   |   ----Enter FATHER
|   |   |   |   |   |     Arg-1 = KATE
|   |   |   |   |    \--FATHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |   |   ----Enter MOTHER
|   |   |   |   |   |     Arg-1 = KATE
|   |   |   |   |    \--MOTHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |    \--G-GAP-HELPER returned NIL
|   |   |   ----Enter MOTHER
|   |   |   |     Arg-1 = TAMARA
|   |   |    \--MOTHER returned SUZANNE
|   |   |   ----Enter G-GAP-HELPER
|   |   |   |     Arg-1 = SUZANNE
|   |   |   |     Arg-2 = LINDA
|   |   |   |     Arg-3 = 2
|   |   |   |   ----Enter FATHER
|   |   |   |   |     Arg-1 = SUZANNE
|   |   |   |    \--FATHER returned COLIN
|   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |     Arg-1 = COLIN
|   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |     Arg-3 = 3
|   |   |   |   |   ----Enter FATHER
|   |   |   |   |   |     Arg-1 = COLIN
|   |   |   |   |    \--FATHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |   |   ----Enter MOTHER
|   |   |   |   |   |     Arg-1 = COLIN
|   |   |   |   |    \--MOTHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |   ----Enter MOTHER
|   |   |   |   |     Arg-1 = SUZANNE
|   |   |   |    \--MOTHER returned DEIDRE
|   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |     Arg-1 = DEIDRE
|   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |     Arg-3 = 3
|   |   |   |   |   ----Enter FATHER
|   |   |   |   |   |     Arg-1 = DEIDRE
|   |   |   |   |    \--FATHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |   |   ----Enter MOTHER
|   |   |   |   |   |     Arg-1 = DEIDRE
|   |   |   |   |    \--MOTHER returned NIL
|   |   |   |   |   ----Enter G-GAP-HELPER
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = LINDA
|   |   |   |   |   |     Arg-3 = 4
|   |   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |   |    \--G-GAP-HELPER returned NIL
|   |   |    \--G-GAP-HELPER returned NIL
|   |    \--G-GAP-HELPER returned NIL
|    \--G-GAP-HELPER returned NIL
 \--GENERATION-GAP returned NIL
NIL


i. Use the functions you have written to answer the following questions
  1. Is Robert descended from Deirdre? No.
  2. Who are Yvette's ancestors? (WANDA VINCENT SUZANNE BRUCE ARTHUR KATE DEIDRE COLIN LINDA FRANK GEORGE ELLEN
 QUENTIN JULIE ROBERT ZELDA)
  3. What is the generation gap between Olivia and Frank? 3
  4. Who are Peter's cousins? (JOSHUA ROBERT)
  5. Who are Olivia's grandparents? (HILLARY ANDRE GEORGE ELLEN)



***
8 Advanced Topics

---
8.16 ADVANTAGES OF TAIL RECURSION

Remember that tail-recursive functions do not work after the recursive call;
  the function returns whatever the recursive call returns.

ANYODDP is a tail recursive function, but COUNT-SLICES is not.

(defun count-slices (loaf)
  "Counts how many slices there are in the loaf."
  (cond ((null loaf) 0)
        (t (+ 1 (count-slices (rest loaf))))))

CL-USER> (count-slices '(x x x x x x x))
----Enter COUNT-SLICES
|     Arg-1 = (X X X X X X X)
|   ----Enter COUNT-SLICES
|   |     Arg-1 = (X X X X X X)
|   |   ----Enter COUNT-SLICES
|   |   |     Arg-1 = (X X X X X)
|   |   |   ----Enter COUNT-SLICES
|   |   |   |     Arg-1 = (X X X X)
|   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |     Arg-1 = (X X X)
|   |   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |   |     Arg-1 = (X X)
|   |   |   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |   |   |     Arg-1 = (X)
|   |   |   |   |   |   |   ----Enter COUNT-SLICES
|   |   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |    \--COUNT-SLICES returned 0
|   |   |   |   |   |    \--COUNT-SLICES returned 1
|   |   |   |   |    \--COUNT-SLICES returned 2
|   |   |   |    \--COUNT-SLICES returned 3
|   |   |    \--COUNT-SLICES returned 4
|   |    \--COUNT-SLICES returned 5
|    \--COUNT-SLICES returned 6
 \--COUNT-SLICES returned 7
7


If we look at the trace of COUNT-SLICES again,
  we see that each recursive call produces a different return value (augmentation).


(defun find-first-atom (lst)
  "Finds the first atom in the lst."
  (cond ((atom lst) lst)
        (t (find-first-atom (first x)))))

In a tail-recursive function, all calls return the same value as the terminal call.

CL-USER> (find-first-atom '((((d)))))
----Enter FIND-FIRST-ATOM
|     Arg-1 = ((((D))))
|   ----Enter FIND-FIRST-ATOM
|   |     Arg-1 = (((D)))
|   |   ----Enter FIND-FIRST-ATOM
|   |   |     Arg-1 = ((D))
|   |   |   ----Enter FIND-FIRST-ATOM
|   |   |   |     Arg-1 = (D)
|   |   |   |   ----Enter FIND-FIRST-ATOM
|   |   |   |   |     Arg-1 = D
|   |   |   |    \--FIND-FIRST-ATOM returned D
|   |   |    \--FIND-FIRST-ATOM returned D
|   |    \--FIND-FIRST-ATOM returned D
|    \--FIND-FIRST-ATOM returned D
 \--FIND-FIRST-ATOM returned D
D


In general it is better to write recursive functions in tail-recursive form whenever possible,
  because Lisp systems can execute tail-recursive functions more efficiently than ordinary
    recursive functions.

They do this by replacing the recursive call with a jump.

Many Lisp compilers perform this optimization automatically;
  some interpreters do as well.

A common technique for producing a tail-recursive version of an ordinary recursive function
  is to introduce an extra variable for accumulating augmentation values.

For example, here is a tail-recursive function called TR-COUNT-SLICES
  that sets up the initial call to TR-CS1.

TR-CS1 uses an extra variable N to hold the number of slices seen so far.

(defun tr-count-slices (loaf)
  "Tail-recursive function, sets up  the initial call to TR-CS1."
  (tr-cs1 loaf 0))

(defun tr-cs1 (loaf n)
  "Uses an extra variable N to hold the count of the number of slices seen thus far."
  (cond ((null loaf) n)
        (t (tr-cs1 (rest loaf) (+ n 1)))))

CL-USER> (tr-count-slices '(x x x x x))
----Enter TR-COUNT-SLICES
|     Arg-1 = (X X X X X)
|   ----Enter TR-CS1
|   |     Arg-1 = (X X X X X)
|   |     Arg-2 = 0
|   |   ----Enter TR-CS1
|   |   |     Arg-1 = (X X X X)
|   |   |     Arg-2 = 1
|   |   |   ----Enter TR-CS1
|   |   |   |     Arg-1 = (X X X)
|   |   |   |     Arg-2 = 2
|   |   |   |   ----Enter TR-CS1
|   |   |   |   |     Arg-1 = (X X)
|   |   |   |   |     Arg-2 = 3
|   |   |   |   |   ----Enter TR-CS1
|   |   |   |   |   |     Arg-1 = (X)
|   |   |   |   |   |     Arg-2 = 4
|   |   |   |   |   |   ----Enter TR-CS1
|   |   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |   |     Arg-2 = 5
|   |   |   |   |   |    \--TR-CS1 returned 5
|   |   |   |   |    \--TR-CS1 returned 5
|   |   |   |    \--TR-CS1 returned 5
|   |   |    \--TR-CS1 returned 5
|   |    \--TR-CS1 returned 5
|    \--TR-CS1 returned 5
 \--TR-COUNT-SLICES returned 5
5


Look in the DTRACE output, note that the value of N (Arg-2) increases with each call.

The terminal call computes the return value, 5;
  this value is then passed back unchanged by each level.

Every recursive call to TR-COUNT-SLICES is passed the value of the first call.
  The helper function TR-CS1 computes the number 5 in the first call
    and holds onto that value throughout each call.


REVERSE can display another example of how augmentation can be eliminated
  by introducing an extra variable:

(defun my-reverse (lst)
  "User defined REVERSE, eliminating augmentation within the recursive calls."
  (cond ((null lst) nil)
        (t (append (my-reverse (rest lst))
                   (list (first lst))))))

CL-USER> (my-reverse '(a b c d))
----Enter MY-REVERSE
|     Arg-1 = (A B C D)
|   ----Enter MY-REVERSE
|   |     Arg-1 = (B C D)
|   |   ----Enter MY-REVERSE
|   |   |     Arg-1 = (C D)
|   |   |   ----Enter MY-REVERSE
|   |   |   |     Arg-1 = (D)
|   |   |   |   ----Enter MY-REVERSE
|   |   |   |   |     Arg-1 = NIL
|   |   |   |    \--MY-REVERSE returned NIL
|   |   |    \--MY-REVERSE returned (D)
|   |    \--MY-REVERSE returned (D C)
|    \--MY-REVERSE returned (D C B)
 \--MY-REVERSE returned (D C B A)
(D C B A)
CL-USER> (my-reverse '(3 2 1))
----Enter MY-REVERSE
|     Arg-1 = (3 2 1)
|   ----Enter MY-REVERSE
|   |     Arg-1 = (2 1)
|   |   ----Enter MY-REVERSE
|   |   |     Arg-1 = (1)
|   |   |   ----Enter MY-REVERSE
|   |   |   |     Arg-1 = NIL
|   |   |    \--MY-REVERSE returned NIL
|   |    \--MY-REVERSE returned (1)
|    \--MY-REVERSE returned (1 2)
 \--MY-REVERSE returned (1 2 3)
(1 2 3)

To reverse a list of some length,
  we can reverse the REST of the list recursively,
    then tack the FIRST element onto the end like the above definition.

We can also tell that MY-REVERSE may have APPEND within the function body definition.
  Note how the last recursive call seems to append objects to the list front to back.

This version of REVERSE builds the return value after the recursive calls.

The definition above isn't tail-recursive.
  After the recursive call returns,
    the result is augmented by APPEND.


Below is a two-part, tail-recursive definition of REVERSE that uses an extra variable
  to build up the result with (rather than after) each recursive call:

(defun tr-reverse (list)
  "Our tail-recursive version of REVERSE. The extra variable builds the result up."
  (tr-rev1 list nil))

(defun tr-rev1 (list result)
  "Helper function to TR-REVERSE; we are building up a return value."
  (cond ((null list) result)
        (t (tr-rev1
            (rest list)
            (cons (first list) result)))))

CL-USER> (tr-reverse '(a b c d))
----Enter TR-REVERSE
|     Arg-1 = (A B C D)
|   ----Enter TR-REV1
|   |     Arg-1 = (A B C D)
|   |     Arg-2 = NIL
|   |   ----Enter TR-REV1
|   |   |     Arg-1 = (B C D)
|   |   |     Arg-2 = (A)
|   |   |   ----Enter TR-REV1
|   |   |   |     Arg-1 = (C D)
|   |   |   |     Arg-2 = (B A)
|   |   |   |   ----Enter TR-REV1
|   |   |   |   |     Arg-1 = (D)
|   |   |   |   |     Arg-2 = (C B A)
|   |   |   |   |   ----Enter TR-REV1
|   |   |   |   |   |     Arg-1 = NIL
|   |   |   |   |   |     Arg-2 = (D C B A)
|   |   |   |   |    \--TR-REV1 returned (D C B A)
|   |   |   |    \--TR-REV1 returned (D C B A)
|   |   |    \--TR-REV1 returned (D C B A)
|   |    \--TR-REV1 returned (D C B A)
|    \--TR-REV1 returned (D C B A)
 \--TR-REVERSE returned (D C B A)
(D C B A)


Not all recursive functions have tail-recursive versions.

Any function that is multiple recursive, such as FIB,
  cannot be made tail-recursive simply by introducing an extra variable,
    since after the first recursive call returns there is another one waiting to be done.

Tail-recursive calls are only good after the first call,
  the return value is the result of the first call.

Tail recursion is a sort of way to get an initial return value through recursive methods.


EXERCISES
8.61 Write a tail-recursive version of COUNT-UP.

(defun tr-count-up (n)
  "Tail-recursive version of COUNT-UP."
  (tr-count-up1 n nil))

(defun tr-count-up1 (n result)
  "Helper function to TR-COUNT-UP."
  (cond ((zerop n) result)
        (t (tr-count-up1
            (- n 1)
            (cons n result)))))

CL-USER> (tr-count-up 3)
----Enter TR-COUNT-UP
|     Arg-1 = 3
|   ----Enter TR-COUNT-UP1
|   |     Arg-1 = 3
|   |     Arg-2 = NIL
|   |   ----Enter TR-COUNT-UP1
|   |   |     Arg-1 = 2
|   |   |     Arg-2 = (3)
|   |   |   ----Enter TR-COUNT-UP1
|   |   |   |     Arg-1 = 1
|   |   |   |     Arg-2 = (2 3)
|   |   |   |   ----Enter TR-COUNT-UP1
|   |   |   |   |     Arg-1 = 0
|   |   |   |   |     Arg-2 = (1 2 3)
|   |   |   |    \--TR-COUNT-UP1 returned (1 2 3)
|   |   |    \--TR-COUNT-UP1 returned (1 2 3)
|   |    \--TR-COUNT-UP1 returned (1 2 3)
|    \--TR-COUNT-UP1 returned (1 2 3)
 \--TR-COUNT-UP returned (1 2 3)
(1 2 3)



8.62 Write a tail-recursive version of FACT.
       Remember: N factorial is N times N-1 factorial, and zero is factorial one.

(defun tr-fact (n)
  "Tail-recursive version of FACT."
  (tr-fact1 n 1))

(defun tr-fact1 (n result)
  "Helper function to TR-FACT."
  (cond ((zerop n) result)
        (t (tr-fact1
            (- n 1)
            (* n result)))))

CL-USER> (tr-fact 3)
----Enter TR-FACT
|     Arg-1 = 3
|   ----Enter TR-FACT1
|   |     Arg-1 = 3
|   |     Arg-2 = 1
|   |   ----Enter TR-FACT1
|   |   |     Arg-1 = 2
|   |   |     Arg-2 = 3
|   |   |   ----Enter TR-FACT1
|   |   |   |     Arg-1 = 1
|   |   |   |     Arg-2 = 6
|   |   |   |   ----Enter TR-FACT1
|   |   |   |   |     Arg-1 = 0
|   |   |   |   |     Arg-2 = 6
|   |   |   |    \--TR-FACT1 returned 6
|   |   |    \--TR-FACT1 returned 6
|   |    \--TR-FACT1 returned 6
|    \--TR-FACT1 returned 6
 \--TR-FACT returned 6
6
CL-USER> (fact 3)
----Enter FACT
|     Arg-1 = 3
|   ----Enter FACT
|   |     Arg-1 = 2
|   |   ----Enter FACT
|   |   |     Arg-1 = 1
|   |   |   ----Enter FACT
|   |   |   |     Arg-1 = 0
|   |   |    \--FACT returned 1
|   |    \--FACT returned 1
|    \--FACT returned 2
 \--FACT returned 6
6

Do the math yourself within each recursive call,
  the result is 6 everytime.


8.63 Write tail-recursive versions of UNION, INTERSECTION, and SET-DIFFERENCE.

(defun tr-union (x y)
  "Tail-recursive version of UNION."
  (cond ((null x) y)
        ((member (first x) y)
         (tr-union (rest x) y))
        (t (tr-union
            (rest x)
            (cons (first x) y)))))

(defun tr-intersection (x y)
  "Tail-recursive version of INTERSECTION."
  (tr-intersect1 x y nil))

(defun tr-intersect1 (x y result)
  "Helper function to TR-INTRERSECTION."
  (cond ((null x) result)
        ((member (first x) y)
        (tr-intersect1
         (rest x)
         y
         (cons (first x) result)))
  (t (tr-intersect1
      (rest x) y result))))

(defun tr-set-difference (x y)
  "Tail-recursive version of SET-DIFFERENCE."
  (tr-setdiff1 x y nil))

(defun tr-setdiff1 (x y result)
  "Helper function to TR-SET-DIFFERENCE."
  (cond ((null x) result)
        ((not (member (first x) y))
         (tr-setdiff1
          (rest x)
          y
          (cons (first x) result)))
        (t (tr-setdiff1
            (rest x) y result))))



---
8.17 WRITING NEW APPLICATIVE OPERATORS

We can use FUNCALL to invoke a function that the user supplies.
  This allows us to write applicative operators.

(defun my-mapcar (fn x)
  "Defining our own applicative operator. A fork of MAPCAR."
  (cond ((null x) nil)
        (t (cons (funcall fn (first x))
                 (my-mapcar fn (rest x))))))

CL-USER> (setf words
               '((one un)
                 (two deux)
                 (three trois)
                 (four quatre)
                 (five cinq)))
((ONE UN) (TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
CL-USER> (my-mapcar #'second words)
(UN DEUX TROIS QUATRE CINQ)
CL-USER> (my-mapcar #'second words)
----Enter MY-MAPCAR
|     Arg-1 = #<FUNCTION SECOND>
|     Arg-2 = ((ONE UN) (TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
|   ----Enter MY-MAPCAR
|   |     Arg-1 = #<FUNCTION SECOND>
|   |     Arg-2 = ((TWO DEUX) (THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
|   |   ----Enter MY-MAPCAR
|   |   |     Arg-1 = #<FUNCTION SECOND>
|   |   |     Arg-2 = ((THREE TROIS) (FOUR QUATRE) (FIVE CINQ))
|   |   |   ----Enter MY-MAPCAR
|   |   |   |     Arg-1 = #<FUNCTION SECOND>
|   |   |   |     Arg-2 = ((FOUR QUATRE) (FIVE CINQ))
|   |   |   |   ----Enter MY-MAPCAR
|   |   |   |   |     Arg-1 = #<FUNCTION SECOND>
|   |   |   |   |     Arg-2 = ((FIVE CINQ))
|   |   |   |   |   ----Enter MY-MAPCAR
|   |   |   |   |   |     Arg-1 = #<FUNCTION SECOND>
|   |   |   |   |   |     Arg-2 = NIL
|   |   |   |   |    \--MY-MAPCAR returned NIL
|   |   |   |    \--MY-MAPCAR returned (CINQ)
|   |   |    \--MY-MAPCAR returned (QUATRE CINQ)
|   |    \--MY-MAPCAR returned (TROIS QUATRE CINQ)
|    \--MY-MAPCAR returned (DEUX TROIS QUATRE CINQ)
 \--MY-MAPCAR returned (UN DEUX TROIS QUATRE CINQ)
(UN DEUX TROIS QUATRE CINQ)


The function that we supply to MY-MAPCAR must be a function of one input,
  since that's how many inputs it will be FUNCALLed with.


EXERCISE
8.64 Write  a TREE-FIND-IF operator that returns the first non-NIL atom
       of a tree that satisfies a predicate.

A tree looks like this.

S> (list '((2 4) (5 6) 7))

[*|*]--->NIL
 |
 v
[*|*]------------------>[*|*]------------------>[*|*]--->NIL
 |                       |                       |
 v                       v                       v
[*|*]--->[*|*]--->NIL   [*|*]--->[*|*]--->NIL    7
 |        |              |        |
 v        v              v        v
 2        4              5        6

Result:  (((2 4) (5 6) 7))


(defun tree-find-if (pred tree)
  "Our version of FIND-IF."
  (cond ((and tree
              (atom tree)
              (funcall pred tree))
         tree)
        ((atom tree) nil)
        (t (or (tree-find-if
                pred (car tree))
               (tree-find-if
                pred (cdr tree))))))

CL-USER> (tree-find-if #'oddp '((2 4) (5 6) 7))
----Enter TREE-FIND-IF
|     Arg-1 = #<FUNCTION ODDP>
|     Arg-2 = ((2 4) (5 6) 7)
|   ----Enter TREE-FIND-IF
|   |     Arg-1 = #<FUNCTION ODDP>
|   |     Arg-2 = (2 4)
|   |   ----Enter TREE-FIND-IF
|   |   |     Arg-1 = #<FUNCTION ODDP>
|   |   |     Arg-2 = 2
|   |    \--TREE-FIND-IF returned NIL
|   |   ----Enter TREE-FIND-IF
|   |   |     Arg-1 = #<FUNCTION ODDP>
|   |   |     Arg-2 = (4)
|   |   |   ----Enter TREE-FIND-IF
|   |   |   |     Arg-1 = #<FUNCTION ODDP>
|   |   |   |     Arg-2 = 4
|   |   |    \--TREE-FIND-IF returned NIL
|   |   |   ----Enter TREE-FIND-IF
|   |   |   |     Arg-1 = #<FUNCTION ODDP>
|   |   |   |     Arg-2 = NIL
|   |   |    \--TREE-FIND-IF returned NIL
|   |    \--TREE-FIND-IF returned NIL
|    \--TREE-FIND-IF returned NIL
|   ----Enter TREE-FIND-IF
|   |     Arg-1 = #<FUNCTION ODDP>
|   |     Arg-2 = ((5 6) 7)
|   |   ----Enter TREE-FIND-IF
|   |   |     Arg-1 = #<FUNCTION ODDP>
|   |   |     Arg-2 = (5 6)
|   |   |   ----Enter TREE-FIND-IF
|   |   |   |     Arg-1 = #<FUNCTION ODDP>
|   |   |   |     Arg-2 = 5
|   |   |    \--TREE-FIND-IF returned 5
|   |    \--TREE-FIND-IF returned 5
|    \--TREE-FIND-IF returned 5
 \--TREE-FIND-IF returned 5
5

Note that the second branch houses the terminal call.
  That branch contains the return value.



---
8.18 THE LABELS SPECIAL FUNCTION

Up to now we have been writing helping functions as separate DEFUNs.
  This is considered sloppy since the function may be called at top-level mistakenly.

The more serious reason to why we don't define helping functions at top-level
  is because functions defined with DEFUN cannot access any of the main functions
    local variables

Both of these problems can be solved with LABELS.


The LABELS special function allows us to establish local function definitions
  inside the body of the main function,
    just as LET allows us to establish local variables.

The syntax of the two forms is similar:

(LABELS ((fn-1 args-1 body-1)
          ...
         (fn-n args-2 body-2))
  body)


The body can call any of the local functions.

The local functions can call each other and can reference their parent's variables.


In the following example, notice that COUNT-UP-RECURSIVELY references N,
  the input to COUNT-UP:

(defun count-up-recursively (n)
  (labels ((count-up-recursively (cnt)
             (if (> cnt n) nil
                 (cons cnt
                       (count-up-recursively
                        (+ cnt 1))))))
    (count-up-recursively 1)))

One disadvantage of using LABELS is that in most Lisp implementations,
  there is no way to trace functions that are defined inside a LABELS expression.

STEP can still be called to step through evaluation manually.


EXERCISE
8.65 Use LABELS to write versions of TR-COUNT-SLICES and TR-REVERSE.

(defun tr-count-slices (x)
  "Uses LABELS to embed the helper function within the function body definition."
  (labels ((trc1 (x n)
             (if x
                 (trc1 (rest x)
                       (+ n 1))
                 n)))
    (trc1 x 0)))

(defun tr-reverse (lst)
  "Uses LABELS to embed the helper function."
  (labels ((trrev1 (lst result)
             (if lst
                 (trrev1 (rest lst)
                          (cons (first lst) result))
                 result)))
    (trrev1 lst nil)))



---
8.19 RECURSIVE DATA STRUCTURES

Data structures may also have recursive definitions.

Consider the following definition of an S-expression (symbolic expression):

  "An S-expression is either an atom, or a cons cell whose
    CAR and CDR parts are S-expressions."

The term S-expression is used inside of its own definition.
  It is a recursive definition.

S-expressions are instances of a very common recursive data structure,
  with important applications in all areas of computer science,
    called a tree.

Here is another example of a tree, this time representing an arithmetic expression:

                                       -
                                     /   \
                                    /     \
                                   +       +
                                  / \     / \
                                 3   5   8   6

The bottom nodes of the tree are called terminal nodes
  because they have no branches descending from them.

Remaining nodes are called non-terminal nodes.

A tree can be defined recursively just as S-expressions were:

  "A tree is either a single or terminal node,
    or a non-terminal node whose branches are trees."

Trees are naturally represented by lists.

The tree above corresponds to the list ((3 + 5) - (8 + 6)).


Let's look at another arithmetic expression tree:

                                       -
                                     /   \
                                    /     \
                                   +       *
                                  / \     / \
                                 2   2   3   *
                                            / \
                                           /   /
                                          4   / \
                                             12  6

This tree illustrates the fact that the branches of a nonterminal node need
  not be of the same length.

The list representation of this tree is ((2 + 2) - (3 * (4 * (12 / 6)))).

We can define arithmetic expressions recursively as:

  "An arithmetic expression is either a number,
    or a three-element list whose first and third elements
      are arithmetic expressions and whose middle elements is one of:
        + - * / ."


EXERCISES
8.66 Write ARITH-EVAL, a function that evaluates arithmetic expressions.

(defun arith-eval (exp)
  "Evaluates arithmetic expressions."
  (cond ((numberp exp) exp)
        (t (funcall (second exp)
                    (arith-eval (first exp))
                    (arith-eval (third exp))))))


8.67 Write a predicate LEGALP that returns T if its input
       is a legal arithmetic expression.

(defun legalp (exp)
  "Tests whether its input is a legal arithmetic expression."
  (cond ((numberp exp) t)
        ((atom exp) nil)
        (t (and (equal (length exp) 3)
                (legalp (first exp))
                (member (second exp)
                        '(+ - * /))
                (legalp (third exp))))))

The T is the end-clause because COND evaluates the NIL part of the expression.

CL-USER> (legalp '((2 * 2) - 3))
----Enter LEGALP
|     Arg-1 = ((2 * 2) - 3)
|   ----Enter LEGALP
|   |     Arg-1 = (2 * 2)
|   |   ----Enter LEGALP
|   |   |     Arg-1 = 2
|   |    \--LEGALP returned T
|   |   ----Enter LEGALP
|   |   |     Arg-1 = 2
|   |    \--LEGALP returned T
|    \--LEGALP returned T
|   ----Enter LEGALP
|   |     Arg-1 = 3
|    \--LEGALP returned T
 \--LEGALP returned T
T


8.68 A "proper list" is a cons cell chain ending in NIL.
       Lists that are not proper lists are called dotted lists,
         because they must be written with a dot.
       If we wanted to define the concept of proper list recursion,
         we could say "NIL is a proper list, and so is any cons cell whose ..."
     Fill in the rest of the definition.

"... cdr is a proper list."


8.69 Of the positive integers greater than one, some are primes other are not.
       Primes are numbers divisible only by themselves and 1.
       Non-primes or composite numbers can always be factored into primes.
         Here is a factorization tree for the number 60 that was
           obtained by successive divisions by primes:

                                   60
                                  /  \
                                 2   30
                                    /  \
                                   2   15
                                      /  \
                                     3    5

     The number 60 has factors 2, 2, 3, and 5, 60=2*2*3*5.
       Write a recursive definition for positive integers greater than one
         in terms of prime numbers.

"A positive integer greater than one is either a prime,
  or the product of a prime and a positive integer greater than one."


8.70 Following is a function FACTORS that returns the list of prime factors of a number.
       It uses the built-in REM function to compute the remainder
         of dividing one number by the other.

(defun factors (n)
  "Returns the list of prime factors of a number."
  (factors-help n 2))

(defun factors-help (n p)
  "Helper function to FACTORS."
  (cond ((equal n 1) nil)
        ((zerop (rem n p))
         (cons p (factors-help (/ n p) p)))
        (t (factors-help n (+ p 1)))))

     Try tracing the helper function to see the process.
       Write a similar function, FACTOR-TREE, that returns a factorization tree instead.

(defun factor-tree (n)
  "Returns the factor tree of N as a list."
  (factor-tree-help n 2))

(defun fact-tree-help (n p)
  "Helper function to FACTOR-TREE."
  (cond ((equal n p) n)
        ((zerop (rem n p))
         (list n p (fact-tree-help (/ n p) p)))
        (t (fact-tree-help n (+ p 1)))))

CL-USER> (factor-tree 60)
----Enter FACTOR-TREE
|     Arg-1 = 60
|   ----Enter FACT-TREE-HELP
|   |     Arg-1 = 60
|   |     Arg-2 = 2
|   |   ----Enter FACT-TREE-HELP
|   |   |     Arg-1 = 30
|   |   |     Arg-2 = 2
|   |   |   ----Enter FACT-TREE-HELP
|   |   |   |     Arg-1 = 15
|   |   |   |     Arg-2 = 2
|   |   |   |   ----Enter FACT-TREE-HELP
|   |   |   |   |     Arg-1 = 15
|   |   |   |   |     Arg-2 = 3
|   |   |   |   |   ----Enter FACT-TREE-HELP
|   |   |   |   |   |     Arg-1 = 5
|   |   |   |   |   |     Arg-2 = 3
|   |   |   |   |   |   ----Enter FACT-TREE-HELP
|   |   |   |   |   |   |     Arg-1 = 5
|   |   |   |   |   |   |     Arg-2 = 4
|   |   |   |   |   |   |   ----Enter FACT-TREE-HELP
|   |   |   |   |   |   |   |     Arg-1 = 5
|   |   |   |   |   |   |   |     Arg-2 = 5
|   |   |   |   |   |   |    \--FACT-TREE-HELP returned 5
|   |   |   |   |   |    \--FACT-TREE-HELP returned 5
|   |   |   |   |    \--FACT-TREE-HELP returned 5
|   |   |   |    \--FACT-TREE-HELP returned (15 3 5)
|   |   |    \--FACT-TREE-HELP returned (15 3 5)
|   |    \--FACT-TREE-HELP returned (30 2 (15 3 5))
|    \--FACT-TREE-HELP returned (60 2 (30 2 (15 3 5)))
 \--FACTOR-TREE returned (60 2 (30 2 (15 3 5)))
(60 2 (30 2 (15 3 5)))


8.71 The trees for arithmetic expressions are called binary trees,
       because each non-terminal node has exactly two branches.
         Any list can be viewed as a binary tree.

     Draw a binary tree representing the cons cell structure of the
       list (A B (C D) E).

     What are the terminal nodes?

(cons 'a (cons 'b (append '((cd)) '(e))))

CL-USER> (sdraw-loop)
Type any Lisp expression, or :ABORT to exit.

S> (cons 'a (cons 'b (append '((c d)) '(e))))

[*|*]--->[*|*]--->[*|*]------------------>[*|*]--->NIL
 |        |        |                       |
 v        v        v                       v
 A        B       [*|*]--->[*|*]--->NIL    E
                   |        |
                   v        v
                   C        D

Result:  (A B (C D) E)

To view the diagram as a binary tree instead of a list,
  turn the book 45-degrees clockwise.

The terminal nodes of the tree are the atoms A B C D E and NIL.
  The non-terminal nodes are the cons cells.


8.72 More abstract tree types are possible,
       in which different nodes have a different number of branches.

     Pick some concept or object and describe it in terms of a general tree structure.

The SSP in the Marine Corps resembled a tree structure.

                                 Captain
                                    |
                               Platoon Sgt
                                 /     \
                                TL     TL
                               /  \   /  \
                              T    T T    T

Non-terminal nodes Captain, Platoon Sergeant, Team Lead.
Terminal nodes being the Troops the Team Lead is in charge of.



***
9 Input/Output

---
9.1 INTRODUCTION

Input/output, or i/o, is the way a computer communicates with the world.

Lisp's read-eval-print loop provides a simple kind of i/o.
  It reads expressions from the keyboard and prints the results on the display.

We may want more sometimes.

We can create feedback systems through input/output.

Another use for i/o functions is to read data from a disk file,
  or write data into a file so we can read it back some other day.



---
9.2 CHARACTER STRINGS

In order to get the computer to print informative messages on display,
  we need to know what character strings are.

Character strings (strings for short) are a type of sequence;
  they are similar in some ways to lists, and are a subtype of vectors,
    but they have a different set of primitive operations.


Strings evaluate to themselves as numbers do.

CL-USER> "strings are things"
"strings are things"


Strings are not symbols.

The STRINGP predicate returns T if its input is a string:

CL-USER> (describe 'stringp)
COMMON-LISP:STRINGP
  [symbol]

STRINGP names a compiled function:
  Lambda-list: (SB-IMPL::OBJECT)
  Declared type: (FUNCTION (T) (VALUES BOOLEAN &OPTIONAL))
  Documentation:
    Return true if OBJECT is a STRING, and NIL otherwise.
  Known attributes: foldable, flushable, unsafely-flushable, movable, predicate
  Source file: SYS:SRC;CODE;PRED.LISP
; No value
CL-USER> (stringp "strings are things")
T
CL-USER> (setf string-a "Strings are Lisp objects.")
"Strings are Lisp objects."
CL-USER> (stringp string-a)
T
CL-USER> (setf symbol-a 'this-object-is-a-symbol)
THIS-OBJECT-IS-A-SYMBOL
CL-USER> (stringp symbol-a)
NIL


Character strings must be enclosed in double quotation characters (").

*Note* The apostrophe (') is used to quote symbols and lists.



---
9.3 THE FORMAT FUNCTION

The FORMAT function normally returns NIL,
  but as a side effect it causes things to be written on display or to a file.

The first argument to FORMAT should be the symbol T when we want output to the display.
  (Different values are used when writing to a disk file.)

The second argument to FORMAT must be a string,
  called the format control string.
    FORMAT writes the string (without the quotes) and then returns NIL:

CL-USER> (format t "Carpets in the furnace.")
Carpets in the furnace.
NIL


The format control string can also contain special formatting directives,
  which begin with a tilde, "~," character.

For example, the ~% directive causes FORMAT to move to a new line.
  Two ~% directives right next to each other result in a blank line in the output.

CL-USER> (format t "Time flies~%like an arrow.")
Time flies
like an arrow.
NIL
CL-USER> (format t "Fruit flies~%~%like bananas.")
Fruit flies

like bananas.
NIL

CL-USER> (format t "My boots came~%  undid~%    and i tripped.")
My boots came
  undid
    and i tripped.
NIL
CL-USER> (format t "One line~%~%skipped.")
One line

skipped.
NIL


The ~& directive tells FORMAT to move to a new line
  unless it knows it is already at the beginning of a new line.
    So two or three successive ~& directives have the same effect as a single one.

The ~& directive is useful because we don't always know where our cursor will have
  been left off when our function gets called.

In programs that produce several lines of output,
  it is best practice to begin each line with the ~& directive
    so that the cursor is guaranteed to be on a fresh line before printing each message.

CL-USER> (defun mary ()
           (format t "~&Mary had a little bat.")
           (format t "~&Its wings were long and brown.")
           (format t "~&And everywhere that Mary went")
           (format t "~&the bat went, upside down."))
MARY
CL-USER> (mary)
Mary had a little bat.
Its wings were long and brown.
And everywhere that Mary went
the bat went, upside down.
NIL


Another important formatting directive is ~S,
  which inserts the printed representation of a Lisp object
    into the message that FORMAT prints.

  The S stands for S-expression (symbolic expression),
    the archaic term for a Lisp object.

For each occurrence of ~S in the format control string,
  FORMAT  requires one extra argument.
    The extra argument is what takes the place of ~S once the form is evaluated.

CL-USER> (format t "From ~S to ~S in ~S minutes."
                 'Houston '(Austin) 90)
From HOUSTON to (AUSTIN) in 90 minutes.
NIL


CL-USER> (defun square-talk (n)
           "Takes a number as input. Contains a string telling the square of that number."
           (format t "~&~S squared is ~S" n (* n n)))
SQUARE-TALK
CL-USER> (square-talk 5)
5 squared is 25
NIL


SQUARE-TALK takes a number as input
  and tells you the square of that number.

It does not return the square;
  it returns NIL because that is the result returned by FORMAT.

SQUARE-TALK takes a number as input
  and TELLS you the square of that number through the data it contains.

SQUARE-TALK does not return, I repeat,
  SQUARE-TALK does not return the square of a number;
    it returns NIL because that is the result returned by FORMAT.


CL-USER> (mapcar #'square-talk '(1 2 3 4 5))
1 squared is 1
2 squared is 4
3 squared is 9
4 squared is 16
5 squared is 25
(NIL NIL NIL NIL NIL)


The result returned by MAPCAR is a list of NILs;
  each call to SQUARE-TALK returns NIL.


The ~A directive prints an object without using escape characters.

The easiest way to explain this is to compare how ~A and ~S print strings.

~S  includes the quotation marks, whereas ~A does not.

A quotation mark is one kind of escape character.

CL-USER> (test "Floppy nips.")
With escape characters: "Floppy nips."
Without escape characters: Floppy nips.
NIL


EXERCISES
9.1 Write a function to print the following saying on the display:

      "There are old pilots, and there are bold pilots,
         but there are no old bold pilots."

    Your function should break up the quotation into several lines.

CL-USER> (defun they-dont-exist ()
  "Takes no input."
  (format t "~&There are old pilots,")
  (format t "~&  and there are bold pilots,")
  (format t "~&    but there are no old bold pilots."))
THEY-DONT-EXIST
CL-USER> (they-dont-exist)
There are old pilots,
  and there are bold pilots,
    but there are no old bold pilots.
NIL

*The book has a different answer.*

CL-USER> (defun saying ()
           "Takes no input."
           (format t "~&There are old pilots,~%")
           (format t "and there are bold pilots,~%")
           (format t "but there are no old bold pilots.~%"))
SAYING
CL-USER> (saying)
There are old pilots,
and there are bold pilots,
but there are no old bold pilots.
NIL


9.2 Write a recursive function DRAW-LINE that draws a line of a specified length
      by doing (FORMAT T "*") the correct number of times.

(defun draw-line (n)
  "Draws a line of *'s specified by input."
  (cond ((zerop n) (format t "~%"))
        (t n (format t "*") (draw-line (- n 1)))))

CL-USER> (draw-line 5)
*****
NIL


9.3 Write a recursive function DRAW-BOX that calls DRAW-LINE
      repeatedly to draw a box of specified dimensions.

(defun draw-box (width height)
  "Draws a * box of specified width and height."
  (cond ((zerop height) nil)
        (t (draw-line width)
           (draw-box width (- height 1)))))

Func: DRAW-BOX
End-test: (zerop height)
End-value: NIL
Reduced-x: (- HEIGHT 1)

CL-USER> (draw-box 5 5)
*****
*****
*****
*****
*****
NIL


9.4 Write a recursive function NINETY-NINE-BOTTLES that sings the song
      "Ninety-nine Bottles of Beer on the Wall."

    NINETY-NINE-BOTTLES should take a number N as input and start counting from N to zero.
      The function should leave a blank line between each verse,
        and say something appropriate when it runs out of beer.

(defun ninety-nine-bottles (n)
  "Prints the verses to 99 Bottles of Beer."
  (cond ((zerop n)
         (format t "~&Awww, no more beer!"))
        (t (do-verse n)
           (ninety-nine-bottles (- n 1)))))

(defun do-verse (n)
  "Does the verse N times."
  (format t "~&~S bottles of beer on the wall,~%" n)
  (format t "~S bottles of beer!~%" n)
  (format t "Ohh take one down,~%Pass it around,~%")
  (format t "~S bottles of beer on the wall.~%~%"
          (- n 1)))

CL-USER> (defun do-verse (n)
           "Do the verse N times."
           (format t "~&~S bottles of beer on the wall,~%" n)
           (format t "~S bottles of beer!~%" n)
           (format t "Ohh take one down,~%Pass it around,~%")
           (format t "~S bottles of beer on the wall.~%~%"
                   (- n 1)))
DO-VERSE
CL-USER> (defun ninety-nine-bottles (n)
           "Prints the verses to 99 Bottles of Beer."
           (cond ((zerop n)
                  (format t "~&Awww, no more beer!"))
                 (t (do-verse n)
                    (ninety-nine-bottles (- n 1)))))
NINETY-NINE-BOTTLES
CL-USER> (ninety-nine-bottles 3)
3 bottles of beer on the wall,
3 bottles of beer!
Ohh take one down,
Pass it around,
2 bottles of beer on the wall.

2 bottles of beer on the wall,
2 bottles of beer!
Ohh take one down,
Pass it around,
1 bottles of beer on the wall.

1 bottles of beer on the wall,
1 bottles of beer!
Ohh take one down,
Pass it around,
0 bottles of beer on the wall.

Awww, no more beer!
NIL


9.5 Part of any tic-tac-toe playing program is a function to display the board.
      Write a function PRINT-BOARD that takes a list of nine elements as input.
        Each element will be an X, an O, or NIL.

(defun print-board (b)
  "Takes the moves of a tic-tac-toe game and prints the diagram of the match."
  (let ((b2 (sublis '((x    . "X")
                      (o    . "O")
                      (nil  . " "))
                    b)))
    (format t "~&")
    (print-line b2)
    (format t "-----------~%")
    (print-line (nthcdr 3 b2))
    (format t "-----------~%")
    (print-line (nthcdr 6 b2))))

(defun print-line (line)
  "Prints a line for PRINT-BOARD."
  (format t " ~A | ~A | ~A~%"
          (first line)
          (second line)
          (third line)))

CL-USER> (defun print-line (line)
           "Prints a line for PRINT-BOARD."
           (format t " ~A | ~A | ~A~%"
                   (first line)
                   (second line)
                   (third line)))
PRINT-LINE
CL-USER> (defun print-board (b)
  "Takes the moves of a tic-tac-toe game and prints the diagram of the match."
  (let ((b2 (sublis '((x    . "X")
                      (o    . "O")
                      (nil  . " "))
                    b)))
    (format t "~&")
    (print-line b2)
    (format t "-----------~%")
    (print-line (nthcdr 3 b2))
    (format t "-----------~%")
    (print-line (nthcdr 6 b2))))

PRINT-BOARD
CL-USER> (print-board '(x o o nil x nil o nil x))
 X | O | O
-----------
   | X |  
-----------
 O |   | X
NIL

SUBLIS takes a specified alist (the first input) and substitutes
  it into the specified tree (the second input).


---
9.4 THE READ FUNCTION
 
READ is a function that reads one Lisp object from the keyboard
  and returns that object as its value.
    Nothing is evaluated.

The object does not have to be quoted because it will not be evaluated.

By placing calls to READ within a function,
  we can make the computer read data from the keyboard under program control.

(defun my-square ()
  "Prompts for a number, returns a string stating the square of it."
  (format t "Please type in a number: ")
  (let ((x (read)))
    (format t "The number ~S squared is ~S.~%"
            x (* x x))))

CL-USER> (my-square)
Please type in a number: 4
The number 4 squared is 16.
NIL
CL-USER> (my-square)
Please type in a number: -3
The number -3 squared is 9.
NIL


EXERCISES

9.6 Write a function to compute an hourly workers gross pay
      given an hourly wage in dollars and number of hours worked.

    The function should prompt for each input it needs by printing a message in
      English. It should display its answer in English as well.

(defun compensation ()
  "Computes the compensation of an hourly worker. Prompts name, wage, hours worked."
  (format t "~&Name of employee: ")
  (let ((name (read)))
    (format t "~&Employee hourly wage: ")
    (let ((wage (read)))
      (format t "~&Employee hours worked: ")
      (let ((hours (read)))
        (format t "~&~S earned ~S dollars."
                name (* wage hours))))))

CL-USER> (compensation)
Name of employee: tylerbrw

Employee hourly wage: 20

Employee hours worked: 40

TYLERBRW earned 800 dollars.
NIL


9.7 The COOKIE-MONSTER function continues to read data from the terminal
      until it reads the symbol COOKIE. Write it.

(defun cookie-monster ()
  "It only wants a cookie."
  (format t "Give me cookie!!!~%Cookie? ")
  (let ((response (read)))
    (cond ((equal response 'cookie)
           (format t "~&Thank you!")
           (format t "...Munch, munch, munch")
           (format t "... BURP"))
          (t (format t "~&No want ~S...~%~%"
                     response)
             (cookie-monster)))))

CL-USER> (cookie-monster)
Give me cookie!!!
Cookie? banana

No want BANANA...

Give me cookie!!!
Cookie? cookie

Thank you!...Munch, munch, munch... BURP
NIL



---
9.5 THE YES-OR-NO-P FUNCTION

The YES-OR-NO-P function takes a format control string as input
  and asks the user a yes or no question.

The user must respond by typing yes or no;
  the function returning T or NIL respectively.

(defun riddle ()
  (if (yes-or-no-p
       "Do you seek Zen enlightenment? ")
      (format t "Then do not ask for it!")
      (format t "You have found it.")))



---
9.6 READING FILES WITH WITH-OPEN-FILE

The WITH-OPEN-FILE macro provides a convenient way to read data from a file.
  The syntax is as follows:

    (WITH-OPEN-FILE (var pathname)
      body)


WITH-OPEN-FILE creates a local variable (just like LET)
  and sets it to a stream-object representing a connection to that file.

Stream objects are a special Lisp data-type for describing connections to files.

The *TERMINAL-IO* global variable is a stream-object.
  It holds the stream object Lisp uses to read from the keyboard
    and write to display:

CL-USER> *terminal-io*
#<TWO-WAY-STREAM
  :INPUT-STREAM #<SWANK/GRAY::SLIME-INPUT-STREAM {1004081363}>
  :OUTPUT-STREAM #<SWANK/GRAY::SLIME-OUTPUT-STREAM {10041D9873}>>


Within the body of WITH-OPEN-FILE the stream object can be passed as an optional
  argument to READ to read data from the file instead of from the keyboard.
    When leaving the WITH-OPEN-FILE form,
      the connection to the file is closed automatically.

Let's try an example of reading data from a file.

Suppose the file  timber.dat  in the directory  /usr/dst contains these lines:

  "The North Slope"
  Sapling
  ((45 redwood) (12 oak) (43 maple))
  100


We can read this data with the following program:

(defun get-tree-data ()
  "Gets the tree data from timber.dat"
  (with-open-file (stream "c:/Users/tylerbrw/Documents/lisp/references/an-introduction/timber.dat")
    (let* ((tree-loc (read stream))
           (tree-stage (read stream))
           (tree-table (read stream))
           (tree-total (read stream)))
      (format t "~&There are ~S trees on ~S."
              tree-total tree-loc)
      (format t "~&Tree types include: ~S"
              tree-table)
      (format t "~&Growth stage group: ~S"
              tree-stage))))

CL-USER> (get-tree-data)
There are 100 trees on "The North Slope".
Tree types include: ((45 REDWOOD) (12 OAK) (43 MAPLE))
Growth stage group: SAPLING
NIL



---
9.7 WRITING FILES WITH WITH-OPEN-FILE

We can also use WITH-OPEN-FILE to open files for output
  by passing it the special keyword argument :DIRECTION :OUTPUT.

The stream that WITH-OPEN-FILE creates can then be used
  in place of the usual T as a first argument to FORMAT.

(defun save-tree-data (tree-loc tree-stage
                       tree-table tree-total)
  "Takes the tree data, streams the data as output to the timber.newdat file."
  (with-open-file (stream "c:/Users/tylerbrw/Documents/lisp/references/an-introduction/timber.newdat"
                          :direction :output)
    (format stream "~S~%" tree-loc)
    (format stream "~S~%" tree-stage)
    (format stream "~S~%" tree-table)
    (format stream "~S~%" tree-total)))

(defun get-tree-data ()
  "Gets the tree data from timber.dat"
  (with-open-file (stream "c:/Users/tylerbrw/Documents/lisp/references/an-introduction/timber.newdat")
    (let* ((tree-loc (read stream))
           (tree-stage (read stream))
           (tree-table (read stream))
           (tree-total (read stream)))
      (format t "~&There are ~S trees on ~S."
              tree-total tree-loc)
      (format t "~&Tree types include: ~S"
              tree-table)
      (format t "~&Growth stage group: ~S"
              tree-stage))))

CL-USER> (save-tree-data
          "The West Ridge"
          'Prime-of-life
           '((45 redwood) (22 oak) (43 maple))
          110)
NIL
CL-USER> (get-tree-data)
There are 110 trees on "The West Ridge".
Tree types include: ((45 REDWOOD) (22 OAK) (43 MAPLE))
Growth stage group: PRIME-OF-LIFE
NIL


If we write data to a file using just the ~S directive,
  we are assured of being able to read it back in again.

It is also possible to write arbitrary messages to a file,
  containing strange punctuation, unbalanced parenthesis, etc ...
    but we would not be able to read the file back into Lisp using READ.

Such files may still be useful for being read by people,
  and can be read by Lisp one character at a time using advanced techniques.


SUMMARY

The FORMAT function takes two or more arguments.
  The first argument should be T to print on the display;
    the second must be a format-control-string.
      The remaining arguments are used to fill in information required by
        the ~S and ~A directives.
          The ~% directive begins a new line only if not already at
            the beginning of a new line.

The READ function reads one Lisp object from the terminal and returns that object.
  The object does not have to be quoted because it will not be evaluated.

YES-OR-NO-P and Y-OR-N-P print questions (using format control string) and
  then return T or NIL depending on the users answer.

WITH-OPEN-FILE opens a file for either input or output,
  and binds a local variable to a stream object
    that represents the connection to that file.
      This stream object can be passed to READ or FORMAT to do file i/o.


REVIEW EXERCISES
9.8 How are strings different from symbols?

Strings and symbols are different types of Lisp objects,
  just as a number is not a symbol or string.


9.9 What is printed by each of the following?

CL-USER> (format t "a~S" 'b)
aB
NIL
CL-USER> (format t "always~%broke")
always
broke
NIL
CL-USER> (format t "~S~S" 'alpha 'bet)
ALPHABET
NIL


FUNCTIONS COVERED
String predicate: STRINGP
Input/Output functions: FORMAT READ YES-OR-NO-P Y-OR-N-P
Macro for simple file i/o: WITH-OPEN-FILE


##
Keyboard Exercise

In this exercise we will write a program for producing a graph of an arbitrary function.

The program will prompt for a function name F and then plot y=F(x)
  for a specified range of x values.

EXERCISE
9.10 As you write each of the following functions,
       test each one by calling it from top-level with appropriate inputs
         before proceeding to the next function.

a. Write a recursive function SPACE-OVER that takes a number N as input
     and moves the cursor to the right by printing N spaces, one-at-a-time.

(defun space-over (n)
  "Moves point N-spaces to the right."
  (cond ((plusp n)
         (format t " ")
         (space-over (- n 1)))
        ((zerop n) nil)
        (t (format t "Error!"))))

   We can test our function with the TEST function:
(defun test (n)
  "Testing function for space over."
  (format t "~%>>>")
  (space-over n)
  (format t "<<<"))

CL-USER> (space-over 5)
     
NIL
CL-USER> (space-over " ")
; Evaluation aborted on #<TYPE-ERROR expected-type: NUMBER datum: " ">.
CL-USER> (space-over -5)
Error!
NIL
CL-USER> (test 5)

>>>     <<<
NIL
CL-USER> (test -5)

>>>Error!<<<
NIL
CL-USER> (test 5)
----Enter TEST
|     Arg-1 = 5
>>>
|   ----Enter SPACE-OVER
|   |     Arg-1 = 5 
|   |   ----Enter SPACE-OVER
|   |   |     Arg-1 = 4 
|   |   |   ----Enter SPACE-OVER
|   |   |   |     Arg-1 = 3 
|   |   |   |   ----Enter SPACE-OVER
|   |   |   |   |     Arg-1 = 2 
|   |   |   |   |   ----Enter SPACE-OVER
|   |   |   |   |   |     Arg-1 = 1 
|   |   |   |   |   |   ----Enter SPACE-OVER
|   |   |   |   |   |   |     Arg-1 = 0
|   |   |   |   |   |    \--SPACE-OVER returned NIL
|   |   |   |   |    \--SPACE-OVER returned NIL
|   |   |   |    \--SPACE-OVER returned NIL
|   |   |    \--SPACE-OVER returned NIL
|   |    \--SPACE-OVER returned NIL
|    \--SPACE-OVER returned NIL<<<
 \--TEST returned NIL
NIL

*Reminder* FORMAT returns NIL

CL-USER> (test-two 0)
>>><<<
NIL
CL-USER> (test-two 1)
>>> <<<
NIL


b. Write a function PLOT-ONE-POINT that takes two inputs,
     PLOTTING-STRING and Y-VAL, prints PLOTTING-STRING (without quotes)
       in column Y-VAL, and then moves to a new line.
         The leftmost column is numbered zero.

(defun plotting-string ()
  "String to be plotted in PLOT-ONE-POINT."
  (format t "PLOTTING-STRING"))

(defun plot-one-point (plotting-string y-val)
  "Plots a string on a list of y-axes. Each y-axis listed creates a new line."
  (space-over y-val)
  (format t "~A~%" plotting-string))


*COME BACK TO THIS*



---
Lisp Toolkit: DRIBBLE

The DRIBBLE function records part of a Lisp session in a file.
  Useful for reviewing or making printouts.

Given a filename as an argument, DRIBBLE opens that file for output and starts recording.
  If called with no arguments, it closes the file in which it was recording.



---
9 Advanced Topics


9.8 PARAMETERS TO FORMAT DIRECTIVES

Some format directives accept prefix parameters that further specify their behavior.

Prefix parameters appear between the ~ and the directive.

For example, the ~S directive accepts a width parameter.
  By using an explicit width, like ~10S, we can produce columnar output:

CL-USER> (setf glee-club
               '((john smith) (barbara wilson)
                 (mustapha ali) (shalala lalabalalala)
                 (tyler brandon) (shepherd axel)))
((JOHN SMITH) (BARBARA WILSON) (MUSTAPHA ALI) (SHALALA LALABALALALA)
 (TYLER BRANDON) (SHEPHERD AXEL))
CL-USER> (print-one-name (first glee-club))
SMITH      JOHN
NIL
CL-USER> (defun print-one-name (name)
           "Takes the second and first of the top-level elements, in this case NAMEs."
           (format t "~&~10S ~S"
                   (second name)
                   (first name)))
PRINT-ONE-NAME
CL-USER> (print-one-name glee-club)
(BARBARA WILSON) (JOHN SMITH)
NIL
CL-USER> (defun print-all-names (alist)
           "Prints all the top-level elements from the ALIST, in this case they are names."
           (mapcar #'print-one-name alist)
           'done)
PRINT-ALL-NAMES
CL-USER> (print-all-names glee-club)
SMITH      JOHN
WILSON     BARBARA
ALI        MUSTAPHA
LALABALALALA SHALALA
BRANDON    TYLER
AXEL       SHEPHERD
KRUEGER    STEPHEN
DONE
CL-USER> (dtrace print-one-name print-all-names)
(PRINT-ONE-NAME PRINT-ALL-NAMES)
CL-USER> (print-all-names glee-club)
----Enter PRINT-ALL-NAMES
|     Arg-1 = ((JOHN SMITH) (BARBARA WILSON) (BILL CLINTON) (BARRACK OBAMA) (ALI MUSTAPHA) (SHALALA LALABALALA) (TYLER BRANDON) ...)
|   ----Enter PRINT-ONE-NAME
|   |     Arg-1 = (JOHN SMITH)
SMITH      JOHN
|    \--PRINT-ONE-NAME returned NIL
|   ----Enter PRINT-ONE-NAME
|   |     Arg-1 = (BARBARA WILSON)
WILSON     BARBARA
|    \--PRINT-ONE-NAME returned NIL
|   ----Enter PRINT-ONE-NAME
|   |     Arg-1 = (BILL CLINTON)
CLINTON    BILL
|    \--PRINT-ONE-NAME returned NIL
|   ----Enter PRINT-ONE-NAME
|   |     Arg-1 = (BARRACK OBAMA)
OBAMA      BARRACK
|    \--PRINT-ONE-NAME returned NIL
|   ----Enter PRINT-ONE-NAME
|   |     Arg-1 = (ALI MUSTAPHA)
MUSTAPHA   ALI
|    \--PRINT-ONE-NAME returned NIL
|   ----Enter PRINT-ONE-NAME
|   |     Arg-1 = (SHALALA LALABALALA)
LALABALALA SHALALA
|    \--PRINT-ONE-NAME returned NIL
|   ----Enter PRINT-ONE-NAME
|   |     Arg-1 = (TYLER BRANDON)
BRANDON    TYLER
|    \--PRINT-ONE-NAME returned NIL
|   ----Enter PRINT-ONE-NAME
|   |     Arg-1 = (SHEPHERD AXEL)
AXEL       SHEPHERD
|    \--PRINT-ONE-NAME returned NIL
 \--PRINT-ALL-NAMES returned DONE
DONE



---
9.9 ADDITIONAL FORMAT DIRECTIVES

The ~D directive prints an integer in decimal notation (base 10, bitch.)
  It is also possible to print numbers in other bases, even roman numerals.

The ~F directive prints floating point numbers in a fixed-format notation
  that always includes a decimal point.

All of these directives take prefix parameters.

The first prefix parameter is used to specify a fixed-width for the output,
  how many characters it should take up.
    Lisp will pad the output with blanks if neccessary.

With the ~F directive a second prefix parameter specifies how many digits are to appear
  after the decimal point:

CL-USER> (defun sevenths (nums)
           "Give it NUMS, translates them into a 7-character field with 5 decimal spaces."
           (mapcar #'(lambda (numerator)
                       (format t "~&~4,2F / 7 is ~7,5F"
                               numerator
                               (/ numerator 7.0)))
                   nums)
           'done)
SEVENTHS
CL-USER> (sevenths '(1 3/2 2 2.5 3))
1.00 / 7 is 0.14286
1.50 / 7 is 0.21429
2.00 / 7 is 0.28571
2.50 / 7 is 0.35714
3.00 / 7 is 0.42857
DONE



---
9.10 THE LISP 1.5 OUTPUT PRIMITIVES

The primitive i/o functions TERPRI, PRIN1, PRINC, and PRINT were defined in
  Lisp 1.5 (the ancestor of all modern Lisp systems) and are still found in Common Lisp
    today.

They are included in the Advanced Topics section as a historical note;
  we can get the same effect current-day with FORMAT.

TERPRI stands for TERminate PRInt.
  It moves the cursor to a new line.

PRIN1 and PRINC take a Lisp object as input and print it on the terminal.

  PRIN1 prints the object with whatever escape characters are necessary to assure that
    it can be read back in with READ;

  PRINC prints the object without escape characters.

The ~S format directive works like PRIN1.

The ~A directive works like PRINC.

Both PRIN1 and PRINC return their first argument.

CL-USER> (setf bung "Wherefore art thou, Bunghole?")
"Wherefore art thou, Bunghole?"
CL-USER> (prin1 bung)
"Wherefore art thou, Bunghole?"
"Wherefore art thou, Bunghole?"
CL-USER> (princ bung)
Wherefore art thou, Bunghole?
"Wherefore art thou, Bunghole?"


The PRINT function is a combination of the preceding three functions.
  It goes to a new line with TERPRI, prints its argument with PRIN1,
    and then prints a space with PRINC.

We can define a simple version of PRINT as follows:

(defun my-print (list)
  "User-defined version of PRINT."
  (terpri)
  (prin1 list)
  (princ " ")
  list)

(defun bogosity ()
  "Blanket of bogusness."
  (mapcar #'my-print '(b o g o s i t y)))

CL-USER> (bogosity)

B 
O 
G 
O 
S 
I 
T 
Y 
(B O G O S I T Y)


TERPRI, PRIN1 and PRINC accept an optional stream argument just like READ;
  this allows them to be used for file i/o.



---
9.11 HANDLING END-OF-FILE-CONDITIONS

Sometimes it's necessary to read a file without knowing in advance how many
  objects it contains.

When the program gets to the end of a file, the next READ will generate an
  end-of-file error, and we will find ourselves in the debugger.

It is possible to tell READ to return a special value called an eof-indicator,
  instead of generating an error on end of file.

We do this by supplying two extra arguments to READ:

  a NIL (meaning don't generate an error)
    and the value we want to use as the eof indicator.

We must be careful what value we choose for the eof indicator.
  If we used something like FOO and the file actually contained FOO halfaway
    then the program would be fooled into thinking it reached the end and it hasn't.

A good choice for an eof indicator is a freshly generated cons cell.

We will use EQ rather than EQUAL to make sure that exactly that cons cell is returned.

(defun read-my-file ()
  "Reads an arbitrary file of Lisp objects, tells how many were read, then returns them."
  (with-open-file (stream "c:/Users/tylerbrw/Documents/lisp/references/an-introduction/bung/bogo-file.lisp")
    (let ((contents
            (read-all-objects stream (list '$eof$))))
      (format t "~&Read ~S objects from the file."
              (length contents))
      contents)))

(defun read-all-objects (stream eof-indicator)
  "Reads all of the Lisp objects within an arbitrary file."
  (let ((result (read stream nil eof-indicator)))
    (if (eq result eof-indicator)
        nil
        (cons result (read-all-objects stream eof-indicator)))))

CL-USER> (read-my-file)
Read 6 objects from the file.
(35 CAT (MOOSE MEAT) 98.6 "Frozen yogurt" 3.14159)



---
9.12 PRINTING IN DOT NOTATION

Dot notation is a variant of cons cell notation.

In dot notation each cons cell is displayed:
  as a left parenthesis
    the car part
      a dot
        the cdr part
          and a right parenthesis.

CL-USER> '(a . nil)
(A)
CL-USER> '(a . (b . nil))
(A B)
CL-USER> '(a . (b . (c . nil)))
(A B C)
CL-USER> (sdraw-loop)
Type any Lisp expression, or :ABORT to exit.

S> '(a . (b . nil))

[*|*]--->[*|*]--->NIL
 |        |
 v        v
 A        B

Result:  (A B)


The car and cdr part, if lists, are themselves displayed in dot notation

CL-USER> '(a . ((b . nil) . (c . nil)))
(A (B) C)
CL-USER> (sdraw-loop)
Type any Lisp expression, or :ABORT to exit.

S> '(a . ((b . nil) . (c . nil)))

[*|*]--->[*|*]--------->[*|*]--->NIL
 |        |              |
 v        v              v
 A       [*|*]--->NIL    C
          |
          v
          B

Result:  (A (B) C)



EXERCISES

CL-USER> nil
NIL
CL-USER> 'a
A
CL-USER> '(a . nil)
(A)
CL-USER> '(a . (b . nil))
(A B)
CL-USER> '(a . (b . (c . nil)))
(A B C)
CL-USER> '(a . ((b . nil) . (c . nil)))
(A (B) C)


9.11 Write a function DOT-PRIN1 that takes a list as input and prints it in dot notation.

       DOT-PRIN1 will print parenthesis by:
         (FORMAT T "(") and (FORMAT T ")")

       and will print dots by:
         (FORMAT T " . ")

       and will call itself recursively to print lists within lists.
         *HINT* recursive=conditional

(defun dot-prin1 (list)
  "Takes a standard list and returns it in dot notation."
  (cond ((atom list) (format t "~S" list))
        (t (format t "(")
           (dot-prin1 (car x))
           (format t " . ")
           (dot-prin1 (cdr x))
           (format t ")"))))

CL-USER> (dot-prin1 '(a (b) c))
(A . ((B . NIL) . (C . NIL)))
NIL
CL-USER> (dot-prin1 '((((a)))))
((((A . NIL) . NIL) . NIL) . NIL)
NIL


9.12 Lisp can also read lists in dot notation.

CL-USER> (dot-prin1 '(a . (b . c)))
(A . (B . C))
NIL


9.13 If you type in the quoted list '(A . NIL), Lisp returns (A).
     Type '(A . B).

CL-USER> '(a . b)
(A . B)
CL-USER> (sdraw-loop)
Type any Lisp expression, or :ABORT to exit.

S> '(a . b)

[*|*]--->B
 |
 v
 A

Result:  (A . B)


9.14 Consider the following two circular list structures, each composed of a single cons cell.
       What will be the behavior of DOT-PRIN1 if it is given the first structure as input?
         What will it do with the second structure as input?

Both of these structures cause infinite loops.

The first one returns (FOO . (FOO . (FOO ... infinitely.

The other one gets you an infinite loop of left parenthesis.



---
9.13 HYBRID NOTATION

Lisp normally prints things in list notation, not dot notation.

But as we have seen, some cons cell structures such as (A . B) cannot be written without dots.

Lisp has a policy to print dots only when absolutely necessary.
  It never prints a dot unless the cons cell chain ends in a non-NIL atom.

Its output is thus a mixture of pure list and pur dot notations called hybrid notation.



EXERCISE

9.15 Write HYBRID-PRIN1. Here is how the function should decide whether to print a dot or not.
       If the cdr part of the cons cell is a list, HYBRID-PRIN1 prints in list notation.
         If the cdr part of the cons cell is an atom, dot notation is returned.
           It will be useful to define a subfunction to print cdrs of lists,
             as these always begin with a space,
               whereas the cars always end in a left parenthesis.

(defun hybrid-prin1 (lst)
  "Determines whether to return the input in dot or list notation. Returns the determination."
  (cond ((atom lst) (format t "~S" lst))
        (t (hybrid-print-car (car lst))
           (hybrid-print-cdr (cdr lst)))))

(defun hybrid-print-car (lst)
  "Helper function to HYBRID-PRIN1."
  (format t "(")
  (hybrid-prin1 lst))

(defun hybrid-print-cdr (lst)
  "Helper function to HYBRID-PRIN1."
  (cond ((null lst) (format t ")"))
        ((atom lst) (format t " . ~S)" lst))
        (t (format t " ")
           (hybrid-prin1 (car lst))
           (hybrid-print-cdr (cdr lst)))))

CL-USER> (hybrid-prin1 '(a . nil))
(A)
NIL
CL-USER> (hybrid-prin1 '(a . b))
(A . B)
NIL
CL-USER> (hybrid-prin1 '(a . (b . nil)))
(A B)
NIL
CL-USER> (hybrid-prin1 '(a . (b . c)))
(A B . C)
NIL
CL-USER> (hybrid-prin1 '(a . (b . (c . d))))
(A B C . D)
NIL
CL-USER> (hybrid-prin1 '((a . nil) . (b . (c . d))))
((A) B C . D)
NIL



FUNCTIONS COVERED

Lisp 1.5 output primitives: TERPRI PRIN1 PRINC PRINT



***
10 Assignment

---
10.1 INTRODUCTION

Way back in Chapter 5 we saw how the SETF macro changes the value of a variable;
  this is called assignment.

Assignment has mostly, if not all been done on the top-level read-eval-print loop
  setting global variables.

We have not yet learned how to use SETF inside of functions.

Assignment is easily misused, leading to bullshit.

Lisp offers more control structures than other languages (like LET and applicative operators),
  in many Lisp programs assignment doesn't need to be used.

Assignment is appropriate in Lisp on occasion
  and is commonly used with iterative control structures.



---
10.2 UPDATING A GLOBAL VARIABLE

Suppose we are operating a lemonade stand and we want to keep track
  of glasses sold so far.

    We keep the number of glasses stored in a global variable *TOTAL-GLASSES*
      which we will initialize to zero:

CL-USER> (setf *total-glasses* 0)
0
CL-USER> *total-glasses*
0

There is a convention is Common Lisp that global variables should have names that begin and
  end with an asterisk.

When we write programs that manipulate global variables we need to follow the convention.

Therefore *TOTAL-GLASSES*.

Everytime lemonade is sold, the variable would need to be updated.
  We also want a report on the glasses of lemonade sold thus far:

(defun sell (n)
  "Ye Olde Lemonade Stand: Sales by the Glass."
  (setf *total-glasses* (+ *total-glasses* n))
  (format t "~&Glasses sold so far: ~S"
          *total-glasses*))

CL-USER> (sell 3)
Glasses sold so far: 3
NIL
CL-USER> *total-glasses*
3
CL-USER> (sell 2)
Glasses sold so far: 5
NIL
CL-USER> *total-glasses*
5


Notice that the SELL function contains two forms in its body.
  The first form updates the variable *TOTAL-GLASSES*.
    The second form prints a message about how many glasses have been sold so far.

SELL returns NIL because FORMAT evaluates last.



EXERCISE

10.1 Suppose we had forgotten to set *TOTAL-GLASSES* to zero before calling SELL
       the first time. What would happen?

         What if *TOTAL-GLASSES* was set to FOO?

If *TOTAL-GLASSES* was not initialized, we would get an unassigned variable error
  when we called SELL.

If *TOTAL-GLASSES* was initialized to FOO instead of zero,
  we would get a wrong type input error when SELL tried to increment the total.



---
10.3 STEREOTYPICAL UPDATING METHODS

SETF can assign any value to any variable.

A very common use of assignment is to update a variable,
  the variables old value is used to compute what the new value should be.

Most uses of assignment are of this form.

Common Lisp provides built-in macros for expressing the most common update
  cases more concisely than with SETF.

Two updating methods we consider update a counter by incrementing or decrementing it,
  and updating a list by adding or deleting an element at the front.



10.3.1 The INCF and DECF Macros

Instead of incrementing a numeric variable by writing (SETF A (+ A 5)),

CL-USER> (setf a 2)
2
CL-USER> a
2
CL-USER> (setf a (+ a 5))
7


  we can use INCF:

CL-USER> (setf a 2)
2
CL-USER> (incf a 5)
7


We can use DECF to decrement an update:

CL-USER> (decf a 5)
2


INCF and DECF are special assignment macros for incrementing and decrementing variables.

CL-USER> (describe 'incf)
COMMON-LISP:INCF
  [symbol]

INCF names a macro:
  Lambda-list: (SB-IMPL::PLACE &OPTIONAL (SB-IMPL::DELTA 1))
  Documentation:
    The first argument is some location holding a number. This number is
      incremented by the second argument, DELTA, which defaults to 1.
  Source file: SYS:SRC;CODE;SETF.LISP
; No value

CL-USER> (describe 'decf)
COMMON-LISP:DECF
  [symbol]

DECF names a macro:
  Lambda-list: (SB-IMPL::PLACE &OPTIONAL (SB-IMPL::DELTA 1))
  Documentation:
    The first argument is some location holding a number. This number is
      decremented by the second argument, DELTA, which defaults to 1.
  Source file: SYS:SRC;CODE;SETF.LISP
; No value

CL-USER> (incf a)
3
CL-USER> (decf a)
2

If no value is provided to the increment/decrement special assignment macros,
  they default to one.


EXERCISE
10.2 Rewrite the lemonade stand SELL function to use INCF instead of SETF:

(defun sell-old (n)
  "Ye Olde Lemonade Stand: Sales by the Glass."
  (setf *total-glasses* (+ *total-glasses* n))
  (format t "~&Glasses sold so far: ~S"
          *total-glasses*))

(defun sell (n)
  "The New lemonade stand bitches."
  (incf *total-glasses* n)
  (format t "~&Glasses sold so far: ~S"
          *total-glasses*))


---
10.3.2 The PUSH and POP Macros

The elegant way a Lisp programmer adds list elements to a variable
  is through the PUSH and POP macros.

CL-USER> (setf my-stack nil)
NIL
CL-USER> (push 'dish1 my-stack)
(DISH1)
CL-USER> (push 'dish2 my-stack)
(DISH2 DISH1)
CL-USER> (push 'dish3 my-stack)
(DISH3 DISH2 DISH1)
CL-USER> my-stack
(DISH3 DISH2 DISH1)
CL-USER> (pop my-stack)
DISH3
CL-USER> (push 'dish4 my-stack)
(DISH4 DISH2 DISH1)
CL-USER> (push 'dish5 my-stack)
(DISH5 DISH4 DISH2 DISH1)
CL-USER> (pop my-stack)
DISH5
CL-USER> (pop my-stack)
DISH4
CL-USER> my-stack
(DISH2 DISH1)
CL-USER> (push 'dish3 my-stack)
(DISH3 DISH2 DISH1)
CL-USER> (push 'dish4 my-stack)
(DISH4 DISH3 DISH2 DISH1)
CL-USER> (push 'dish5 my-stack)
(DISH5 DISH4 DISH3 DISH2 DISH1)


The name "push" comes from classical computer science terminology for "pushdown-stacks".

A stack, or pushdown stack is analogpus to a spring-loaded stack of dishes in a cafeteria.
  When you push a dish onto the stack, it becomes the new top-most element.
    When you pop the top-most dish off the stack, the dish below becomes the top-most element.

Reading a list from left-to-right is like reading a stack from top-to-bottom:

S> (pop my-stack)

DISH5

S> my-stack

[*|*]--->[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |        |
 v        v        v        v
DISH4    DISH3    DISH2    DISH1

Result:  (DISH4 DISH3 DISH2 DISH1)

S> (push 'dish5 my-stack)

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |        |        |
 v        v        v        v        v
DISH5    DISH4    DISH3    DISH2    DISH1

Result:  (DISH5 DISH4 DISH3 DISH2 DISH1)


Since each call to PUSH results in an assignment, the variable MY-STACK
  will always be updated to point to the newest cons cell, at the head of the list.

When we start popping dishes off the stack,
  DISH5 defaults and is removed from the stack.

DISH4 is then at the top of the stack.

We can PUSH anything onto the stack, but pushing DISH5 onto MY-STACK
  places the element back on top of the variable list MY-STACK.

Note that when first calling POP onto the variable list MY-STACK,
  the return value is the element that was formerly at the top of the stack.

The side effect of POP is that top element being removed.


An equivalent form for POP:

CL-USER> (pop my-stack)
DISH5
(DISH4 DISH3 DISH2 DISH1)
CL-USER> (push 'dish5 my-stack)
(DISH5 DISH4 DISH3 DISH2 DISH1)
CL-USER> (let ((top-element (first my-stack)))
           (setf my-stack (rest my-stack))
           top-element)
DISH5


The LET expression first remembers the top of the stack in the local variable TOP-ELEMENT.
  Then in the body it pops the stack by setting MY-STACK to (REST MY-STACK).
    Finally it returns the value of TOP-ELEMENT, which is the element it just popped.

PUSH and POP should really be called PUSHF and POPF for consistency with the other
  assignment forms.

Their names do not end in F because they were invented before SETF and the F
  convention were brought about.

*Note* SETF stands for set-field.


Programming with PUSH:

(setf *friends* nil)

(defun meet (person)
  "Who the fuck ..?"
  (cond ((equal person (first *friends*))
         'we-just-met)
        ((member person *friends*)
         'we-know-eachother)
        (t (push person *friends*)
           'pleased-to-meet-you)))

CL-USER> (meet 'fred)
PLEASED-TO-MEET-YOU
CL-USER> (meet 'cindy)
PLEASED-TO-MEET-YOU
CL-USER> (meet 'cindy)
WE-JUST-MET
CL-USER> (meet 'joe)
PLEASED-TO-MEET-YOU
CL-USER> (meet 'fred)
WE-KNOW-EACHOTHER
CL-USER> *friends*
(JOE CINDY FRED)



EXERCISES
10.3 Modify the MEET function to keep a count of how many people have been met more than once.
       Store the count in a global variable.

(setf *met-before* 0)

(defun meet (person)
  "Hi, nice to meet ya dude. I think I've met some of y'all before .."
  (cond ((equal person (first *friends*))
         (incf *met-before*)
         'we-just-met)
        ((member person *friends*)
         (incf *met-before*)
         'we-know-eachother)
        (t (push person *friends*)
           'pleased-to-meet-you)))


10.4 Write a function FORGET that removes a person from the *FRIENDS* list.
       If the person wasn't on the list in the first place, the function should complain.

(setf *homies* nil)

(defun makin-homies (dude)
  "Wuddup dude?"
  (cond ((equal dude (first *homies*))
         'we-literally-just-met-dude)
        ((member dude *homies*)
         'we-are-homies-dude)
        (t (push dude *homies*)
           'welcome-dude)))

(setf *already-met-these-dudes* 0)

(defun makin-homies-efficiently (dude)
  "Duuuuude, this is better."
  (cond ((equal dude (first *homies*))
         (incf *already-met-these-dudes*)
         'we-literally-just-met-dude)
        ((member dude *homies)
         (incf *already-met-these-dudes*)
         'we-are-homies-dude)
        (t (push dude *homies*)
           'welcome-dude)))

(defun forget-you-dude (dude)
  "We ain't dudes anymore dude."
  (cond ((member dude *homies*)
         (setf *homies*
               (remove dude *homies*))
         'forget-you-dude)
        (t (list 'dont 'know 'this 'dude))))

CL-USER> (defun forget-you-dude (dude)
  "We ain't dudes anymore dude."
  (cond ((member dude *homies*)
         (setf *homies*
               (remove dude *homies*))
         'forget-you-dude)
        (t (list 'dont 'know 'this 'dude))))
FORGET-YOU-DUDE
CL-USER> (forget-you-dude 'bill)
FORGET-YOU-DUDE
CL-USER> (forget-you-dude 'vic)
(DONT KNOW THIS DUDE)



---
10.3.3 Updating Local Variables

Assignment should not be used indiscriminately.

It is distasteful to change the value of a local variable;
  one should just bind a new local variable with LET instead.

It is even more distasteful to modify a variable that appears in a function's argument list;
  doing this makes the function hard to understand.

This is an example of code written in poor style in comparison to the same function
  written stylistically:

(defun bad-style (n)
  (format t "~&N is ~S." n)
  (decf n 2)
  (format t "~&Now N is ~S." n)
  (decf n 2)
  (format t "~&Now N is ~S." n)
  (list 'result 'is (* n (- n 1))))

CL-USER> (bad-style 7)
N is 7.
Now N is 5.
Now N is 3.
(RESULT IS 6)

(defun good-style (n)
  (let* ((p (- n 2))
         (q (- p 2)))
    (format t "~&N is ~S." n)
    (format t "~&P is ~S." p)
    (format t "~&Q is ~S." q)
    (list 'result 'is (* q (- q 1)))))

CL-USER> (good-style 7)
N is 7.
P is 5.
Q is 3.
(RESULT IS 6)


GOOD-STYLE is cleaned up with the introduction of extra variables
  and replacing the DECF expressions
    with a LET* form.

When all assignments have been eliminated, we are assured that the value of a variable
  will never change once it is created.

Programs written in this assignment-free style are easy to understand and very elegant.

There are occasions when it is more convenient to assign
  to a local variable instead of LET-binding it.

The following is an example:

(defun get-name ()
  "Into the system you go."
  (let ((last-name nil)
        (first-name nil)
        (middle-initial nil)
        (preferred-title nil))
    (format t "~&Input Last Name : ")
    (setf last-name (read))
    (format t "~&First Name: ")
    (setf first-name (read))
    (format t "~&Middle Initial: ")
    (setf middle-initial (read))
    (format t "~&Preferred Title: ")
    (setf preferred-title (read))
    (list preffered-title first-name middle-initial last-name)))

CL-USER> (get-name)
Input Last Name : Fudgebottoms

First Name: Harry

Middle Initial: P

Preferred Title: Major

(MAJOR HARRY P FUDGEBOTTOMS)



---
10.4 WHEN AND UNLESS

CL-USER> (describe 'when)
COMMON-LISP:WHEN
  [symbol]

WHEN names a macro:
  Lambda-list: (SB-IMPL::TEST &BODY SB-IMPL::FORMS)
  Documentation:
    If the first argument is true, the rest of the forms are
    evaluated as a PROGN.
  Source file: SYS:SRC;CODE;DEFBOOT.LISP
; No value
CL-USER> (describe 'unless)
COMMON-LISP:UNLESS
  [symbol]

UNLESS names a macro:
  Lambda-list: (SB-IMPL::TEST &BODY SB-IMPL::FORMS)
  Documentation:
    If the first argument is not true, the rest of the forms are
    evaluated as a PROGN.
  Source file: SYS:SRC;CODE;DEFBOOT.LISP
; No value


WHEN and UNLESS are conditional forms that are useful when we
  need to evaluate more than one expression when a test is true.

Syntax:

(WHEN test
  body)

(UNLESS test
  body)


WHEN first evaluates the test form.
  If the result is NIL, WHEN just returns NIL.
    If the result is non-NIL,
      WHEN evaluates the forms in its body
        and returns the value of the last one.

UNLESS is similar, except it evaluates the forms in its body only if the test is false.

For both of these conditionals, when the forms in the body are evaluated,
  the value of the last one is returned.
    Forms prior to the last one are only useful for their side-effects,
      such as i/o or assignment.

The only advantages of WHEN and UNLESS over COND are stylistic.
  They have a simpler and somewhat more pleasant syntax,
    and they need less indentation because their bodies are indented only two spaces.


Suppose we want to write a function that takes two numbers as input and multiplies them.
  This function also requires that its first input be odd and it second even.
    If an input is of the wrong sort, the function can "fix" it by adding or subtracting
      one and printing a suitable warning message:

(defun picky-times (x y)
  (unless (oddp x)
    (incf x)
    (format t "~&Changing X to ~S to make it odd." x))
  (when (oddp y)
    (decf y)
    (format t "~&Changing Y to ~S to make it even." y))
  (* x y))

; compiling (DEFUN PICKY-TIMES ...)
CL-USER> (picky-times 2 3)

Changing X to 3 to make it odd.
Changing Y to 2 to make it even.
6
CL-USER> (picky-times 3 2)
6
CL-USER> (picky-times 0 0)
Changing X to 1 to make it odd.
0



---
10.5 GENERALIZED VARIABLES

A generalized variable is any place a pointer may be stored.

An ordinary variable like X or N contains a pointer to the object that is its value.
  But pointers can also be stored in other sorts of plaes,
    such as the car or cdr half of a cons cell.

Assignment means replacing one pointer with another.
  So when we say the value of N is 3,

CL-USER> (setf n 3)
3
CL-USER> (inspect n)

The object is an ATOM:
  3

    what we mean is that the variable named N holds a pointer to the number 3.

When we do something like this:

CL-USER> (incf n)
4


  then that expression replaces the pointer
    specifying the number 3,

  to a pointer specifying the number 4.


The assignmnet macros covered can assign to geralized variables,
  meaning they can store pointers in many different places.

The first arguments to functions SETF INCF DECF PSH or POP is treated as a place description.

Consider this example:

CL-USER> (setf x '(jack benny was 39 for many years))
(JACK BENNY WAS 39 FOR MANY YEARS)

CL-USER> (setf (sixth x) 'several)
SEVERAL

CL-USER> x
(JACK BENNY WAS 39 FOR SEVERAL YEARS)

CL-USER> (decf (fourth x) 2)
37

CL-USER> x
(JACK BENNY WAS 37 FOR SEVERAL YEARS)

CL-USER> (incf (fourth x) 10)
47

CL-USER> x
(JACK BENNY WAS 47 FOR SEVERAL YEARS)

CL-USER> (setf (third x) 'turned)
TURNED

CL-USER> (setf (second numord) 2)
2
CL-USER> x
(JACK BENNY TURNED 47 FOR SEVERAL YEARS)


SETF and related forms can accept place descriptions like (FOURTH X),
  then store pointers to the updated locations.

The expression (FOURTH X) specifies a pointer that lives in the car of the fourth
  cons cell in the chain pointed by X.

This place can also be called the CAR of the CDDDR of X:

S> x

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]---->[*|*]--->NIL
 |        |        |        |        |        |         |
 v        v        v        v        v        v         v
JACK     BENNY    TURNED    47      FOR      SEVERAL   YEARS

Result:  (JACK BENNY TURNED 47 FOR SEVERAL YEARS)

S> (car (cdddr x))

47

S> (cadddr x)

47


Maybe it could be called the CADDDR to.



---
10.6 CASE STUDY: A TIC-TAC-TOE PLAYER

In this section we will write our first large program:
  a program that not only plays tic-tac-toe,
    but also explains the strategy behind each move.

When writing a program this complex, it pays to take a few minutes
  at the outset to think about the overall design,
    particularly the data structures that will be used.


We can begin writing our program by building a representation of the board,
  we can number the squares on the tic-tac-toe board this way:

  1 | 2 | 3
 -----------
  4 | 5 | 6
 -----------
  7 | 8 | 9


We will represent a board as a list consisting of the symbol BOARD followed
  by nine numbers that describe the contents of each position.

A zero means the position is empty;
 a one means it is filled by an O;
   a ten means it is filled by an X.

The function MAKE-BOARD creates a new tic-tac-toe board:

(defun make-board ()
  (list 'board 0 0 0 0 0 0 0 0 0))

; compiling (DEFUN MAKE-BOARD ...)
CL-USER> (make-board)

(BOARD 0 0 0 0 0 0 0 0 0)


Notice that if B is a variable holding a tic-tac-toe board,
  position one of the board can be accessed by writing (NTH 1 B),
    position two by (NTH 2 B), and so on ..
      (NTH 0 B) returns the symbol BOARD.

CL-USER> (setf b (make-board))
(BOARD 0 0 0 0 0 0 0 0 0)
CL-USER> b
(BOARD 0 0 0 0 0 0 0 0 0)
CL-USER> (nth 1 b)
0
CL-USER> (nth 0 b)
BOARD


Now let's write functions to print out on the board.

CONVERT-TO-LETTER converts a zero, one, or ten
  to a space, an O, or an X.

It is called by PRINT-ROW, which prints out one row of the board.

PRINT-BOARD calls PRINT-ROW:

(defun convert-to-letter (v)
  (cond ((equal v 1) "O")
        ((equal v 10) "X")
        (t " ")))

(defun print-row (x y z)
  (format t "~&  ~A | ~A | ~A"
          (convert-to-letter x)
          (convert-to-letter y)
          (convert-to-letter z)))

(defun print-board (board)
  (format t "~%")
  (print-row
   (nth 1 board) (nth 2 board) (nth 3 board))
  (format t "~&  ---------")
  (print-row
   (nth 4 board) (nth 5 board) (nth 3 board))
  (format t "~&  ---------")
  (print-row
   (nth 7 board) (nth 8 board) (nth 9 board))
  (format t "~%~%"))

CL-USER> (print-board b)

    |   |  
  ---------
    |   |  
  ---------
    |   |  

NIL
CL-USER> b
(BOARD 0 0 0 0 0 0 0 0 0)

We get a tic-tac-toe board printed,
  the B variable represents our board with 9 move spaces.


We can make a board move by destructively changing
  one of the board position descriptors from a 0 to a 1 (for O) or 10 (for X).

The variable PLAYER in MAKE-MOVE will be either one or ten,
  depending on who is moving:

(setf *computer* 10)

(setf *opponent* 1)

CL-USER> b
(BOARD 0 0 0 0 0 0 0 0 0)
CL-USER> (make-move *opponent* 3 b)
(BOARD 0 0 1 0 0 0 0 0 0)
CL-USER> (make-move *computer* 5 b)
(BOARD 0 0 1 0 10 0 0 0 0)
CL-USER> (print-board b)

    |   | O
  ---------
    | X |  
  ---------
    |   |  

NIL


The program will be able to select the best move
  if it has some way of analysing the board configuration
    and possible moves.

Tic-tac-toe only provides eight different ways to make a winning three-in-a-row:
  three horizontally,
    three vertically,
      and two diagonally.

Each of these combinations can be coined as a triplet.
  All eight triplets will be stored as individual lists in *TRIPLETS*:

(setf *triplets*
      '((1 2 3) (4 5 6) (7 8 9)    ;Horizontal triplets.
        (1 4 7) (2 5 8) (3 6 9)    ;Vertical triplets.
        (1 5 9) (3 5 7)))          ;Diagonal triplets.


SUM-TRIPLET can now be written so that we can return the sum
  of the numbers in the board positions specified by that triplet.

    For example, the right diagonal triplet is (3 5 7).
      The sum of elements 3 5 7 of board B is 11.

        This indicates that there is one X, one O, and one blank
          on that diagonal triplet (in no specific order).

    If the sum had been twenty-one, there would be two Xs and one O;
      a sum of twelve would indicate one X and two Os, etc.

(defun sum-triplet (board triplet)
  (+ (nth (first triplet) board)
     (nth (second triplet) board)
     (nth (third triplet) board)))

(sum-triplet b '(3 5 7))    ;Left-diagonal.

(sum-triplet b '(2 5 8))    ;Middle-vertical.

(sum-triplet b '(7 8 9))    ;Bottom horizontal.

CL-USER> (sum-triplet b '(3 5 7))
11
CL-USER> (sum-triplet b '(2 5 8))
10
CL-USER> (sum-triplet b '(7 8 9))
0


Fully analyzing the board requires a view of all the possible sums.
  The function COMPUTE-SUMS returns a list of all sums of winning triplets.

(defun compute-sums (board)
  (mapcar #'(lambda (triplet)
              (sum-triplet board triplet))
          *triplets*))

CL-USER> (compute-sums b)
(1 10 0 0 10 1 10 11)
CL-USER> b
(BOARD 0 0 1 0 10 0 0 0 0)
CL-USER> (print-board b)

    |   | O
  ---------
    | X |  
  ---------
    |   |  

NIL


Notice that if player O ever gets three-in-a-row,
  one of the eight sums will be three.

If player X manages a three-in-a-row, one of the eight sums will be 30.

We can write a predicate to check for this condition:

(defun winner-p (board)
  (let ((sums (compute-sums board)))
    (or (member (* 3 *computer*) sums)
        (member (* 3 *opponent*) sums))))


The state of the board in its current state would return NIL.
  A completed board can be input later.


We must move forward and begin to view the basic framework of tic-tac-toe.

The function PLAY-ONE-GAME offers the user a choice of making the first move,
  and then can call either COMPUTER-MOVE or OPPONENT-MOVE as appropriate,
    passing a new, empty board as input.

(defun opponent-move (board)
  (let* ((pos (read-a-legal-move board))
         (new-board (make-move
                     *opponent*
                     pos
                     board)))
    (print-board new-board)
    (cond ((winner-p new-board)
           (format t "~&You win."))
          ((board-full-p new-board)
           (format t "~&Tie. Both y'all lose."))
          (t (computer-move new-board)))))


A legal move is an integer between one and nine;
  on an empty board position.

READ-A-LEGAL-MOVE reads a Lisp object and checks whether it is a legal move.
  It uses the less-than or equal comparison predicate, <=.

If the move isn't legal, the function calls itself to read another move.
  Notice that the first two COND clauses each contain a test and two consequents.

    If the test is true, both consequents are evaluated,
      and the value of the last one (the recursive call) is returned.

(defun read-a-legal-move (board)
  (format t "~&Your move: ")
  (let ((pos (read)))
    (cond ((not (and (integerp pos)
                     (<= 1 pos 9)))
           (format t "~&Invalid input.")
           (read-a-legal-move board))
          ((not (zerop (nth pos board)))
           (format t
                   "~&That space is already occupied.")
           (read-a-legal-move board))
          (t pos))))


The BOARD-FULL-P predicate is called by OPPONENT-MOVE to test
  if there are no more empty spaces left on the board:
  
(defun board-full-p (board)
  (not (member 0 board)))


COMPUTER-MOVE is similar to OPPONENT-MOVE, except that the player is X
  and instead of reading a move from the keyboard, we will call CHOOSE-BEST-MOVE.

    This function returns a list of two elements.
      The first element is the position in which to place an X.
        The second a string explaining strategy behind that move.
        
(defun computer-move (board)
  (let* ((best-move (choose-best-move board))
         (pos (first best-move))
         (strategy (second best-move))
         (new-board (make-move
                     *computer* pos board)))
    (format t "~&My move: ~S" pos)
    (format t "~&My strategy: ~A~%" strategy)
    (print-board new-board)
    (cond ((winner-p new-board)
           (format t "~&I win!"))
          ((board-full-p new-board)
           (format t "~&Tie game."))
          (t (opponent-move new-board)))))


Now we are almost ready to play our first game.

Our first version of CHOOSE-BEST-MOVE will have only one strategy:
  Pick a legal move at random.

The function RANDOM-MOVE-STRATEGY returns a list whose first element is the move,
  and whose second element is a string explaining the strategy behind the move.

The function PICK-RANDOM-EMPTY-POSITION picks a random number from one to nine.
  If that board position is empty, it returns that move.

Otherwise, it calls itself recursively to try another random number.

(defun choose-best-move (board)    ;First version.
  (random-move-strategy board))

;;The move and an explanation of the logic behind it.

(defun random-move-strategy (board)
  (list (pick-random-empty-position board)
        "random move"))

;;Picking a random number from 1 to 9 for position.

(defun pick-random-empty-position (board)
  (let ((pos (+ 1 (random 9))))
    (if (zerop (nth pos board))
        pos (pick-random-empy-position board))))


We can play a few games with the program to see how it feels:

CL-USER> (print-board b)

    |   |  
  ---------
    |   |  
  ---------
    |   | X

NIL
CL-USER> (computer-move b)
My move: 8
My strategy: Random move.

    |   |  
  ---------
    |   |  
  ---------
    | X | X

Your move: 3

    |   | O
  ---------
    |   |  
  ---------
    | X | X

My move: 5
My strategy: Random move.

    |   | O
  ---------
    | X |  
  ---------
    | X | X

Your move: 2

    | O | O
  ---------
    | X |  
  ---------
    | X | X

My move: 4
My strategy: Random move.

    | O | O
  ---------
  X | X |  
  ---------
    | X | X

Your move: 6

    | O | O
  ---------
  X | X | O
  ---------
    | X | X

My move: 1
My strategy: Random move.

  X | O | O
  ---------
  X | X | O
  ---------
    | X | X

I win!
NIL


I lost to the computer by accident, but as we can see the computer clearly works as it should.

The computer chooses any empty space using a test for zero and the RANDOM fucntion.

We can make this program more intelligent by
  telling it to survey the board for two Xs in a row,
    it should fill in the third X to win the game.

(defun make-three-in-a-row (board)
  (let ((pos (win-or-block board
                           (* 2 *computer*))))
    (and pos (list pos "make three in a row"))))

(defun win-or-block (board target-sum)
  (let ((triplet (find-if
                  #'(lambda (trip)
                      (equal (sum-triplet board
                                          trip)
                             target-sum))
                  *triplets*)))
    (when triplet
      (find-empty-position board triplet))))

(defun find-empty-position (board squares)
  (find-if #'(lambda (pos)
               (zerop (nth pos board)))
           squares))


  Otherwise, if there are two Os in a row,
    the computer player should know to place an X in front of the series.

Both MAKE-THREE-IN-A-ROW and BLOCK-OPPONENT return NIL if
  they cannot find a move that fits their respective strategies.


Now we need to revise CHOOSE-BEST-MOVE,

(defun choose-best-move (board)    ;First version.
  (random-move-strategy board))


  so that it will try its strategies one at a time
    until one of them returns a non-NIL move.

(defun choose-best-move (board)    ;Second version.
  (or (make-three-in-a-row board)
      (block-opponent-win board)
      (random-move-strategy board)))

The new strategies we have introduced to the system leaves no room for error while playing.

If the human does not make any mistakes, the game is sure to end in a tie.



SUMMARY

The SETF macro can assign any value to any variable.

"Updating" a variable means computing its new value based on its old value.

Two stereotypical forms of updating are incrementing or decrementing
  a numeric variable for which INCF and DECF may be used).

Most updates are performed on global variables.

Changing the value of a local variable is usually considered bad programming style;
  it is better to bind a new variable with LET instead.

A generalized variable is any place a pointer may be stored.
  All of the assignment macros discussed in this chapter operate on generalized variables,
    not just oridinary variables.

Your move: 9

 3 O | X | X
  ---------
  X |1 O |  
  ---------
 2 O |   |4 O

You win.
NIL
CL-USER>


Assignment is used only sparingly in Lisp programs.
  LET, applicative operators, and effieciently written tail-recursive functions
    make assignment unnecessary in many cases.

Assignment free programs are considered very elegant.



REVIEW EXERCISES

10.5 Rewrite the following ugly function to use good Lisp style.

(defun ugly (x y)
  (when (> x y)
    (setf temp y)
    (setf y x)
    (setf x temp))
  (setf avg (/ (+ x y) 2.0))
  (setf pct (* 100 (/ avg y)))
  (list 'average avg 'is
        pct 'percent 'of 'max y))

(defun pretty (x y)
  (let* ((biggest (max x y))
         (smallest (min x y))
         (avg (/ (+ x y) 2.0))
         (pct (* 100 (/ avg biggest))))
    (list 'average avg 'is pct 'percent
          'of 'max biggest)))

This function is taking the average of two numbers,
  returning that and the percentage of the smaller integer
    out of the larger one.

It stores all of its variables in a LET* expression, allowing it to use previously used symbols.

      We find the largest integer put of the two:
        (biggest (max x y))

      We find the smallest of them:
        (smallest (min x y))

      We find the average of those two:
        (avg (/ (+ x y) 2.0))

      Lastly the percentage:
        (pct (* 100 (/ avg biggest))))

We complete the function definition with a list of combined symbols
  with the computed functions embedded therein.

When evaluating either function, the order of integer input does not matter.
  The function always divides the larger input with the lesser.


10.6 Set X to NIL. Evaluate (PUSH X X) three times.

CL-USER> (setf x nil)
NIL
CL-USER> (push x x)
(NIL)
CL-USER> (push x x)
((NIL) NIL)
CL-USER> (push x x)
(((NIL) NIL) (NIL) NIL)

The cons cell chain ends up looking like this,

[*|*]------------------------>[*|*]--------->[*|*]--->NIL
 |                             |              |
 v                             v              v
[*|*]--------->[*|*]--->NIL   [*|*]--->NIL   NIL
 |              |              |
 v              v              v
[*|*]--->NIL   NIL            NIL
 |
 v
NIL

Result:  (((NIL) NIL) (NIL) NIL)


  if the input continues in pairs, it seems the branch nodes
    are squared with each call.


10.7 What's wrong with the expression (SETF (LENGTH X) 3)?

Length X is not a valid place description, it does not name a place where a pointer is stored.
  SETF will complain that it has no SETF method for LENGTH.



FUNCTIONS COVERED

Generalized assignment macros: SETF INCF DECF PUSH POP

Conditionals: WHEN UNLESS



---
Lisp Toolkit: BREAK and ERROR

The BREAK and ERROR functions are useful for debugging,
  and for making programs more resilient to bugs.

We have already been intriduced to BREAK when learning of recursive functions,
  but we haven't seen anything yet.

Both BREAK and ERROR take a format control string as their first argument.
  Additional arguments, if any, are used as arguments to the format directives,
    such as ~S, that appear in the control string.

BREAK prints out the message generated by the format control string,
  and then causes Lisp to enter the debugger.
    Execution can continue after debugging with a debugging command
      such as GO PROCEED RESTART or something or another.

    The BREAK function returns NIL, and evaluation proceeds with the next form.


Using BREAK to debug a function:

(defun analyze-profit (price commission-rate)
  (let* ((commission (* price commission-rate))
         (result
           (cond ((> commission 100) 'rich)
                 ((< commission 100) 'poor))))
    (format t "~&I predict you will be: ~S"
            result)
    result))

CL-USER> (analyze-profit 1600 0.15)

I predict you will be: RICH
RICH
CL-USER> (analyze-profit 3100 0.02)
I predict you will be: POOR
POOR
CL-USER> (analyze-profit 2000 0.05)
I predict you will be: NIL
NIL
CL-USER> (* 2000 0.05)
100.0


To begin debugging the function we can insert a call to BREAK in the body:

(defun analyze-profit (price comission-rate)
  (let* ((commission (* price commission-rate))
         (result
           (cond ((> commission 100) 'rich)
                 ((< commission 100) 'poor))))
    (break "Value of RESULT is ~S" result)
    (format t "~&I predict you will be: ~S"
            result)
    result))

We insert BREAK following the COND clauses.
  Now we can use the debugger to examine the control stack
    and check the values of local variables.


Value of RESULT is NIL
   [Condition of type SIMPLE-CONDITION]

Restarts:
 0: [CONTINUE] Return from BREAK.
 1: [RETRY] Retry SLIME REPL evaluation request.
 2: [*ABORT] Return to SLIME's top level.
 3: [ABORT] abort thread (#<THREAD "repl-thread" RUNNING {10041A8473}>)

Backtrace:
  0: (ANALYZE-PROFIT 2000 0.05)
      Locals:
        COMMISSION-RATE = 0.05
        PRICE = 2000
        RESULT = NIL
  1: (SB-INT:SIMPLE-EVAL-IN-LEXENV (ANALYZE-PROFIT 2000 0.05) #<NULL-LEXENV>)
      Locals:
        SB-KERNEL:LEXENV = #<NULL-LEXENV>
        SB-IMPL::ORIGINAL-EXP = (ANALYZE-PROFIT 2000 0.05)
  2: (EVAL (ANALYZE-PROFIT 2000 0.05))
      Locals:
        SB-IMPL::ORIGINAL-EXP = (ANALYZE-PROFIT 2000 0.05)
 --more--


It appears the SBCL debugger only computes top-level expressions.
  Its good enough, NIL isn't any of the values we were seeking anyway.

The issue is clear within the 0 1 and 2 backtrace elements in the control stack.

The error is that when the comission is equal to 100, neither COND clauses have a
  true test, so the function COND dumps to NIL.

The solution to the error is to replace the second test expression with T.

CL-USER> (defun analyze-profit (price commission-rate)
  (let* ((commission (* price commission-rate))
         (result
           (cond ((> commission 100) 'rich)
                 (t (< commission 100) 'poor))))
    (break "Value of RESULT is ~S" result)
    (format t "~&I predict you will be: ~S"
            result)
    result))

WARNING: redefining COMMON-LISP-USER::ANALYZE-PROFIT in DEFUN
ANALYZE-PROFIT
CL-USER> (analyze-profit 2000 0.05)
I predict you will be: POOR
POOR


Just like that.


The ERROR function takes the same arguments as BREAK: a format control string
  followeed by some optional arguments whose values will be printed by the format directives.

One difference between ERROR and BREAK is that ERROR never returns:
  You can never continue from ERROR.

Second is that ERROR merely reports the error and stops the program,
  it doesn't necessarily put you in the debugger, although most implementations will.

Programs can be made more resistant to bugs by inserting "sanity checks":
  expressions that check to make sure everything is normal,
    and call ERROR if something is wrong.

(defun average (x y)
  (unless (and (numberp x) (numberp y))
    (error "Arguments must be numbers:  ~S, ~S"
           x y))
  (/ (+ x y) 2.0))

CL-USER> (average 'a 'b)
; Evaluation aborted on #<SIMPLE-ERROR "Arguments must be numbers:  ~S, ~S" {1004370F13}>.
CL-USER> (average 5 2)
3.5


Common Lisp provides several other functions for reporting errors,
  WARN prints a warning message but does not stop the program from running.
    CERROR signals a "continuable error", the user is told and given the option to continue.

These functions, and the new Common Lisp condition system that allows
  the signalling and trapping of arbitrary error conditions is the shit
    and should be explored later.



---
Keyboard Exercise

This keyboard exercise requires us to extend our AIs strategy pool.


The first strategy extension considered is called the squeeze play,
  which can be made using either of the two diagonal triplets.

Squeeze Play:

    |   | O
  ---------
    | X |  
  ---------
  O |   |  


If X responds by choosing a corner, O only needs to choose the final corner to
  be in a position to get three-in-a-row two ways.

The defense against a squeeze play is selecting a side square, not a corner square.

Defended the squeeze play:

    | X | O
  ---------
    | X |  
  ---------
  O |   |  
 Your move: 8

    | X | O
  ---------
    | X |  
  ---------
  O | O |  

My move: 9
My strategy: block opponent

    | X | O
  ---------
    | X |  
  ---------
  O | O | X

Your move: 1

  O | X | O
  ---------
    | X |  
  ---------
  O | O | X

My move: 4
My strategy: block opponent

  O | X | O
  ---------
  X | X |  
  ---------
  O | O | X

Your move: 6

  O | X | O
  ---------
  X | X | O
  ---------
  O | O | X

Tie. Both y'all lose.
NIL


The second strategy extension is called the "two on one."

Like the squeeze play, it can be set using either diagonal triplet.
  In a two-on-one strategy, the opponent takes the center square, the computer takes a corner,
    and the opponent takes the opposite corner.

Two on one:

CL-USER> (play-one-game)
Would you like to go first?  (y or n) y

Your move: 5

    |   |  
  ---------
    | O |  
  ---------
    |   |  

My move: 2
My strategy: random move

    | X |  
  ---------
    | O |  
  ---------
    |   |  

Your move: 9

    | X |  
  ---------
    | O |  
  ---------
    |   | O

My move: 1
My strategy: block opponent

  X | X |  
  ---------
    | O |  
  ---------
    |   | O

Your move: 3

  X | X | O
  ---------
    | O |  
  ---------
    |   | O

My move: 6
My strategy: block opponent

  X | X | O
  ---------
    | O | 
  ---------
  X |   | O

Your move: 3.7

  X | X | O
  ---------
    | O | O
  ---------
  X |   | O

You win.
NIL


The only defense against a two on one attack is for X to take a corner instead of a side square.



EXERCISE
10.8 Type in the tic-tac-toe program as it appears in this book, with the second
       version of CHOOSE-BEST-MOVE. Test the program.

a. Set up global variable *CORNERS* to hold a list of the four corner positions.
     Set up a global variable named *SIDES* to hold a list of the four side squares.
       *NOTE* (FIND-EMPTY-POSITION BOARD *SIDES*) should return an empty side square,
         if there are any.

(setf *corners* '(1 3 7 9))


(setf *sides* '(2 4 6 8))



b. Write a function BLOCK-SQUEEZE-PLAY that checks the diagonals for an O-X-O pattern and
     defends by suggesting a side square as the best move. The function should return NIL
       if there is no squeeze play in progress. Otherwise, it should return a list containing
         the move number and a string explaining the strategy behind the move.
           Test the function on a sample board.

(defun block-squeeze-play (board)
  (sq-and-2 board *computer* *sides* 12
            "block squeeze play"))



c. Write function BLOCK-TWO-ON-ONE that checks the diagonals for an O-O-X or
     an X-O-O pattern and defends by suggesting a corner as the best move.
       The function should return NIL if there is no threat to respond.
        Otherwise return the list with the move and the strategy string.

(defun block-two-on-one (board)
  (sq-and-2 board *opponent* *corners* 12
            "block two-on-one"))



d. Modify the CHOOSE-BEST-MOVE function so that it tries these two defensive
     strategies before selecting a move at random.

(defun try-squeeze-play (board)
  (sq-and-2 board *opponent* nil 11
            "set up a squeeze play"))


(defun try-two-on-one (board)
  (sq-and-2 board *opponent* nil 11
            "set up a two-on-one"))


(defun sq-and-2 (board player pool v strategy)
  (when (equal (nth 5 board) player)
    (or (sq-helper board 1 9 v strategy pool)
        (sq-helper board 3 7 v strategy pool))))


(defun sq-helper (board c1 c2 val strategy pool)
  (when (equal val (sum-triplet
                    board (list c1 5 c2)))
    (let ((pos (find-empty-position
                board
                (or pool (list c1 c2)))))
      (and pos (list pos strategy)))))


(defun exploit-two-on-one (board)
  (when (equal (nth 5 board) *computer*)
    (or (exploit-two board 1 2 4 3 7)
        (exploit-two board 3 2 6 1 9)
        (exploit-two board 7 4 8 1 9)
        (exploit-two board 9 6 8 3 7))))


(defun exploit-two (board pos d1 d2 c1 c2)
  (and (equal (sum-triplet
               board
               (list c1 5 c2)) 21)
       (zerop (nth pos board))
       (zerop (nth d1 board))
       (zerop (nth d2 board))
       (list pos "exploit two-on-one")))


(defun choose-best-move (board)
  (or (make-three-in-a-row board)
      (block-opponent-win board)
      (block-squeeze-play board)
      (block-two-on-one board)
      (exploit-two-on-one board)
      (try-squeeze-play board)
      (try-two-on-one board)
      (random-move-strategy board)))



***
10 Advanced Topics

---
10.7 DO-IT-YOURSELF LIST SURGERY

You can use SETF on generalized variables to manipulate pointers directly.

Suppose we want to turn a chain of three cons cells into a chain
  of two cons cells by "snipping out" the middle cell.

In other words, we want to change the cdr of the first cell so that it points
  directly to the third cell.

(defun snip (lst)
  (setf (cdr lst) (cdr (cdr lst))))

CL-USER> (setf a '(no down payment))
(NO DOWN PAYMENT)
CL-USER> (setf b (cdr a))
(DOWN PAYMENT)
CL-USER> (snip a)
(PAYMENT)
CL-USER> a
(NO PAYMENT)
CL-USER> b
(DOWN PAYMENT)


We can use SETF to create the following circular structure.

(setf circ (list 'foo))  =>  (FOO)

(setf (cdr circ) circ)  =>  (FOO FOO FOO ...)


Modifying lists by directly changing the pointers in their
  cons cells is known as list surgery.

List surgery is useful in large, complex programs because it can be
  much faster to change a few pointers than to build a whole new list.
    This also reduces the program's memory requirements or causes it
      to garbage collect less frequently.


Advanced Common Lisp programming includes a lot of list surgery,
  but list surgery is considered unnecessary for beginners
    because of available built-in functions.



---
10.8 DESTRUCTIVE OPERATIONS ON LISTS

Destructive list operations are those that change the contents of a cons cell.

These types of operations should be done with care,
  circular list structures that are difficult to print can result
    because their effect on shared structures may be hard to predict.

None the less, destructive functions are powerful and efficient tools.

By convention destructive function names begin with an N.



10.8.1 NCONC

"En-konk" is derived from concatenate and is a destructive version of APPEND.

While APPEND creates a new list for its result,
  NCONC physically changes the last cons cell of its first input
    to point to its second input.

CL-USER> (setf x '(a b c))
(A B C)
CL-USER> (setf y '(d e f))
(D E F)

S> (append x y)

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |        |        |        |
 v        v        v        v        v        v
 A        B        C        D        E        F

Result:  (A B C D E F)

S> x

[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |
 v        v        v
 A        B        C

Result:  (A B C)

S> (nconc x y)

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |        |        |        |
 v        v        v        v        v        v
 A        B        C        D        E        F

Result:  (A B C D E F)

S> x

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |        |        |        |
 v        v        v        v        v        v
 A        B        C        D        E        F

Result:  (A B C D E F)

S> y

[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |
 v        v        v
 D        E        F

Result:  (D E F)


The X that is returned by NCONC is physically in computer memory
  while the Y that is input remains the same even after evaluation.

If the first input to NCONC is NIL, it just returns its second input.
  It is for this reason one cannot assume that (NCONC X Y)
    will alter the value of X.

CL-USER> (setf x (nconc x y))
(B C)
CL-USER> x
(B C)


Therefore, one should always use SETF to store the result
  of NCONC just in case.

I repeat, one should not assume that X is changed following
  the evaluation of an NCONC expression.

One should always use SETF to store the result of NCONC into X, just in case.


The NCONC function accepts any number of inputs in practice,
  and can destructively concatenate all inputs to form one long cons cell chain.

We can write our own version of NCONC that takes exactly two lists as input
  and makes the cdr of the last cell of the first list
    point to the second list.

It the returns a pointer to the beginning of the first list:

(defun my-nconc (arg-1 arg-2)
  (cond ((null arg-1) arg-2)
        (t (setf (cdr (last arg-1)) arg-2)
           arg-1)))

CL-USER> (setf x nil)
NIL
CL-USER> y
(B C)
CL-USER> (my-nconc x y)
(B C)
CL-USER> x
NIL



---
10.8.2 NSUBST

NSUBST is the destructive version of SUBST.

It modifies a list by changing the pointers in the cars of some cells.

CL-USER> (setf trees '(save all (them trees (them trees) in there)))
(SAVE ALL (THEM TREES (THEM TREES) IN THERE))
CL-USER> trees
(SAVE ALL (THEM TREES (THEM TREES) IN THERE))
CL-USER> (nsubst 'whales 'trees trees)
(SAVE ALL (THEM WHALES (THEM WHALES) IN THERE))
CL-USER> trees
(SAVE ALL (THEM WHALES (THEM WHALES) IN THERE))
CL-USER> (nsubst 'flopping '(them whales) trees :test #'equal)
(SAVE ALL (THEM WHALES FLOPPING IN THERE))

Since we were searching the tree for the list (THEM WHALES),
  we had to tell NSUBST to use EQUAL as the equality test.

The default EQL would not have worked.

CL-USER> (nsubst '(them whales) 'flopping trees :test #'equal)
(SAVE ALL (THEM WHALES (THEM WHALES) IN THERE))
CL-USER> (nsubst 'flopping '(them whales) trees :test #'eql)
(SAVE ALL (THEM WHALES (THEM WHALES) IN THERE))



---
10.8.3 Other Destructive Functions

Many other Common Lisp functions have destructive counterparts.

NREVERSE, NUNION, NINTERSECTION, and NSET-DIFFERENCE for example.


There are only two exceptions to the N naming convention.

APPEND was the very first Lisp function to have a destructive counterpart.
  Its destructive version was called NCONC (for concatenate).
    Years later the N thing started happening and that was that.

There is no NAPPEND.


REMOVE is the other exception.

The destructive yang to REMOVEs yen is DELETE for historical reasons ofcourse.

In the Lisp programmer world, which is the one you live in now,
  N is commonly held to stand for "noncopying" or "nonconsing."



---
10.9 PROGRAMMING WITH DESTRUCTIVE OPERATIONS

One place where destructive operations are especially useful
  is in making small changes to complex list structures,
    such as with the MAKE-MOVE function in the tic-tac-toe program.

(defun make-move (player pos board)
  (setf (nth pos board) player)
  board)


The give-away is the SETF within the function definition body.
  If it wasn't too obvious.


Suppose we have the following table stored in the global variable *THINGS*:

(setf *things* '((object1 large green shiny cube)
                 (object2 small red dull metal cube)
                 (object3 red small dull plastic cube)))


How can we change the symbol OBJECT1 to FROB?

S> (assoc 'object1 *things*)

[*|*]---->[*|*]--->[*|*]--->[*|*]--->[*|*]--->NIL
 |         |        |        |        |
 v         v        v        v        v
OBJECT1   LARGE    GREEN    SHINY    CUBE

Result:  (OBJECT1 LARGE GREEN SHINY CUBE)


We can use SETF on this list to physically change it by storing
  into the car half of the first cons cell, the cons containing
    the symbol OBJECT1.

Since this is a destructive operation on the list,
  the value of *THINGS* will change as well.

Let's go ahead and write a general function for renaming objects:

S> (car (assoc 'object1 *things*))

OBJECT1


This expression can retrieve the car of the entry list.

We combine this with SETF and store the return value to NEWNAME.

(defun rename-element (obj newname)
  (setf (car (assoc obj *things*)) newname))

CL-USER> (rename-element 'object1 'frob)
FROB
CL-USER> *things*
((FROB LARGE GREEN SHINY CUBE) (OBJECT2 SMALL RED DULL METAL CUBE)
 (OBJECT3 RED SMALL DULL PLASTIC CUBE))


We can use NCONC to add a new property to an object already in *THINGS*.

(defun add-property (obj prop)
  (nconc (assoc obj *things*) (list prop)))

CL-USER> (assoc 'object2 *things*)
(OBJECT2 SMALL RED DULL METAL CUBE)
CL-USER> (add-property 'object2 'sharp-edged)
(OBJECT2 SMALL RED DULL METAL CUBE SHARP-EDGED)
CL-USER> *things*
((FROB LARGE GREEN SHINY CUBE) (OBJECT2 SMALL RED DULL METAL CUBE SHARP-EDGED)
 (OBJECT3 RED SMALL DULL PLASTIC CUBE))



EXERCISES
10.9 Write a destructive function CHOP that shortens any non-NIL
       list to a list of one element.

(defun chop (lst)
  (if (consp lst)
      (setf (cdr lst)
            nil))
  x)

CL-USER> (chop '(fee fie foe fum))
(FEE)
CL-USER> (setf x '(a b c d))
(A B C D)
CL-USER> (chop x)
(A)
CL-USER> x
(A)



10.10 Write function NTACK that destructively tacks a symbol onto a list.

(defun ntack (x e)
  (nconc x (list e)))

CL-USER> x
(A B)
CL-USER> y
C
CL-USER> (ntack x y)
(A B C)



10.11 Draw the cons cell structure that results from
        the following sequence of operations.

(setf x '(a b c))

(setf (cdr (last x)) x)


S> (setf x '(a b c))

[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |
 v        v        v
 A        B        C

Result:  (A B C)

S> (setf (cdr (last x)) x)

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->etc.
 |        |        |        |        |        |        |        |
 v        v        v        v        v        v        v        v
 A        B        C        A        B        C        A        B


I knew it, this shit almost killed my Lisp.

S> (setf (cdr (last x)) x)

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->etc.
 |        |        |        |        |        |        |        |
 v        v        v        v        v        v        v        v
 A        B        C        A        B        C        A        B


; No value
CL-USER> ; No value; Evaluation aborted on #<SB-KERNEL::HEAP-EXHAUSTED-ERROR {100005D793}>.


It did in fact kill your Lisp.



---
10.10 SETQ AND SET

SETQ is an archaic version of SETF.

SET was in Lisp 1.5 and lacked lexical scoping.
  This limitation only allowed for evaluation if the first argument was a symbol.

In Common Lisp SET stores a value in the value cell of a symbol.
  It assigns to the global variable named by the symbol,
    even if a local variable exists with the same name.

The SYMBOL-VALUE function returns the contents of a symbol's value cell.
  Using SET and the SYMBOL-VALUE functions:

(setf duck 'donald)    ;The global duck.

CL-USER> (setf duck 'donald)
DONALD
CL-USER> duck
DONALD
CL-USER> (symbol-value 'duck)
DONALD
CL-USER> (list duck)
(DONALD)
CL-USER> (defun test1 (duck)
           (list duck
                 (symbol-value 'duck)))
TEST1
CL-USER> (test1 'huey)
(HUEY DONALD)
CL-USER> (defun test2 (duck)
           (set 'duck 'daffy)
           (list duck
                 (symbol-value 'duck)))
TEST2
CL-USER> (test2 'huey)
(HUEY DAFFY)
CL-USER> duck
DAFFY



***
11
Iteration and Block Structure

---
11.1 INTRODUCTION

The word iterate means to repeat a thing over and over.

Recursion and applicative operators are repetitive,
  but iteration (also known as looping) is the simplest repetitive control structure.

Virtually all programming languages provide some way to write iterative expressions.


Common Lisp iteration is more sophisticated than other languages'.

Sophistication provided by the powerful built-in iteration constructs DO and DO*,
  as well as the simple ones DOTIMES and DOLIST.

In this chapter we will also learn about block structure,
  a concept borrowed from the Algol family of languages (Pascal, Modula, Ada, etc)

We will demonstrate how to group Lisp expressions into blocks and its usefulness.



---
11.2 DOTIMES AND DOLIST

The simplest iterative forms are DOTIMES and DOLIST. Both are macro functions,
  meaning they don't evaluate their arguments:

(DOTIMES (index-var n [result-form])
  body)


DOTIMES evaluates the forms in its body N times,
  while stepping an index variable from zero through n-1.
    It then returns the value of the result-form,
      which defaults to NIL if omitted.

CL-USER> (dotimes (i 4)
           (format t "~&I is ~S." i))
I is 0.
I is 1.
I is 2.
I is 3.
NIL


DOLIST has the same syntax as DOTIMES, but instead of counting,
  it steps through the elements of a list.

CL-USER> (dolist (e '(face bung hole) 'bungaroo)
           (format t "~&Poop on your ~S." e))
Poop on your FACE.
Poop on your BUNG.
Poop on your HOLE.
BUNGAROO


You see, in this example the value returned by DOLIST is the symbol FLOWERS.



---
11.3 EXITING THE BODY OF A LOOP

The RETURN function can be used to exit the body
  of an iteration form immediately without looping further.

RETURN takes one input, which is the value to return once breaking from the loop.
  When RETURN is used to force an exit from an iteration form,
    the result-form expression (if provided) is ignored.


Here is an iterative function called FIND-FIRST-ODD
  that returns the first odd number in a list.

FIND-FIRST-ODD uses DOLIST to loop through the elements of the list,
  as well as RETURN to exit the loop as soon as an odd number is found.

If the list contains no odd numbers, then when the loop is finished,
  DOLIST will return NIL.

An interesting point about FIND-FIRST-ODD is that the body of the loop
  contains two forms instead of one.

Loop bodies may contain any number of forms.

(defun find-first-odd (lst)
  (dolist (e lst)
    (format t "~&Testing ~S .." e)
    (when (oddp e)
      (format t ".. found the odd number.")
      (return e))))

CL-USER> (setf lst '(2 4 6 7 8 10))
(2 4 6 7 8 10)
CL-USER> (find-first-odd lst)
----Enter FIND-FIRST-ODD
|     Arg-1 = (2 4 6 7 8 10)
Testing 2 ..
Testing 4 ..
Testing 6 ..
Testing 7 .... found the odd number.
 \--FIND-FIRST-ODD returned 7
7


WHEN comes across an odd number, so it evaluates the forms that follow.
  These expressions provide the value to be returned.


FIND-FIRST-ODD returns NIL if no odd number is found.

CL-USER> (find-first-odd '(2 4 6 8))
Testing 2 ..
Testing 4 ..
Testing 6 ..
Testing 8 ..
NIL


The following is an example where specifying an explicit result-form
  with DOLIST is useful.

The function CHECK-ALL-ODD uses DOLIST to verify that all elements are odd.
  If so, DOLIST returns the symbol T at the completion of the loop.

If any non-odd element is found, the function immediately returns
  from the loop with a value of NIL.

(defun check-all-odd (lst)
  (dolist (e lst t)
    (format t "~&Checking ~S for oddity .." e)
    (if (not (oddp e)) (return nil))))

CL-USER> (setf x '(1 3 5 7))
(1 3 5 7)
CL-USER> (setf y '(1 3 4 7))
(1 3 4 7)
CL-USER> (check-all-odd x)
Checking 1 for oddity ..
Checking 3 for oddity ..
Checking 5 for oddity ..
Checking 7 for oddity ..
T
CL-USER> (check-all-odd y)
Checking 1 for oddity ..
Checking 3 for oddity ..
Checking 4 for oddity ..
NIL


CHECK-ALL-ODD-TWO seems to work as well:

CL-USER> (defun check-all-odd-two (lst)
           (dolist (e lst t)
             (format t "~&Checking ~S for oddity .." e)
             (if (evenp e) (return nil))))
CHECK-ALL-ODD-TWO
CL-USER> (check-all-odd-two x)
Checking 1 for oddity ..
Checking 3 for oddity ..
Checking 5 for oddity ..
Checking 7 for oddity ..
T
CL-USER> (check-all-odd-two y)
Checking 1 for oddity ..
Checking 3 for oddity ..
Checking 4 for oddity ..
NIL



EXERCISES
11.1 Write an iterative version of the MEMBER function, called IT-MEMBER
       that returns T if its input appears in its second input; the function
         does not need to return a sublist of its second input.

(defun it-member (item lst)
  (dolist (e lst)
    (when (equal item e) (return t))))

(defun it-member-two (obj lst)
  (dolist (e lst)
    (if (equal obj e) (return t))))

CL-USER> y
(1 3 4 7)
CL-USER> (it-member '4 y)
T
CL-USER> (it-member-two '4 y)
T
CL-USER> (it-member '5 y)
NIL
CL-USER> (it-member-two '5 y)
NIL


11.2 Write an iterative version of ASSOC called IT-ASSOC.

(defun it-assoc (key table)
  (dolist (entry table)
    (if (equal key (first entry))
        (return entry))))

CL-USER> words
((ONE UN) (DEAUX TWO) (TROIX THREE) (QUATRE FOUR))
CL-USER> (it-assoc 'trois words)
(TROIS THREE)
CL-USER> (assoc 'trois words)
(TROIS THREE)


11.3 Write a recursive version of CHECK-ALL-ODD, that produces
       the same result as the iterative version.

(defun rec-check-all-odd (lst)
  (cond ((null lst) t)
        (t (format t "~&Checking ~S .."
                   (first lst))
           (unless (evenp (first lst))
             (rec-check-all-odd (rest lst))))))

CL-USER> (rec-check-all-odd y)
----Enter REC-CHECK-ALL-ODD
|     Arg-1 = (1 3 4 7)
Checking 1 ..
|   ----Enter REC-CHECK-ALL-ODD
|   |     Arg-1 = (3 4 7)
Checking 3 ..
|   |   ----Enter REC-CHECK-ALL-ODD
|   |   |     Arg-1 = (4 7)
Checking 4 ..
|   |    \--REC-CHECK-ALL-ODD returned NIL
|    \--REC-CHECK-ALL-ODD returned NIL
 \--REC-CHECK-ALL-ODD returned NIL
NIL
CL-USER> (rec-check-all-odd x)
----Enter REC-CHECK-ALL-ODD
|     Arg-1 = (1 3 5 7)
Checking 1 ..
|   ----Enter REC-CHECK-ALL-ODD
|   |     Arg-1 = (3 5 7)
Checking 3 ..
|   |   ----Enter REC-CHECK-ALL-ODD
|   |   |     Arg-1 = (5 7)
Checking 5 ..
|   |   |   ----Enter REC-CHECK-ALL-ODD
|   |   |   |     Arg-1 = (7)
Checking 7 ..
|   |   |   |   ----Enter REC-CHECK-ALL-ODD
|   |   |   |   |     Arg-1 = NIL
|   |   |   |    \--REC-CHECK-ALL-ODD returned T
|   |   |    \--REC-CHECK-ALL-ODD returned T
|   |    \--REC-CHECK-ALL-ODD returned T
|    \--REC-CHECK-ALL-ODD returned T
 \--REC-CHECK-ALL-ODD returned T
T



---
11.4 COMPARING RECURSIVE AND ITERATIVE SEARCH

For searching a flat list, iteration is simpler to use than recursion.
  A flat list is a list of atoms. Since it contains no lists as elements,
    the list is called flat rather than nested.

It may also be more efficient to use iteration in some implementations.

Compare,

(defun rec-find-first-odd (lst)
  (if (null lst)
      nil
      (if (oddp (car lst))
          (car lst)
          (rec-find-first-odd (cdr lst)))))

(defun cond-find-first-odd (lst)
  (cond ((null lst) nil)
        ((oddp (first lst)) (first lst))
        (t (cond-find-first-odd (rest lst)))))

(defun it-find-first-odd (lst)
  (dolist (e lst)
    (if (oddp e) (return e))))

(defun applica-find-first-odd (lst)
  (find-if #'oddp lst))


These are recursive, applicative, and iterative versions of FIND-FIRST-ODD.


There are a couple of small advantages to the iterative version.

First, the termination test is implicit;
  DOLIST always stops when it gets to the end of the list.
    The recursive versions require their own clauses for this.

Second, in the iterative version the variable E names successive elements of the list.
  The recursive versions don't provide a convenient method of storing these names.
    Writing out (FIRST LST) or (CDR LST) is the only way to refer to these element names.


In other situations recursion may be simpler and more natural to the Lisp programmer.
  For example, searching a tree can easily be done with CAR/CDR recursion.

Iterative searching solutions do exist, but lack style and elegance.



---
11.5 BUILDING UP RESULTS WITH ASSIGNMENT

Repetitively building up a result with recursive function calls
  was shown in Chapter 8.

Iterative programs are built up through repetitive assignment.

(defun it-fact (n)
  (let ((prod 1))
    (dotimes (i n prod)
      (setf prod (* prod (+ i 1))))))


(defun if-fact (n)    ;Recursively.
  (if (zerop n)
      1
      (* n (if-fact (- n 1)))))

First we create an auxiliary variable PROD with an initial value of one.
  This value is repetitively updated in the body of the DOTIMES expression.
    Since the index variable I varies from zero to N-1 rather than from one to N,
      we must ass one to I each time we reference its value in the body.

Therefore (IT-FACT 5) counts from 0 to 4,
  but multiplies PROD by the numbers 1 through 5.


Writing an iterative set-intersection function.

The variable E is bound to successive elements of the SET1.
  If E is a member of SET2, it gets pushed onto RESULT-SET, otherwise it doesn't.
    When all the elements of SET1 have been processed, DO-LIST returns
      the value of RESULT-SET.

(defun it-intersection (set1 set2)
  (let ((result-set nil))
    (dolist (e set1 result-set)
      (when (member e set2)
        (push e result-set)))))

CL-USER> (setf set1 '(f a c e))
(F A C E)
CL-USER> (setf set2 '(c l o v e))
(C L O V E)
CL-USER> (it-intersection set1 set2)
(E C)



EXERCISES

11.4 Write an iterative version of LENGTH, called IT-LENGTH.

Fuck it, here is two iterative versions:

(defun it-length (x)
  (let ((n 0))
    (dolist (e x n)
      (incf n))))


(defun our-length (lst)
  (let ((len 0))    ;From ANSI-Common-Lisp by Paul Graham.
    (dolist (obj lst)
      (setf len (+ 1 len)))
    len))


Here is two recursive versions:

(defun rec-our-length (lst)
  (if (null lst)
      0
      (+ (rec-our-length (cdr lst)) 1)))


(defun cond-length (lst)
  (cond ((null lst) 0)
        (t (+ 1 (cond-length (rest lst))))))


11.5 Write an iterative version of NTH, call it IT-NTH.

(defun it-nth (n lst)
  (dotimes (i n (first lst))    ;Iterative.
    (pop lst)))


(defun cond-nth (n lst)
  (cond ((null lst) nil)    ;Conditionally recursive.
        ((zerop n) (first lst))
        (t (cond-nth (- n 1) (rest lst)))))


(defun if-nth (n lst)
  (if (null lst)    ;If it can be conditionally recursive ..
      nil
      (if (zerop n)
          (car lst)
          (if-nth (- n 1) (cdr lst)))))


Remember, PUSH and POP destructively add or remove
  top-level list elements.



11.6 Write an iterative version of UNION, call it IT-UNION.

(defun it-union (lst1 lst2)
  (dolist (e lst1 lst2)
    (unless (member e lst2)
      (push e lst2))))


(defun it-union-two (lst1 lst2)
  (dolist (e lst1 lst2)
    (unless (member e lst2)
      (setf lst2 (cons e lst2)))))



---
11.6 COMPARING DOLIST WITH MAPCAR AND RECURSION

MAPCAR is the simplest way to apply a function to every element of a list.

Consider the problem of squaring a list of numbers.

Applicatively,

(defun appl-show-squares (num-lst)
  (mapcar #'(lambda (n) (* n n))
          num-lst))


The MAPCAR operator takes care of the whole input list,
  properly stops at the end, and conses the result list.


All of those operations must be handled explicitly in the recursive version.

Recursively,

(defun rec-show-squares (num-list)
  (cond ((null num-list) nil)
        (t (cons (* (first num-list) (first num-list))
                 (rec-show-squares (rest num-list))))))


If we use DOLIST to write an iterative solution,
  the termination test will be handled automatically,
    but we still have to build up the result with an explicit assignment.

(defun it-show-squares (numlst)
  (let ((result nil))
    (dolist (e numlst (reverse result))
      (push (* e e) result))))    ;Remember this result is being REVERSEd


It is typical for iterative solutions needing to be reversed.
  Since the function proceeds through the input list from left to right,
    and pushes each result onto the front of the result list,
      the result list ends up backwards.

The square of the first number in the input list is the last number
  in the result list, and so on.

CL-USER> (acl-show-squares 1 4)
1 1
2 4
3 9
4 16
DONE
CL-USER> (it-show-squares '(1 2 3 4))
(1 4 9 16)


If we have been reading the Advanced Topics sections,
  we would understand why experienced Lisp programmers prefer to use
    the destructive function NREVERSE at the end of iteration instead
      of using REVERSE.



EXERCISES
11.7 Why did the IT-INTERSECTION function return elements in reverse
       order from the order they appeared in the first input?
         How can this be corrected?


(defun it-intersection (set1 set2)
  (let ((result-set nil))
    (dolist (e set1 result-set)
      (when (member e set2)
        (push e result-set)))))

CL-USER> (it-intersection '(f a c e) '(c l o v e))
(E C)
; compiling (DEFUN IT-INTERSECTION-TWO ...)
CL-USER> (it-intersection-two '(f a c e) '(c l o v e))

(C E)


(defun it-intersection-two (set1 set2)
  (let ((result-set nil))
    (dolist (e set1 (reverse result-set))
      (when (member e set2)
        (push e result-set)))))



11.8 Write an iterative version of REVERSE, called IT-REVERSE.

(defun it-reverse (lst)
  (let ((result nil))
    (dolist (e lst result)
      (push e result))))

CL-USER> (it-reverse '(e d c b a))

(A B C D E)


(defun if-reverse (lst)
  (if (null lst)
      nil
      (append (reverse (cdr lst))
              (list (car lst)))))



---
11.7 THE DO MACRO

DO is the most powerful iteration form in Lisp.

It can bind any number of variables like LET;
  it can step any number of index variables any way you like;
    and it allows us to specify our own test to break the loop.

DOs syntax can be quite complex.

(do ((var1 init1 [update1])
     (var2 init2 [update2])
     ...)
    (test action-1 ... action-n)
 body)


First, each variable in the DO variable list is assigned its initial value.

Then the test form is evaluated.

If the result is true, DO evaluates the termination actions
  and returns the value of the last one.

Otherwise DO evaluates the forms of its body in order.

The body may contain RETURNs which force the DO
  to return immediately rather than to iterate further.

When DO reaches the end of the body,
  it begins the next iteration of the loop.

First, each variable in the variable list is updated
  by setting it to the value of its update expression.
    If the update expression is omitted,
      the variable will be left unchanged.

When all the variables have been updated,
  the termination test is tried again, and if it is true,
    DO evaluates the termination actions.
      Otherwise it goes on to evaluate the body again.


This is a function LAUNCH written with DO.

Note that it uses only one index variable, CNT,
  which it determines from N down to zero.

It is possible to write LAUNCH with DOTIMES instead,
  but it would lack elegance ...
    DOTIMES steps the index in the opposite direction.

(defun do-launch (n)
  (do ((cnt n (- cnt 1)))
      ((zerop cnt) (format t "Blast off!"))
    (format t "~S..." cnt)))

; compiling (DEFUN DO-LAUNCH ...)
CL-USER> (do-launch 5)
5...4...3...2...1...Blast off!
NIL



EXERCISES
11.9 Show how to write CHECK-ALL-ODD using DO.

(defun do-check-all-odd (lst)
  (do ((z lst (rest z)))
      ((null z) t)
    (format t "~&Checking ~S ..." (first z))
    (if (evenp (first z))
        (return nil))))


(defun dolist-check-all-odd (lst)
  (dolist (e lst t)
    (format t "~&Checking ~S ..." e)
    (if (not (oddp e))
        (return nil))))


11.10 Write DOTIMES-LAUNCH.

(defun dotimes-launch (n)
  (dotimes (i n)
    (format t "~S..." (- n i)))
  (format t "Blast off!"))


(defun do-launch (n)
  (do ((cnt n (- cnt 1)))
      ((zerop cnt) (format t "Blast off!"))
    (format t "~S..." cnt)))


Here is an implementation of COUNT-SLICES using DO.

This loop uses two index variables CNT starts at zero
  and is used to build up the result.
    Z steps through successive RESTs of the loaf.

(defun do-count-slices (loaf)
  (do ((cnt 0 (+ cnt 1))
       (z loaf (rest z)))
      ((null z) cnt)))


var-1: cnt
init-1: 0
update1: (+ cnt 1)

var-2: z
init-2: loaf
update-2: (rest z)

*no-body*

test: (null z)
action-1: cnt


This particular DO has an empty body:
  All the computation is done by expressions in the variable list.

Suppose we want to evaluate (COUNT-SLICES '(X X)).

When the DO is entered, CNT initializes to zero,
  and Z initializes to (X X).

The termination test follows;
  Since Z is not NIL, the loop does not terminate.

The body is empty, so DO goes to update its variables.

CNT is set to the value of (+ CNT 1), which is one.

Z is set to (REST Z), which is the list (X).

Now DO tries the termination test again.

Z is still not NIL, so iteration occurs once more.

This time CNT is set to two, and Z is set to NIL.

Now the termination test is true.

The expression to be evaluated and returned when the loop terminates is CNT,
  so DO returns two.



---
11.8 ADVANTAGES OF IMPLICIT ASSIGNMENT

DO has several advantages over DOTIMES and DOLIST.

It can step the index variables any way you like,
  it can count down or up for example.

DO can also bind multiple variables.
  This makes it easy for us to build up a result
    in the variable list of the DO;
      we dont need a surrounding LET
        or an explicit SETF.

(defun do-fact (n)
  (do ((i n (- i 1))
       (result 1 (* result i)))
      ((zerop i) result)))


DO-FACT counts down rather than up,
  while also making use of the binding property of DO.

When we compute (DO-FACT 5),
  initially i is set to 5
    and RESULT to one.

When it comes time to update the variables,
  the expression (- i 1) evaluates to four,
    and RESULT is set to five.

The next time through the loop,
  (- i 1) evaluates to three,
    and RESULT evaluates to 5.

The next loop, (- i 1) evaluates to three,
  and (* RESULT i) evaluates to 5*4 or 20 etc..


Both COUNT-SLICES and FACT have empty bodies.
  This is often the reason why we want to use DO.

We can make the assignments implicit by doing
  all the work in the update expressions within the variable list,
    we never have to write a PUSH or SETF.

Writing iterative functions in this way
  is considered elegant and a good practice.


As with most general things though, doing all the work
  in our update expressions isn't always the best method.

If the update is a conditional,
  it is not a good idea to do our computations
    within the update expressions.


The DO macro form:

(DO ((var-1 init-1 [update-1])
     (var-2 init-2 [update-2])
     ...)
    (test action-1 ... action-n)
 body)


IT-INTERSECTION has a null body:

(defun it-intersection (x y)
  (do ((x1 x (rest x1))
       (result nil (if (member (first x1) y)
                       (cons (first x1) result)
                       result)))
      ((null x1) result)))


This is a shitty version of IT-INTERSECTION because the DO wants to update
  the RESULT every time it goes through the loop.

    We only want the value to change when (FIRST X1) is a member of Y.

A more elegant version can be written by omitting the update expression for
  RESULT in the variable list.

    Instead we perform the update with a conditional PUSH in the body:

(defun it-intersection-elegantly (lst1 lst2)
  (do ((x1 lst1 (rest x1))
       (result nil))
      ((null x1) result)
    (when (member (first x1) lst2)
      (push (first x1) result))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  *NOTE*
;;    (when test
;;      body)
;;      
;;    WHEN returns NIL if it hits one or the return values of the last T.
;;
;;


If all we need to do is iterate over the elements of a list,
  DOLIST is more concise than DO.
    But DO is more general.

We can use DO to iterate over several lists at the same time,
  like with the FIND-MATCHING-ELEMENTS function:

(defun it-find-matching-elements (lst1 lst2)
  (do ((x lst1 (rest x))
       (y lst2 (rest y)))
      ((or (null x) (null y) nil))
    (if (equal (first x)
               (first y))
        (return (first x)))))


This function compares corresponding list elements from two input lists
  until it finds two that are equal, such as the third element here:

CL-USER> (it-find-matching-elements '(b i r d) '(c a r p e t))
R



---
11.9 THE DO* MACRO

Here is FIND-FIRST-ODD written with DO:

(defun do-find-first-odd (lst)
  (do ((x lst (rest x)))
      ((null x) nil)
    (if (oddp (first x)) (return (first x)))))


The conventional DO method is followed,
  A variable X is stepped through successive RESTs of the input.
    Within the body, we write (FIRST X) to refer to elements of the input list.


The DO* macro has the same syntax as DO, but it creates and updates
  variables sequentially like LET*, rather than all at once like LET.

One advantage of DO* in a function like DO-FIND-FIRST-ODD is that it
  allows us to define a second index variable to hold successive elements of a list,
    while the first index variable holds the successive cdrs:

(defun do*-find-first-odd (lst)
  (do* ((x lst (rest x))
        (e (first x) (first x)))
       ((null x) nil)
    (if (oddp e) (return e))))


Notice that the index variable E uses the expression (FIRST X)
  for both its initial value and the update value.

This is necessary because if the update value were omitted, the value of E
  would not change each time it went through the loop.

It is also important that E appear after X in the variable list of the DO* form,
  Es value depends on Xs value.


;;The DO macro form.

(DO ((var-1 init-1 [update-1])
     (var-2 init-2 [update-2])
     ...)
    (test action-1 ... action-n)
 body)



EXERCISES

11.11 Rewrite the following function to use DO* instead of DOLIST.

(defun dolist-find-largest (lst)
  (let ((largest (first lst)))
    (dolist (e (rest lst)
               largest)
      (when (> e largest)
        (setf largest e)))))


(defun do*-find-largest (lst)
  (do* ((largest (car lst))
        (z (cdr lst) (cdr z))
        (e (car z) (car z)))
       ((null z) largest)
    (when (> e largest)
      (setf largest e))))


(defun if-do*-find-largest (lst)
  (do* ((largest (first lst))
        (z (rest lst) (rest z))
        (element (first z) (first z)))
       ((null z) largest)
    (if (> element largest)
        (setf largest element))))



11.12 Rewrite the following function to use DO instead of DOTIMES.

(defun dotimes-power-of-2 (n)    ;2 to the Nth power.
  (let ((result 1))
    (dotimes (i n result)
      (incf result result))))


(defun do-power-of-two (n)    ;Two to the Nth power.
  (do ((result 1 (+ result result))
       (i 0 (+ i 1)))
      ((equal i n) result)))


;;The DO macro form.

(DO ((var-1 init-1 [update-1])
     (var-2 init-2 [update-2])
     ...)
    (test action-1 ... action-n)
 body)



11.13 Rewrite the following function using DOLIST instead of DO*.

(defun do*-first-non-integer (lst)
  (do* ((z lst (rest z))
        (element (first z) (first z)))
       ((null z) 'none)
    (unless (integerp element)
      (return element))))


(defun dolist-first-non-integer (lst)
  (dolist (element lst 'none)
    (unless (integerp element)
      (return element))))


(defun dolist-when-first-int (lst)
  (dolist (element lst 'none)
    (when (not (integerp element))
      (return element))))



11.14 Suppose we modified the function DO*-FIND-FIRST-ODD by swapping DO* for DO.

(defun do*-find-first-odd (lst)
  (do* ((x lst (rest x))
        (e (first x) (first x)))
       ((null x) nil)
    (if (oddp e) (return e))))


(defun buggy-do-find-first-odd (lst)
  (do ((x lst (rest x))
        (e (first x) (first x)))
       ((null x) nil)
    (if (oddp e) (return e))))


; compiling (DEFUN BUGGY-DO-FIND-FIRST-ODD ...)

; file: C:/Users/tylerbrw/AppData/Local/Temp/slime25
; in: DEFUN BUGGY-DO-FIND-FIRST-ODD
;     (FIRST X)
; ==>
;   (CAR X)
; 
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::X
; 
; compilation unit finished
;   Undefined variable:
;     X
;   caught 1 WARNING condition


X is never defined and cannot be used as a variable.


;;The DO macro form.

(DO ((var-1 init-1 [update-1])
     (var-2 init-2 [update-2])
     ...)
    (test action-1 ... action-n)
 body)



11.15 The following version of the SUBTLE-BUGGY-DO-FFO function contains a subtle bug.
        Find it.

(defun subtle-buggy-do-ffo (lst)
  (do ((z lst (rest z))
       (element (first lst) (first z)))
      ((null z) nil)
    (if (oddp element) (return element))))


NIL is returned if the last number in the list is odd, instead of the odd number.
  Due to parallel assignment, E is assigned the last number in the list
    at the same time that Z becomes NIL.

When Z is NIL the DOs termination test is true,
  the body is never evaluated and the last element of
    the list is never tested for being odd.

(defun fixed-subtle-buggy-do-ffo (lst)
  (do ((z lst (rest z))
       (element (first lst) (first z)))
      ((null z) element)
    (if (oddp element) (return element))))


Just swap the NIL for the ELEMENT value in the action part of the form.



---
11.10 INFINITE LOOPS WITH DO

DO can be made to loop infinitely by specifying NIL as the termination test.

An application for this sort of technique is useful when we need the function
  to read something from the keyboard:

;;DO me infinitely baby.

(defun do-read-a-num ()
  (do ((answer nil))
      (nil)
    (format t "~&Type a number: ")
    (setf answer (read))
    (if (numberp answer)
        (return answer))
    (format t
            "~&Bitch, ~S isn't a number. Give me a number DAMNIT."
            answer)))

CL-USER> (do-read-a-num)

Type a number: foo

Bitch, FOO isn't a number. Give me a number DAMNIT.
Type a number: fung

Bitch, FUNG isn't a number. Give me a number DAMNIT.
Type a number: 1

1



---
11.11 IMPLICIT BLOCKS

(DOLIST (index-var list [result-form])
  body)


In Common Lisp function bodies are contained in implicit blocks,
  an the function name also serves as the block name.

A block is a sequence of expressions that can be exited at any point
  via the RETURN-FROM special function.

(defun block-dolist-ffo (lst)
  (format t "~&Looking for the odd number ..")
  (dolist (element lst)
    (when (oddp element)
      (format t "~&Found ~S." element)
      (return-from block-dolist-ffo element)))
  (format t "~&None found.")
  'none)

Index-var  =>  element
List  =>  lst
Result-form  =>  none
Body  =>  (when ..


The body of FIND-FIRST-ODD is a block named FIND-FIRST-ODD,
  the arguments to RETURN-FROM are a block name and a result expression;
    the block name is not evaluate, so it should not be quoted.

CL-USER> (block-dolist-ffo '(2 4 6 7 8))
Looking for the odd number ..
Found 7.
7
CL-USER> (block-dolist-ffo '(2 4 6 8 10))
Looking for the odd number ..
None found.
NONE


In BLOCK-DOLIST-FFO we used RETURN-FROM to exit the body of FIND-FIRST-ODD,
  not just the body of DOLIST.

RETURN-FROM returns from the closest enclosing block with the specified name.

The bodies of looping forms such as DOTIMES DOLIST DO and DO*
  are enclosed in implicit blocks named NIL.

The expression (RETURN x) is actually just an abbreviation for (RETURN-FROM NIL x).

So in the body of BLOCK-DOLIST-FFO, the RETURN-FROM is nested inside a block named NIL,
  which is in turn contained in a block named BLOCK-DOLIST-FFO.


RETURN-FROM can be necessary in functions using applicative operators:

(defun mapcar-sq-list (lst)
  (mapcar
   #'(lambda (e)
       (if (numberp e)
           (* e e)
           (return-from mapcar-sq-list 'nope)))
   lst))


CL-USER> (mapcar-sq-list '(1 2 3 4 5))

(1 4 9 16 25)
CL-USER> (mapcar-sq-list '(1 2 three four 5))
NOPE


The function MAPCAR-SQ-LIST uses the applicative operator MAPCAR to square a list of numbers.
  If any elements of the input list are not numbers,
    the function returns the symbol NOPE.

The RETURN-FROM inside the lambda expression exits from there,
  the MAPCAR form, and the body of the SQUARE-LIST function itself.

Besides the implicit blocks containing the function bodies,
  blocks may also be defined explicitly via the BLOCK special function,
    useful for advanced applications.


*NOTE* The expression (RETURN x) is actually just an abbreviation for (RETURN-FROM NIL x).



SUMMARY

DOLIST and DOTIMES are the simplest iteration forms.

DO and DO* are more powerful because they can step several variables at once
  using arbitrary update expressions and terminal tests.
    But for simple problems like searching a list,
      DOLIST is more straightforward.

All of the iteration forms make implicit assignments to their index variables.
  In this way the loop handles assignment rather than writing a SETF.

Sometimes, it is better to build up results using explicit assignment in the loop body.
  This is especially true when we are using conditional assignment,
    like in the IT-INTERSECTION function.

Function names serve as implicit block names.
  We can use RETURN-FROM to exit a function from anywhere in its body.



REVIEW EXERCISES

11.16 How do the variable lists of LET and DO differ?

(LET ((var-1 value-1)
      (var-2 value-2)
      ...
      (var-n value-n))
  body)


The variable list of a LET contains pairs of form (variable value).


(DO ((var-1 init-1 [update-1])
     (var-2 init-2 [update-2])
     ...)
    (test action-1 ... action-n)
  body)


The variable list of a DO contains triples of form, (variable init-value update-expression).
  If the third element is omitted, the variable is not updated each time through the loop.
    In this case, DO treats the variable just as a LET would.



11.17 What value is returned by the following expression? (trick question)

(dotimes (i 5 i)
  (format t "~&I = ~S" i))

CL-USER> (dotimes (i 5 i)
  (format t "~&I = ~S" i))
I = 0
I = 1
I = 2
I = 3
I = 4
5

The return value is 5, the strings printed on each line
  are consequences of computing the return value of 5.



11.18 Rewrite the expression using DO instead.

(dotimes (i 5 i)
  (format t "~&I = ~S" i))

CL-USER> (do ((i 0 (+ i 1)))
             ((equal i 5) i)
           (format t "~%I = ~S i))
I = 0
I = 1
I = 2
I = 3
I = 4
5


We can see how the index variable I only computes to 4.

The DO goes through its body five times, with the index variable I equal to
  zero through four. The loop terminates once it reaches five.
    Since implementations automatically translate DOTIMES expressions
      into DO expressions such as this one.


11.19 Does switching the order of entries in the variable list
        of a DO expression make a difference?

CL-USER> (do-count-slices '(x x x x))

4
CL-USER> (do-switch-count-slices '(x x x x))
4
CL-USER> (do-count-slices nil)
0
CL-USER> (do-switch-count-slices nil)
0


As far as I can tell it does not seem to.

As suspected, I was correct, the entries in a DO's variable list
  may appear in any order.

The variables are completely independent due to the use of parallel assignment.


In a DO* form, variable order matters.

DO* uses sequential assignment, allows for the existence of variable dependencies.



11.20 If a loop uses only one index variable, can DO and DO* be used interchangeably?

Yes, DO and DO* are equivalent in this case.



11.21 One way to compute a Fib(5) is to start with Fib(0) and Fib(1),
        Which we already know to be one, and add them together to make Fib(2).
          Then we could add Fib(1) to Fib(2) to get a Fib(3),
            a Fib(2) + Fib(3) to get Fib(4), finally a Fib(3) + Fib(4) to get Fib(5).

        This is an iterative method involving no recursion; only the last two
          values of the Fib need to be stored to compute the next one.
            Write an iterative version of Fib using this technique.

(defun do*-fib (n)    ;DO* version.
  (do* ((cnt 0 (+ cnt 1))
        (i 1 j)
        (j 1 k)
        (k 2 (+ i j)))
       ((equal cnt n) i)))


(defun do-fib (n)
  (do ((cnt 0 (+ cnt 1))
       (i 1 j)
       (j 1 (+ i j)))
      ((equal cnt n) i)))



FUNCTIONS COVERED

Iteration macros: DOTIMES DOLIST DO DO*
Special functions: BLOCK RETURN-FROM
Ordinary function for exiting the block named NIL: RETURN



---
KEYBOARD EXERCISE

We will explore the properties of single and double-stranded DNA.

DNA and the related molecule RNA, make up the genetic material found in
  every type of cell within living things.

A strand of DNA is very much like a chain of cons cells;
  the elements of the chain are of four types, corresponding to the four bases,
    adenine, thymine, guanine, and cytosine.

We will represent a strand of DNA by a list of bases.

S> (list 'a 'g 'g 't 'c 'a 't 't 'g)

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->etc.
 |        |        |        |        |        |        |        |
 v        v        v        v        v        v        v        v
 A        G        G        T        C        A        T        T

Result:  (A G G T C A T T G)


This list corresponds to a strand that is nine bases long;
  the first base being adenine and the next two guanine.


Each of the four bases has a complement for which it can form a pair.

Adenine pairs with thymine, while guanine pairs with cytosine.

Two single strands of DNA can combine to form double-stranded DNA
  when each of their corresponding bases are complimentary.

---------------------------------------------
  !    !    !    !    !    !    !    !    !
  A    G    G    T    C    A    T    T    G
  .    .    .    .    .    .    .    .    .
  T    C    C    A    G    T    A    A    C
  !    !    !    !    !    !    !    !    !
---------------------------------------------


Double-stranded DNA resembles the above model.



EXERCISE

11.22 Write iterative solutions to all parts of this exercise that require repetition.

a. Write COMPLEMENT-BASE that takes a base as input and returns the matching complementary base.

(defun complement-base (base)
  (second (assoc base '((a t) (t a) (g c) (c g)))))


This function is a simple translator that uses a table of pairs,
  each pair housing the translatable base.

CL-USER> (complement-base 't)
A
CL-USER> (complement-base 'a)
T
CL-USER> (complement-base 'g)
C
CL-USER> (complement-base 'c)
G
CL-USER> (complement-base 'nil)
NIL


... and don't even fuck with this.



b. Write a function COMPLEMENT-STRAND that returns the complementary strand of a sequence
     of a single stranded DNA.

Since we are inputting a strand of DNA, we would have to repetitively check
  each input element for their complementary bases.

DO can be used effectively for this.

(defun complement-base (base)
  (second (assoc base '((a t) (t a) (g c) (c g)))))


COMPLEMENTARY-BASE will be called.

(defun complement-strand (strand)
  (do ((b strand (cdr b))
       (result nil
               (cons (complement-base (car b))
                     result)))
      ((null b) (reverse result))))


Var-1: b
Init-1: strand
Update-1: (cdr b)
Var-2: result
Init-2: nil
Update-2: (cons (complement-base (car b)) result)
Test: (null b)
Action: (reverse result)

The variable b stores our values for the input strand throughout the rest of the DO form.
  B initializes as the whole input strand.
    The variable-1 b is updated with the rest of its self with the update form,
      (CDR B).

Variable-2 is RESULT and it initializes at the empty list.
  It is updated by the form (cons (complement-base (car b)) result).

The test is (null b) so if b shows T for empty,
  the action taken is to reverse the result.

CL-USER> (do-complement-strand '(a g g t))
(T C C A)



c. Write MAKE-DOUBLE that takes a single strand of DNA as input and returns a
     double-stranded DNA by making a list of each base and its complement.

(defun do-make-double (strand)
  (do ((b strand (rest b))
       (result nil
               (cons (list (first b) (complement-base (first b)))
                     result)))
      ((null b) (reverse result))))

S> (do-make-double '(g g a c t))

[*|*]------------------>[*|*]------------------>[*|*]--->etc.
 |                       |                       |
 v                       v                       v
[*|*]--->[*|*]--->NIL   [*|*]--->[*|*]--->NIL   [*|*]--->[*|*]--->NIL
 |        |              |        |              |        |
 v        v              v        v              v        v
 G        C              G        C              A        T

Result:  ((G C) (G C) (A T) (C G) (T A))


Var-1: b
Init-1: strand
Update-1: (rest b)
Var-2: result
Init-2: nil
Update-2: (cons (list (first b) (complement-base (first b))) result)
Test: (null b)
Action: (reverse result)


This function essentially mirrors the COMPLEMENT-STRAND function,
  but adds the base translation as a pair to the input strand.

(defun do-complement-strand (strand)
  (do ((b strand (cdr b))
       (result nil
               (cons (complement-base (car b))
                     result)))
      ((null b) (reverse result))))


(first b) and (complement-base (first b)) are listed
  and then consed to each other as a pair.
    For example:
      (first b)  =>  G
      (complement-base (first b))  =>  C

        CL-USER> (list 'g 'c)
        (G C)


    This is consed to the result repetitively.

The test confirms if the list has run out and if it has
  the result is reversed.



d. Write COUNT-BASES that counts the number of bases of each type in a DNA strand,
     and returns the result as a table. The function should work for both single-
       and double-stranded DNA.
         What happens if we apply COUNT-BASES to the corresponding double-stranded sequence?

(defun count-bases (dna)
  (let ((acnt 0) (tcnt 0) (gcnt 0) (ccnt 0))
    (labels ((cond-count-one-base (base)
               (cond ((equal base 'a) (incf acnt))
                     ((equal base 't) (incf tcnt))
                     ((equal base 'g) (incf gcnt))
                     ((equal base 'c) (incf ccnt)))))
      (dolist (element dna)
        (cond ((atom element) (cond-count-one-base element))
              (t (cond-count-one-base (first element))
                 (cond-count-one-base (second element)))))
      (list (list 'a acnt)
             (list 't tcnt)
             (list 'g gcnt)
             (list 'c ccnt)))))

CL-USER> (count-bases '((g c) (a t) (t a) (t a) (c g)))
((A 3) (T 3) (G 2) (C 2))


The description of LABELS can be found on p282.

This problem can be solved in a tasteful fashion, without LABLES.
  It would be achieved by making COUNT-ONE-BASE a separate function
    and keeping the counts in global variables.

In this particular example LABELS is defining a local function COND-COUNT-ONE-BASE,
  a conditional function that acts as a counter, ticking each base as it is read.



e. Write a predicate PREFIXP that returns T if one strand of DNA is a prefix of another.
     To be a prefix, the elements of the first strand must exactly match the corresponding
       elements of the second, which may be longer.

(defun prefixp (strand1 strand2)
  (do ((s1 strand1 (rest s1))
       (s2 strand2 (rest s2)))
      ((null s1) t)
    (unless (equal (first s1) (first s2))
      (return nil))))

CL-USER> (prefixp '(g t c) '(g t c a t))

T
CL-USER> (prefixp '(g t c) '(a g g t c))
NIL
CL-USER> (prefixp '(g) '(g t a t))
T


Var-1: s1
Init-1: strand1
Update-1: (rest s1)
Var-2: s2
Init-2: strand 2
Update-2: (rest s2)
Test: (null s1)
Action: T
Body: (unless (equal (first s1) (first s2))
        (return nil))

PREFIXP only cares that one base match the first base of the other input.
  It will still return T for more matches in sequence but once a base doesn't match the other,
    the function will stop attempting to match bases between the two inputs.



f. Write predicate APPEARSP that returns T if one DNA strand appears anywhere in another.

(defun appearsp (strand-1 strand-2)
  (do ((s2 strand-2 (rest s2)))
      ((null s2) nil)
    (if (prefixp strand-1 s2)
        (return t))))

CL-USER> (appearsp '(c a t) '(t c a t g))
T
CL-USER> (appearsp '(c a t) '(t c c g t a))
NIL


Var-1: s2
Init-1: strand-2
Update-1: (rest s2)
Test: (null s2)
Action: nil
Body: (if (prefixp strand-1 s2)
          (return t))

If x appears in y, then x is either a prefix of y,
  or of (REST y), or of (REST (REST y)), etc.



g. Write predicate COVERP that returns T if its first input,
     repeated some number of times, matches its second input.

(defun coverp (strand-1 strand-2)
  (do* ((len1 (length strand-1))    ;DO* updates variables in order, sequentially.
        (s2 strand-2 (nthcdr len1 s2)))
       ((null s2) t)
    (unless (prefixp strand-1 s2)
      (return nil))))

CL-USER> (coverp '(a g c) '(a g c a g c a g c))

T
CL-USER> (coverp '(a g c) '(a b c t t g))
NIL


Var-1: len1
Init-1: (length strand-1)
Update-1:
Var-2: s2
Init-2: strand-2
Update-2: (nthcdr len1 s2)
Test: (null s2)
Action: T
Body: (unless (prefixp strand-1 s2)
        (return nil))

COVERP, the DO* form let's us know that these variables will be evaluated one
  after another, in a sequential way.
    It also notifies us that there may be a second index variable
      holding the successive elements of the list,
        while the first one holds the successive cdrs.

The successive cdrs are being processed by Update-2,(NTHCDR LEN1 S2)
  and the value is being held by S2.

*NOTE* the differences:

CL-USER> (setf *strand-1* '(a g c))
(A G C)
CL-USER> (setf *strand-2* '(a g c a g c a g c))
(A G C A G C A G C)
CL-USER> (setf *strand-3* '(a g c t c a g))
(A G C T C A G)
CL-USER> (length *strand-1*)
3
CL-USER> (nthcdr 3 *strand-2*)
(A G C A G C)
CL-USER> (nthcdr 3 *strand-3*)
(T C A G)
CL-USER> (setf *strand-4* '(a g a t c g t a))
(A G A T C G T A)
CL-USER> (setf *strand-5* '(t c g a t c a t))
(T C G A T C A T)
CL-USER> (nthcdr 3 *strand-4*)
(T C G T A)
CL-USER> (nthcdr 3 *strand-5*)
(A T C A T)


It stores the length of 3 in Var-1,LEN1.


The Var-2,S2 is cut to the length of the first input.
  In the examples above, the first input is three elements in length,
    therefore any strand that is the second input will be cut to the first three elements;
      this new value is stored as a three element list in S2.


Test,(NULL S2) and Action,T are there to loop iteration until S2 cannot satisfy
  the function parameters.


*NOTE* the initial value of Var-2,S2 is STRAND-2, the second input:

CL-USER> (prefixp *strand-1* *strand-2*)
T
CL-USER> (prefixp *strand-1* *strand-3*)
T
CL-USER> (prefixp *strand-1* *strand-4*)
NIL
CL-USER> (prefixp *strand-1* *strand-5*)
NIL

So *STRAND-4*,(A G A T C G T A) and *STRAND-5*,(T C G A T C A T) are out of the game;
  their first three list elements do not match the entirety of the first input.
    Reminder, the entirety of the first input is 3 length in this example.


*STRAND-2* and *STRAND-3* qualify for looping so we put the next three list elements
  of those lists through the DO* body, taking away the variable names it looks like:

CL-USER> (prefixp *strand-1* '(a g c a g c))    ;*STRAND-2* passes.
T
CL-USER> (prefixp *strand-1* '(t c a g))    ;*STRAND-3* doesn't pass.
NIL


So We know that *STRAND-2* will ride out the loop,
  *STRAND-3* can't satisfy the function body parameters
    returning a NIL value.

*STRAND-2* satisfies all the parameters:

CL-USER> (coverp *strand-1* *strand-2*)
T



h. Write function PREFIX that returns the leftmost N bases of a DNA strand.

(defun prefix (n strand)
  (do ((i 0 (+ i 1))
       (result nil (cons (nth i strand) result)))
      ((equal i n) (reverse result))))

CL-USER> *strand-5*

(T C G A T C A T)
CL-USER> (prefix 4 *strand-5*)
(T C G A)


Var-1: i
Init-1: 0
Update-1: (+ i 1)
Var-2: result
Init-2: nil
Update-2: (cons (nth i strand) result)
Test: (equal i n)
Action: (reverse result)
Body:


This is a DO form, our variables will be evaluated at once,

*NOTE* Check the indentation on your DO forms.


Var-1,i starts at Init-1,0;
  This variable is processed every loop by Update-1,(+ i 1).
    Stepping through our loop by an interval of one.

Var-2,RESULT; Init-2,NIL. We are building our result from NIL,
  this form will be updated through the expression Update-2 (CONS (NTH i STRAND) RESULT).

We do it with *STRAND-5* and see, let's manually step up our index to the first input:

CL-USER> (cons (nth 0 *strand-5*) nil)
(T)
CL-USER> (cons (nth 1 *strand-5*) '(t))
(C T)
CL-USER> (cons (nth 2 *strand-5*) '(c t))
(G C T)
CL-USER> (cons (nth 3 *strand-5*) '(g c t))
(A G C T)


The list is built up from NIL four elements in length.

CL-USER> (length '(a g c t))
4


Since we have reached four, looping will stop.
  We know this happens through the Test,(EQUAL i N).
    If the index is equal to the input, the Action-1,(REVERSE RESULT)
      is triggered and the result is reversed and evaluated as the return value.

CL-USER> (equal 4 4)
T
CL-USER> (reverse '(a g c t))
(T C G A)
CL-USER> (prefix 4 *strand-5*)
(T C G A)



i. Biologists have found that portions of some naturally occurring dna strands consist
     of many repetitions of a short kernel type sequence.
       Write function KERNEL, returning the shortest prefix of a DNA strand
         that can be repeated to cover the input strand.

Finding the kernel can be done by looking at prefixes of increasing length
  until one is found that can be repeated and cover the strand.
    Also note that if a strand is unique, the strand will be retuned in entirety.

(defun kernel (strand)
  (do ((i 1 (+ i 1)))
      ((coverp (prefix i strand) strand)
       (prefix i strand))))

CL-USER> *strand-2*
(A G C A G C A G C)
CL-USER> (kernel *strand-2*)
(A G C)

CL-USER> *strand-3*
(A A A A A)
CL-USER> (kernel *strand-3*)
(A)

CL-USER> *strand-4*
(A G A T C G T A)
CL-USER> (kernel *strand-4*)
(A G A T C G T A)


Var-1: i
Init-1: 1
Update-1: (+ i 1)
Test: (coverp (prefix i strand) strand)
Action: (prefix i strand)
Body:

The function body consists of a DO form of one variable line with
  test and action expressions.

Var-1,i starts at Init-1,1 and updates in increments of one, Update-1,(+ i 1).

The input strand and i are run through Test,(coverp (prefix i strand) strand):

CL-USER> *strand-2*
(A G C A G C A G C)
CL-USER> (prefix 1 *strand-2*)
(A)
CL-USER> (coverp '(a) *strand-2*)
NIL
CL-USER> (prefix 1 *strand-2*)
(A)
CL-USER> (prefix 2 *strand-2*)
(A G)
CL-USER> (coverp '(a g) *strand-2*)
NIL
CL-USER> (prefix 3 *strand-2*)
(A G C)
CL-USER> (coverp '(a g c) *strand-2*)
T


Stepping through the function manually until we hit a T that triggers
  Action,(PREFIX i STRAND).

There is no body so Action,(PREFIX i STRAND) is the return value.

CL-USER> (kernel *strand-2*)
(A G C)



j. Write function DRAW-DNA that takes a single-stranded dna sequence as input
     and draws it along with its complementary strand.

(defun draw-dna (strand)
  (let ((n (length strand)))
    (draw-string n "-----")
    (draw-string n "  !  ")
    (draw-bases strand)
    (draw-string n "  .  ")
    (draw-string n "  .  ")
    (draw-bases (complement-strand strand))
    (draw-string n "  !  ")
    (draw-string n "-----")))


(defun draw-string (cnt string)
  (format t "~&")
  (dotimes (i cnt)
    (format t "~A" string)))

Index-var: (i cnt)
List: (format t "~A" string)
Result-form: nil


(defun draw-bases (strand)
  (format t "~&")
  (dolist (base strand)
    (format t "  ~A  " base)))

Index-var: (base strand)
List: (format t "  ~A  " base)
Result-form: nil


CL-USER> (draw-dna *strand-4*)

----------------------------------------
  !    !    !    !    !    !    !    !  
  A    G    A    T    C    G    T    A  
  .    .    .    .    .    .    .    .  
  .    .    .    .    .    .    .    .  
  T    C    T    A    G    C    A    T  
  !    !    !    !    !    !    !    !  
----------------------------------------
NIL


Let's begin top-down with DRAW-DNA which is a LET form that builds
  the diagram around the input sequence and matching sequence.

LET forms resemble DO forms without but without the test:

(LET ((var-1 val-1)
      (var-2 val-2)
      ...
      (var-n val-n))
  body)

Two helper functions are used within the LET form DRAW-STRING and DRAW-BASES,
  these helper functions draw the symbols and bases on their respective lines up to N.

N is the length of the input strand:

CL-USER> (length *strand-4*)
8


DRAW-STRINGs first expression to be evaluated is (FORMAT T "~&"),
  this begins whatever is to be printed on a new line.

The second expression to be evaluated is a DOTIMES form.

(DOTIMES (index-var list [result-form])
  body)


The Index-var,(i CNT) counts up to the input count in the second input.

CL-USER> (length *strand-4*)
8
CL-USER> (draw-string 8 "-----")
----------------------------------------
NIL
CL-USER> (draw-string 8 "  !  ")
  !    !    !    !    !    !    !    !  
NIL


CNT equals the variable N in DRAW-DNA.


The second helper function DRAW-BASES draws the input strand on one line,
  then applies the COMPLEMENT-STRAND function to the input strand.

The function starts a new line and enters a DOLIST form.
  It indexes each base as a list element through the entire input strand,
    printing each base letter per loop.

CL-USER> (draw-bases *strand-4*)
  A    G    A    T    C    G    T    A  
NIL
CL-USER> (draw-bases (complement-strand *strand-4*))
  T    C    T    A    G    C    A    T  
NIL



---
Lisp Toolkit: TIME

The TIME macro function tells how long it took to evaluate the expression it wraps.

The output TIME prints is implementation dependant.

(defun addup (n)
  (do ((i 0 (+ i 1))
       (sum 0 (+ sum i)))
      ((> i n) sum)))


CL-USER> (time (addup 1000))

Evaluation took:
  0.000 seconds of real time
  0.000000 seconds of total run time (0.000000 user, 0.000000 system)
  100.00% CPU
  11,531 processor cycles
  0 bytes consed
  
500500

CL-USER> (time (addup 10000))
Evaluation took:
  0.000 seconds of real time
  0.000000 seconds of total run time (0.000000 user, 0.000000 system)
  100.00% CPU
  86,985 processor cycles
  0 bytes consed
  
50005000

LOL

I am not too sure this function is relevant as much as it used to be ..

Maybe for very large systems its useful.



***
11 Advanced Topics


---
11.12 PROG1, PROG2, AND PROGN

PROG1, PROG2, AND PROGN are three very simple functions.

They all take an arbitrary number of expressions as input and evaluate
  the expressions one at a time.


PROG1 returns the value of the first expression:

(prog1 (setf x 'foo) (setf x 'bar) (setf x 'baz)
       (format t "~&X is ~S" x))

CL-USER> (prog1 (setf x 'foo) (setf x 'bar) (setf x 'baz)
                (format t "~&X is ~S" x))


PROG2 returns the value of the second:

(prog2 (setf x 'foo) (setf x 'bar) (setf x 'baz)
       (format t  "~&X is ~S" x))

CL-USER> (prog2 (setf x 'foo) (setf x 'bar) (setf x 'baz)
                (format t "~&X is ~S" x))
X is BAZ
BAR


PROGN returns the value of the last expression:

CL-USER> (progn (setf x 'foo) (setf x 'bar) (setf x 'baz)
                (format t "~&X is ~S" x))
X is BAZ
NIL


These forms are used infrequently today,
  although important in earlier versions of Lisp.

In these earlier Lisp versions the body of a function could contain
  at most one expression and a COND clause could contain at most one consequent.


PROGN is still useful in the true-part and false-part of an IF form.

IF we want to evaluate several expressions in the true or false-part of an IF form,
  we must group them together using something like PROGN BLOCK or a LET form.


The effects of a PROG1 or PROG2 can easily be achieved with LET.

(POP X) is equivalent to:

(defun prog-pop (lst)
  (prog1 (first lst) (setf lst (rest lst))))


(defun let-pop (lst)
  (let ((was-on-top (first lst)))
    (setf lst (rest lst))
    was-on-top))


Today, LET forms are considered easier to comprehend.



---
11.13 OPTIONAL ARGUMENTS

Common Lisp functions can be written to accept optional arguments,
  keyword arguments, or any number of required arguments by putting
    special symbols called lambda-list keywords in the argument list.

Lambda-list keywords:
A special symbol such as &OPTIONAL or &REST that has a special meaning
  when it appears in the argument list of a function.

(defun optional-foo (x &optional y)
  (format t "~&X is ~S" x)
  (format t "~&Y is ~S" y)
  (list x y))

CL-USER> (optional-foo 2 5)

X is 2
Y is 5
(2 5)
CL-USER> (optional-foo 2)
X is 2
Y is NIL
(2 NIL)


We do not have to use NIL as the default value for unsupplied arguments.

It is possible to specify the default value by using (name default)
  instead of &OPTIONAL.

(defun divide-check (dividend &optional (divisor 2))    ;Default value - 2.
  (format t "~&~S ~A divide evenly by ~S"
          dividend
          (if (zerop (rem dividend divisor))
              "does"
              "does not")
          divisor))

; compiling (DEFUN DIVIDE-CHECK ...)
CL-USER> (divide-check 27 3)

27 does divide evenly by 3
NIL
CL-USER> (divide-check 27)
27 does not divide evenly by 2
NIL


(name default): (divisor 2)



---
11.14 REST ARGUMENTS

The variable following an &REST lambda-list keyword will be bound
  to a list of the remaining arguments to a function.

This allows the function to accept an unlimited number of arguments, as +
  and FORMAT do.

Here's a function that takes an unlimited number
  of arguments and returns their average,
    it includes division by 1.0 to ensure that the result is a floating point number:

(defun rest-args-avg (&rest args)
  (/ (reduce #'+ args)    ;Adds up all the args.
     (length args)    ;Length of the arg list.
     1.0))    ;Make sure the return value is a floating-point number.

CL-USER> (rest-args-avg 1 2 3 4 5)
3.0


&REST shall be used carefully when used with recursive function definitions:

(defun faulty-square-all (&rest nums)
  (if (null nums)
      nil
      (cons (* (first nums) (first nums))
            (faulty-square-all (rest nums)))))

CL-USER> (faulty-square-all '(1 2 3 4 5))
; Evaluation aborted on #<TYPE-ERROR expected-type: NUMBER datum: (1 2 3 4 5)>.


With the first call, the function's arguments are collected into a list.
  If the function then calls itself recursively on the cdr of that list,
    it will be processing a list of a list, rather than the original list.

To properly achieve a square-all function with rest args,
  we can use APPLY on the recursive call:

(defun square-the-rest (&rest args)
  (if (null args)
      nil
      (cons (* (first args) (first args))
            (apply #'square-the-rest (rest args)))))

CL-USER> (square-the-rest 1 2 3 4 5)

(1 4 9 16 25)


The PROG1 PROG2 and PROGN functions can be defined using the &REST
  lambda-list keyword as follows:

CL-USER> (defun my-prog1 (x &rest ignore) x)
MY-PROG1

CL-USER> (my-prog1 (setf x 'foo)
                   (setf x 'bar)
                   (setf x 'baz)
                   (format t "~&X is ~S" x))
X is BAZ
FOO


CL-USER> (defun my-prog2 (x y &rest ignore) y)
MY-PROG2

CL-USER> (my-prog2 (setf x 'foo)
                   (setf x 'bar)
                   (setf x 'baz)
                   (format t "~&X is ~S" x))
X is BAZ
BAR


CL-USER> (defun my-progn (&rest x)
           (car (last x)))
MY-PROGN

CL-USER> (my-progn (setf x 'foo)
                   (setf x 'bar)
                   (setf x 'baz)
                   (format t "~&X is ~S" x))
X is BAZ
NIL


The built-in versions of PROG1 PROG2 and PROGN don't create a list
  of their arguments because they are only required to return one value.



---
11.15 KEYWORD ARGUMENTS

In previous sections keyword arguments have been used in functions
  such as MEMBER and FIND-IF.

Implicitly calling a preferred equality test for MEMBER:

(member x y :test #'equal)


Keyword arguments are useful when a function accepts a large number
  of optional arguments.

By using keywords, we avoid having to memorize an order for these optional arguments,
  we just need to remember their names.

We can create our own functions that accept keyword arguments by using the
  &KEY lambda-list keyword.

As with &OPTIONAL, default values can be supplied if desired.

MAKE-SUNDAE accepts up to five keyword arguments:

(defun make-sundae (name &key (size 'regular) (ice-cream 'vanilla) (syrup 'hot-fudge)
                              nuts
                              cherries
                              whipped-cream)
  (list 'sundae
        (list 'for name)
        (list ice-cream 'with syrup 'syrup)
        (list 'toppings '=
              (remove nil
                      (list (and nuts 'nuts)
                            (and cherries 'cherries)
                            (and whipped-cream 'whipped-cream))))))

CL-USER> (make-sundae 'john)
(SUNDAE (FOR JOHN) (VANILLA WITH HOT-FUDGE SYRUP) (TOPPINGS = NIL))
CL-USER> (make-sundae 'cindy
                      :syrup 'strawberry
                      :nuts t
                      :cherries t)
(SUNDAE (FOR CINDY) (VANILLA WITH STRAWBERRY SYRUP)
 (TOPPINGS = (NUTS CHERRIES)))



---
11.16 AUXILIARY VARIABLES

The &AUX lambda-list keyword is used to define auxiliary local variables.

We can specify jsut the variable name, in which case the variable is created
  with the initial value NIL, or we can use a list of form (var expression).

In the latter case EXPRESSION is evaluated, and the result
  serves as the initial value for the variable.

Using the auxiliary variable LEN to hold the length of the list:

(defun average (&rest args &aux (len (length args)))
  (/ (reduce #'+ args) len 1.0))

CL-USER> (average 1 2 3 4 5)
3.0


The &AUX keyword accomplishes the same thing as the LET* special function;
  both create new local variables using sequential binding.

The choice whether to use a LET* form in the function definition body
  or an &AUX keyword in the function definition variable list is a matter of style.



FUNCTIONS COVERED

PROG1 PROG2 PROGN

Lambda-list keywords: &OPTIONAL &REST &KEY &AUX



***
12
Structures and The Type System


---
12.1 INTRODUCTION

Common Lisp includes many built-in datatypes which come together
  to form a type system.

The types covered so far are:
  numbers (of several varieties), symbols, conses, strings,
    function objects, and stream objects.

These are the basic datatypes, but there are a few more.


The Common Lisp type system has two important properties.

First, types are visible:
  they are described by Lisp data structures (symbols or lists).
    There are built-in functions that test for the type an object is,
      and ones that return type descriptions of input objects.

Second, the type system is extensible:
  Lisp programmers can create new types anytime.

Structures are an example of a programmer-defined datatype.

The Common Lisp Object System provides an advanced programmer-defined datatype
  facility that supports the "object-oriented programming" style.
    CLOS is not covered in this book.


---
12.2 TYPEP AND TYPE-OF

The TYPEP predicate returns true if an object is of the specified type.

Type specifiers may be complex expressions,
  simple cases will be exhibited here:

CL-USER> (typep 3 'number)
T
CL-USER> (typep 3 'integer)
T
CL-USER> (typep 3 'float)
NIL
CL-USER> (typep 'foo 'symbol)
T


In the book figure 12.1 shows a portion of the Common Lisp type hierarchy.

Observe the many interesting features of the diagram:

T appears at the top of the hierarchy,
  all objects are instances and subtypes of T.

Type COMMON includes all the types that are built in to Common Lisp.

Type NULL includes only the symbol NIL.

Type LIST subsumes the types CONS and NULL.

NULL is therefore a subtype of both SYMBOL and LIST.

STRING is a subtype of VECTOR, which is a subtype of ARRAY.


The TYPE-OF function returns a type specifier for an object.

Since objects can be of more than one type,
  the exact result returned by TYPE-OF is implementation dependent.

CL-USER> (typep 3 'number)
T
CL-USER> (typep 3 'integer)
T
CL-USER> (typep 3 'float)
NIL
CL-USER> (typep 'foo 'symbol)
T
CL-USER> (type-of 'bung)
SYMBOL
CL-USER> (type-of 3.5)
SINGLE-FLOAT
CL-USER> (type-of '(bat breath))
CONS
CL-USER> (type-of "bunghole")
(SIMPLE-ARRAY CHARACTER (8))


The type specifier (SIMPLE-ARRAY CHARACTER (8)) describes a fixed-length
  character string with eight elements.



---
12.3 DEFINING STRUCTURES

Structures are programmer defined Lisp objects with an
  arbitrary number of named components.

Newly defined structure types automatically
  become a part of the Lisp type hierarchy.

The DEFSTRUCT macro defines new structures and specifies the
  names and default values of their components:

CL-USER> (defstruct starship
           (name nil)
           (speed 0)
           (condition 'green)
           (shields 'down))
STARSHIP


This DEFSTRUCT form defines a new type of object called a STARSHIP
  whose components are called NAME, SPEED, CONDITION, and SHIELDS.

STARSHIP becomes part of the system type hierarchy and can be
  referenced by TYPEP and TYPE-OF.


The DEFSTRUCT macro function also does several other things.

It defines a constructor function MAKE-STARSHIP for
  creating new structures of this type.

When a new starship is created, the name component will default to NIL,
  the speed to zero, the condition to GREEN, and the shields to DOWN.

CL-USER> (setf s1 (make-starship))
#S(STARSHIP :NAME NIL :SPEED 0 :CONDITION GREEN :SHIELDS DOWN)


The #S notation is the standard way to display structures in Common Lisp.

The list following the #S contains the type of the structure followed
  by an alternating sequence of component names and values.

CL-USER> s1
#S(STARSHIP :NAME NIL :SPEED 0 :CONDITION GREEN :SHIELDS DOWN)


Do not be misled by the use of parenthesis in #S notation.

Structures are not lists.

CL-USER> (car s1)
; Evaluation aborted on #<TYPE-ERROR expected-type: LIST
             datum:
             #S(STARSHIP :NAME NIL :SPEED 0 :CONDITION GREEN :SHIELDS DOWN)>.


Ordinary list operations like CAR and CDR will not work on structures.


CL-USER> (setf s2 '#s(starship speed (warp 3)
                               condition rede
                               shields up))
#S(STARSHIP :NAME NIL :SPEED (WARP 3) :CONDITION REDE :SHIELDS UP)


Although new instances of this datatype are usually created by calling
  the constructor function MAKE-STARSHIP, it is also possible to type in the
    STARSHIP objects directly to the read-eval-print loop using #S notation.

*NOTE* The structure must be quoted to prevent evaluation.



---
12.4 TYPE PREDICATES FOR STRUCTURES

Another side effect of DEFSTRUCT is that it creates a type predicate
  for the structure based on the structure name.

STARSHIP-P in our case:

CL-USER> (starship-p s2)
T
CL-USER> (starship-p 'foo)
NIL


Since the type name STARSHIP is fully integrated into the type system,
  it can be used with TYPEP and will be returned by TYPE-OF.

CL-USER> (typep s2 'starship)
T
CL-USER> (type-of s2)
STARSHIP



---
12.5 ACCESSING AND MODIFYING STRUCTURES

When a new structure is defined, DEFSTRUCT creates accessor functions
  for each of the structure components.

For STARSHIP, a STARSHIP-SPEED accessor function for retrieving
  the SPEED component of a starship was created:

CL-USER> (starship-speed s1)
0
CL-USER> (starship-speed s2)
(WARP 3)

CL-USER> (starship-shields s2)
UP
CL-USER> (starship-shields s1)
DOWN


The accessor functions can also serve as place descriptions to SETF
  and other generalized assignment operators.

CL-USER> s1
#S(STARSHIP :NAME NIL :SPEED 0 :CONDITION GREEN :SHIELDS DOWN)
CL-USER> s2
#S(STARSHIP :NAME NIL :SPEED (WARP 3) :CONDITION REDE :SHIELDS UP)


Using these accessor functions, we can easily write our own functions
  to manipulate structures in interesting ways.

We can write a function ALERT that causes the starship to raise its shields,
  while additionally raising the condition level to be at least YELLOW.

(defun alert (ship-name)
  (setf (starship-shields ship-name) 'up)
  (if (equal (starship-condition ship-name) 'green)
      (setf (starship-condition ship-name) 'yellow))
  'shields-raised)

CL-USER> (alert s1)
SHIELDS-RAISED
CL-USER> s1
#S(STARSHIP :NAME NIL :SPEED 0 :CONDITION YELLOW :SHIELDS UP)


An experienced Lisp programmer would prefer to use a more
  descriptive name than X for the argument to ALERT.

I chose SHIP-NAME.

Alert expects its argument to be a starship, why not use that name in the arg list?

Because that mixes in similarly named variables and structures causing confusion.
  If STARSHIP were used in the argument list, it could get confused with our newly
    defined structure STARSHIP.

To avoid confusion, we can use shorthand variable names like STRSHIP,
  but the one we came up with was on the right track.



---
12.6 KEYWORD ARGUMENTS TO CONSTRUCTOR FUNCTIONS

;;The new new.

CL-USER> (setf s3 (make-starship :name "Bung-Traveler"
                        :shields 'damaged))
#S(STARSHIP :NAME "Bung-Traveler" :SPEED 0 :CONDITION GREEN :SHIELDS DAMAGED)


We aren't restricted by set-defaults for our structural components.

We can specify them as different values by supplying them as keyword
  arguments in the call to the constructor.



---
12.7 CHANGING STRUCTURE DEFINITIONS

If you redefine a structure type using DEFSTRUCT to change the names
  or orderings of components, you should throw away all of the old structures
    of that type.

The accessor functions may no longer work properly on them,
  and their may be other problems as well.

(defstruct starship
  (captain nil)
  (name nil)
  (shields 'down)
  (condition 'green)
  (speed o))

CL-USER> s3
; Evaluation aborted on #<SB-PCL::OBSOLETE-STRUCTURE {10064240A3}>.


S3 and the others need to be rebuilt:

CL-USER> (setf s1 (make-starship))
#S(STARSHIP :CAPTAIN NIL :NAME NIL :SHIELDS DOWN :CONDITION GREEN :SPEED 0)
CL-USER> (raise-alert s1)
SHIELDS-RAISED
CL-USER> s1
#S(STARSHIP :CAPTAIN NIL :NAME NIL :SHIELDS UP :CONDITION YELLOW :SPEED 0)


CL-USER> (setf s2 (make-starship :speed '(warp 3)
                                 :condition 'red
                                 :shields 'up))
#S(STARSHIP :CAPTAIN NIL :NAME NIL :SHIELDS UP :CONDITION RED :SPEED (WARP 3))


CL-USER> (setf s3 (make-starship :captain "Benson"
                                 :name "Reliant"
                                 :shields 'damaged))
#S(STARSHIP
   :CAPTAIN "Benson"
   :NAME "Reliant"
   :SHIELDS DAMAGED
   :CONDITION GREEN
   :SPEED 0)


We have fixed our three SPACESHIP structures.

CL-USER> (starship-speed s2)
(WARP 3)
CL-USER> (starship-speed s1)
0
CL-USER> (starship-captain s3)
"Benson"



SUMMARY

Common Lisp contains many built-in datatypes;
  the basic ones are covered here.

The Common Lisp type system is both visible and extensible.
  Lisp programmers can extend the type system by defining new structure types.


DEFSTRUCT defines new structure types.

The structure definition includes the names of all the components,
  and optionally specifies default values for them.

If no default value is given for a component NIL is used.

DEFSTRUCT also automatically defines a constructor function for the type,
  such as the MAKE-STARSHIP constructor function;
   as well as defining a type predicate,
     the STARSHIP-P predicate.



REVIEW EXERCISES

12.1 Describe the roles of the symbols CAPTAIN :CAPTAIN and STARSHIP-CAPTAIN.

CAPTAIN
The symbol naming a component of the STARSHIP structure.

:CAPTAIN
The symbol representing the keyword when specifying the CAPTAIN
  component of the STARSHIP structure.

STARSHIP-CAPTAIN
this is the accessor function used to access the CAPTAIN component
  of the STARSHIP data structure.



12.2 Evaluate.

CL-USER> (starship-p 'starship)
NIL



12.3 What are the values?

CL-USER> (type-of 'make-starship)
SYMBOL
CL-USER> (type-of #'make-starship)
FUNCTION
CL-USER> (type-of (make-starship))
STARSHIP



FUNCTIONS COVERED

Structure-defining macro: DEFSTRUCT
Type system functions: TYPEP TYPE-OF



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Lisp Toolkit: DESCRIBE and INSPECT
;;
;;


DESCRIBE is a function that takes any kind of Lisp object as input
  and prints an informative description of it.

CL-USER> (describe 7)
7
  [fixnum]
; No value
CL-USER> (describe 'fred)
COMMON-LISP-USER::FRED
  [symbol]
; No value
CL-USER> (describe t)
COMMON-LISP:T
  [symbol]

T names a constant variable:
  Value: T

T names the system-class #<SB-PCL:SYSTEM-CLASS COMMON-LISP:T>:
  Class precedence-list: T
  Direct subclasses: ARRAY, SIMD-PACK-256, SIMD-PACK, NUMBER,
                     SB-KERNEL::RANDOM-CLASS, SB-KERNEL:FDEFN,
                     SB-KERNEL:CODE-COMPONENT, WEAK-POINTER,
                     SYSTEM-AREA-POINTER, SYMBOL, CHARACTER,
                     SB-PCL::SLOT-OBJECT, SEQUENCE, STREAM, FUNCTION
  No direct slots.
; No value
CL-USER> (describe 'cons)
COMMON-LISP:CONS
  [symbol]

CONS names a compiled function:
  Lambda-list: (SB-IMPL::SE1 SB-IMPL::SE2)
  Declared type: (FUNCTION (T T) (VALUES CONS &OPTIONAL))
  Documentation:
    Return a list with SE1 as the CAR and SE2 as the CDR.
  Known attributes: flushable, unsafely-flushable, movable
  Source file: SYS:SRC;CODE;LIST.LISP

CONS names the built-in-class #<BUILT-IN-CLASS COMMON-LISP:CONS>:
  Class precedence-list: CONS, LIST, SEQUENCE, T
  Direct superclasses: LIST
  No subclasses.
  Sealed.
  No direct slots.

CONS names a primitive type-specifier:
  Lambda-list: (&OPTIONAL (SB-KERNEL::CAR-TYPE-SPEC '*)
                (SB-KERNEL::CDR-TYPE-SPEC '*))
; No value


DESCRIBE is great for displaying structures:

CL-USER> (describe s3)
#S(STARSHIP..
  [structure-object]

Slots with :INSTANCE allocation:
  CAPTAIN                        = "Benson"
  NAME                           = "Reliant"
  SHIELDS                        = DAMAGED
  CONDITION                      = GREEN
  SPEED                          = 0
; No value


INSPECT is apparently cool as well.

CL-USER> (inspect s3)

The object is a STRUCTURE-OBJECT of type STARSHIP.
0. CAPTAIN: "Benson"
1. NAME: "Reliant"
2. SHIELDS: DAMAGED
3. CONDITION: GREEN
4. SPEED: 0



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;    Keyboard Exercise
;;
;;


This keyboard exercise implements a discrimination net.

Discrimination nets are networks of yes and no questions used for
  problem-solving tasks, such as diagnosing automotive trouble or maybe
    diagnosing some minor injury or illness.


These discrimination nets consist of a series of nodes.

Each node having a name (a symbol), an associated question (a string),
  a yes action, and a no action.

The yes and no actions may either be the names of other nodes to go to,
  or the may be strings giving the program's diagnosis.

If their is no new node, the program stops after printing the string.


EXERCISE

12.4 In this exercise we create a discrimination net for automotive diagnosis.

a. Write a DEFSTRUCT for a structure called NODE with four components,
     NAME QUESTION YES-CASE NO-CASE.

CL-USER> (defstruct node
           name
           question
           yes-case
           no-case)
NODE



b. Define a global variable *NODE-LIST* that will hold all the nodes in the
     discrimination net. Write a function INIT that initializes the network by
       setting *NODE-LIST* to NIL.

CL-USER> (setf *node-list* nil)
NIL

CL-USER> (defun network-initialization ()
           (setf *node-list* nil)
           'initialized)
NETWORK-INITIALIZATION
CL-USER> (network-initialization)
INITIALIZED



c. Write ADD-NODE. It should return the name of the node it added.

(defun add-node (name question
                 yes-case no-case)
  (push (make-node :name name
                   :question question
                   :yes-case yes-case
                   :no-case no-case)
        *node-list*)
  name)


*NOTE* The MAKE-NODE function was created in the DEFSTRUCT.

This function makes a node. It takes keyword arguments in the input
  so that we may specify some component.

Following the nodes creation, it is pushed to the global variable
  *NODE-LIST* which is storing all of our node structures.

NAME is returned.



d. Write FIND-NODE, returning the node if it is found in *NODE-LIST*.

(defun find-node (input)
  (find-if #'(lambda (node)
               (equal (node-name node) input))
           *node-list*))


This function takes a NODE-NAME as input.

It analyzes the list taking each element and applying an
  equality test looking for the NAME component of the NODE structure.

The find-if function will return the node if it is found in *NODE-LIST*.



e. Write PROCESS-NODE. Taking a node name as input. If it can't find the
     node, it prints a message that the node hasn't been defined yet, and returns NIL.
       Otherwise it asks the user the question associated with that node,
         and then returns the node's yes-action or no-action respectively.

(defun process-node (name)
  (let ((nd (find-node name)))
    (if nd
        (if y-or-n-p "~&~A "
            (node-question nd))
        (node-yes-case nd)
        (node-no-case nd))
    (format t "~&Node ~S not yet defined." name)))



f. Write RUN. This function maintains a local variable named CURRENT-NODE,
     whose initial value is START. It loops, calling PROCESS-NODE to process
       the current-node, and storing the value returned by process node back into
         CURRENT-NODE. If the value returned is a string, the function prints the
           string and stops. If NIL is the returned value it stops.

(defun run ()
  (do ((current-node 'start (process-node current-node)))
      ((null current-node) nil)
    (cond ((stringp current-node)
           (format t "~&~A" current-node)
           (return nil)))))



g. Write an interactive function to add a new node. It should prompt the user for
     the node name, the question, and the yes and no actions. Remember that the
       question must be a string enclosed in double quotes. The function should also
         add the new node to the net.

(defun interactive-add ()
  (let* ((name (prompt-for "Node name? "))
         (question (prompt-for "Question? "))
         (yes-action (prompt-for "If yes? "))
         (no-action (prompt-for "If no? ")))
    (add-node name question yes-action no-action)))



h. If the engine runs for a brief period, but then stalls once it gets cold,
     it is possible that the idle rpm is set too low. Write a new node called
       ENGINE-WILL-RUN-BRIEFLY to inquire whether the engine stalls when cold but
         not when warm. if so, have the net go to another node where the user is asked
           whether the cold idle speed is at least 700 rpm. If it is not, advise the
             user to adjust the idle speed.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  12 Advanced Topics
;;
;;


---
12.8 PRINT FUNCTIONS FOR STRUCTURES

It is often convenient to invent specialized notations for printing structures.

We may not want to see all the fields of a starship object whenever it is printed;
  it may be satisfactory to just view the name.

The convention for printing abbreviated structure descriptions in Common Lisp
  is to make up a notation beginning with "#<" and ending with ">";
    which should contain the type of structure and components to be printed.

(defun print-starship (x stream depth)
  (format stream "#<STARSHIP ~A>"
          (starship-name x)))

CL-USER> (print-starship s3 t 0)
#<STARSHIP Reliant>


The first step in customizing the way starship objects print
  is to write our own print function.

It must take three inputs: the target object, the stream to print it on,
  and a number called depth.

Common Lisp uses the DEPTH variable to limit the depth of nesting
  when printing complex structures.

We can ignore the depth argument in this book, but in order for our custom
  structure printer function to work, we need three input variables in the variable
    list of the function definition.

We can test this function by calling it with a starship, T for the output stream,
  and a 0 depth.

CL-USER> (print-starship s3 t 0)
#<STARSHIP Reliant>


Now to make Lisp call this function whenever it tries to print a starship,
  we must include the print function as an option to the DEFSTRUCT:

CL-USER> (setf s4 (make-starship :name "Reliant"))
#<STARSHIP Reliant>
CL-USER> (starship-shields s4)
DOWN
CL-USER> (starship-condition s4)
GREEN

CL-USER> (format t "This is ~S leaving orbit." s4)
This is #<STARSHIP Reliant> leaving orbit.
NIL


Print functions are especially useful when a structure contains other structures
  as components and we want to suppress the verbosity.

They are almost essential when there are circular pointers between structures.

For instance, every captain has a ship and every ship has a captain.

If the structures for Kirk and the Enterprise point to each other,
  then when either one is printed, Lisp could enter an infinite loop,
    or be forced to use #1# notation to express circularity.

If the print functions for the STARSHIP and CAPTAIN structures display
  only the name fields, we will have a concise notation for these objects in
    which the circularities are not evident.



EXERCISE

12.5 Create a defstruct for CAPTAIN with fields NAME AGE SHIP.
       Make a structure describing James T. Kirk, captain of the Enterprise, age 35.
         Make the Enterprise point back to Kirk through its CAPTAIN component.

       Now define a print function for CAPTAIN that displays only the name.

(setf s1 (make-starship :name "Enterprise"))

(defstruct (captain
            (:print-function print-captain))
  (name nil)
  (age nil)
  (ship nil))

(defun print-captain (x stream depth)
  (format stream "#<CAPTAIN ~S>"
          (captain-name x)))

(setf jim (make-captain
           :name "James T. Kirk"
           :age 35
           :ship s1))

(setf (starship-captain s1) jim)



---
12.9 EQUALITY OF STRUCTURES

The EQUAL function does not treat two distinct structures as equal
  even if they have the same components:

CL-USER> (setf s5 (make-starship))
#<STARSHIP NIL>
CL-USER> (setf s6 (make-starship))
#<STARSHIP NIL>
CL-USER> (equal s5 s6)
NIL
CL-USER> (equal s6 s6)
T


However, the EQUALP function will treat two structures as equal
  if they are of the same type and all of their components are equal.

CL-USER> (equalp s5 s6)
T
CL-USER> (equalp s5 '#s(starship name nil
                                 speed 0
                                 condition green
                                 shields down))


EQUALP also differs from EQUAL in ignoring case
  distinctions when comparing characters.

CL-USER> (equal "enterprise" "Enterprise")
NIL
CL-USER> (equalp "enterprise" "Enterprise")
T



---
12.10 INHERITANCE FROM OTHER STRUCTURES

Structure types can be organized into a hierarchy using the :INCLUDE option
  to DEFSTRUCT.

We could define a new structure type SHIP whose components are
  NAME CAPTAIN CREW-SIZE.

Then we could define STARSHIP as a type of SHIP with additional components
  WEAPONS and SHIELDS, and SUPPLY-SHIP as a type of SHIP with an additional
    component called CARGO.

CL-USER> (defstruct ship
           (name nil)
           (captain nil)
           (crew-size nil))
SHIP
CL-USER> (defstruct (starship (:include ship))
           (weapons nil)
           (shields nil))
STARSHIP
CL-USER> (defstruct (supply-ship (:include ship))
           (cargo nil))
SUPPLY-SHIP


The fields of a STARSHIP structure include all the components of SHIP.

When we make a starship, its first three components will be NAME
  CAPTAIN and CREW-SIZE.

The same holds for supply ships.


~~~~    BREAK    ~~~~

We lost are Lisp here ladies and gentlemen,
  we are going to rebuild our starship structure back to 12.10 hasty.

~~~~    BREAK    ~~~~


Dude we lost so many Lisps redefining structures.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;    13 Arrays, Hash Tables, And Property Lists
;;
;;


---
13.1 INTRODUCTION

This chapter covers three distinct datatypes: arrays hash-tables and property-lists.

Arrays are used frequently in other programming languages, but not so much in Lisp.

This is because Lisp has more datatypes to choose from.

Property lists are old news and have been largely replaced by hash tables,
  but we still must understand them.



---
13.2 CREATING AN ARRAY

An array is a contiguous block of storage whose elements are named by numeric subscripts.

Arrays can be multi-dimensional, but this book only covers one dimensional arrays.


One dimensional arrays are called vectors.

The components of a vector of length n are numbered zero through n-1.

(setf my-vec '#(tuning violin 440 a))

CL-USER> my-vec

#(TUNING VIOLIN 440 A)


Do not let the #() notation fool you into thinking that arrays are lists.

Lists are a chain of cons cells.

Arrays are not lists, arrays are contiguous blocks of storage.


So since arrays are not cons cells, basic list operations like CAR and CDR
  are not going to work.

________________________________________
|    |        |          |       |     |
|HDR | TUNING |  VIOLIN  |  440  |  A  |
|    |        |          |       |     |
|____|________|__________|_______|_____|
         |          |        |      |
         |          |        |      |
         |          |        |      |
         >TUNING    >VIOLIN  >440   >A


The HDR portion of the array is called an array header.

It contains useful information about the array, such as its length and number of dimensions,
  which Lisp uses whenever you access the array's elements.


Because storage in arrays is contiguous, we can access each element of an
  array as fast as any other element.

With lists, we have to follow a chain of pointers to get from one cons cell to the next,
  so depending on the length of the list, it can take much longer to access the last element.


Efficient access is the prime advantage arrays have over lists.
  An array uses half as much memory as a list of equal length.


Lists have many advantages over arrays.

Lists of arbitrary length can be built-up element by element either recursively or iteratively.
  It is not as easy to grow an array one element at a time.

Lists can also share structure in ways that are impossible for arrays



---
13.3 PRINTING ARRAYS

To be able to see the elements of an array, we must set the global variable *PRINT-ARRAY* to T.

This assures that vectors will be printed in the same #(ting1 ting2..) notation
  we have been using this entire time to type in.

If *PRINT-ARRAY* is set to NIL, vectors and arrays will print in a more concise implementation-
  dependent form using #<> notation, in which their individual elements are suppressed.

CL-USER> (setf *print-array* nil)
NIL
CL-USER> my-vec
#<(SIMPLE-VECTOR 4) {100575F84F}>
CL-USER> (setf *print-array* t)
T
CL-USER> my-vec
#(TUNING VIOLIN 440 A)
CL-USER>



---
13.4 ACCESSING AND MODIFYING ARRAY ELEMENTS

The vector we stored in MY-VEC has four elements, numbered zero, one, two, and three.
  The AREF function is used to access the elements of an array by number,
    just as NTH is used to access the elements of this list.

CL-USER> (setf *print-array* nil)
NIL
CL-USER> my-vec
#<(SIMPLE-VECTOR 4) {100575F84F}>
CL-USER> my-vec
#(TUNING VIOLIN 440 A)
CL-USER> (aref my-vec 1)
VIOLIN
CL-USER> (aref my-vec 3)
A

We can use this alternative printing method for our systems arrays to refer
  to the number of elements within our vector.


AREF is also understood as a place name for SETF;
  this is how one stores new values in an array.

Let's make some fresh arrays:

CL-USER> (setf a '#(nil nil nil nil nil))
#(NIL NIL NIL NIL NIL)
CL-USER> (setf (aref a 0) 'foo)
FOO
CL-USER> (setf (aref a 1) 37)
37
CL-USER> (setf (aref a 2) 'bar)
BAR
CL-USER> a
#(FOO 37 BAR NIL NIL)
CL-USER> (aref a 2)
BAR
CL-USER> (setf (aref a 4) 'baz)n
BAZ
CL-USER> (setf (aref a 3) 00)
0
CL-USER> a
#(FOO 37 BAR 0 BAZ)


Many functions we originally learned to use on lists are actually
  designed for working on sequences.

Sequences include both lists and vectors.

Some examples of sequence functions are LENGTH REVERSE and FIND-IF.

CL-USER> a
#(FOO 37 BAR 0 BAZ)
CL-USER> (length a)
5
CL-USER> (reverse a)
#(BAZ 0 BAR 37 FOO)
CL-USER> (find-if #'numberp a)
37
CL-USER> (find-if #'numberp (reverse a))
0


But hold your britches son, some functions only do work on lists.

Aside from the obvious CAR and CDR, there are MEMBER and the other set of functions,
  plus SUBST and SUBLIS, and destructive functions such as NCONC.

Destructive sequence functions like NREVERSE work on either lists or vectors.
  As the definition implies, NREVERSE works on sequences

CL-USER> (describe 'nreverse)
COMMON-LISP:NREVERSE
  [symbol]

NREVERSE names a compiled function:
  Lambda-list: (SEQUENCE)
  Declared type: (FUNCTION (SEQUENCE) (VALUES SEQUENCE &OPTIONAL))
  Derived type: (FUNCTION (T) (VALUES SEQUENCE &OPTIONAL))
  Documentation:
    Return a sequence of the same elements in reverse order; the argument
       is destroyed.
  Known attributes: important-result
  Source file: SYS:SRC;CODE;SEQ.LISP
; No value



---
13.5 CREATING ARRAYS WITH MAKE-ARRAY

The Lisp function MAKE-ARRAY creates and returns a new array.
  The length of the array is specified by the first argument.
    The initial contents of the array are undefined.

Some Common Lisp implementations initialize array elements to zero, others use NIL.

To be safe, we should not rely on array elements having any particular initial
  value unless we have specified one explicitly.


MAKE-ARRAY accepts several keyword arguments.

The :INITIAL-ELEMENT keyword specifies one initial value to use
  for all the elements of the array.

CL-USER> (make-array 5 :initial-element '(1))
#((1) (1) (1) (1) (1))


The INITIAL-CONTENTS keyword specifies a list of values for initializing
  the respective elements of an array.

The list must be exactly as long as the array.

CL-USER> (make-array 5 :initial-contents '(a e i o u))
#(A E I O U)


If we don't use one of these keywords when calling MAKE-ARRAY
  the initial contents of the array will be unpredictable.



---
13.6 STRINGS AS VECTORS

Strings are actually a special type of vector.

LENGTH REVERSE and AREF can be used on them.
  These functions work on vectors,
    so if a string is a special type of vector,
      then we can use them on strings.

We need to keep in mind that vectors are indexed starting from 0.
  Vectors are not indexed beginning at 1.

CL-USER> (length "bunghole")
8
CL-USER> (reverse "bunghole")
"elohgnub"
CL-USER> (aref "bunghole" 5)
#\o


The elements of a string are called character objects.
  #\o denotes the character object known as lowercase o.

Characters are yet another datatype distinct from symbols and numbers.

Character objects do not need to be quoted because they evaluate
  to themselves just as numbers do.

CL-USER> (type-of #\m)
STANDARD-CHAR
CL-USER> #\m
#\m


Since SETF has a handle on AREF as a place name,
  we may destructively modify strings with SETF.

We must only store character objects in the string,
  although an error will result.

CL-USER> (setf pet "Bunghole")
; in: SETF PET
;     (SETF PET "Bunghole")
; ==>
;   (SETQ PET "Bunghole")
; 
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::PET
; 
; compilation unit finished
;   Undefined variable:
;     PET
;   caught 1 WARNING condition
"Bunghole"
CL-USER> pet
"Bunghole"
CL-USER> (setf (aref pet 3) #\s)
; in: SETF (AREF PET 3)
;     (LET* ((#:PET586 PET) (#:NEW1 #\s))
;       (FUNCALL #'(SETF AREF) #:NEW1 #:PET586 3))
; 
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::PET
; 
; compilation unit finished
;   Undefined variable:
;     PET
;   caught 1 WARNING condition
#\s
CL-USER> pet
"Bunshole"


We can change our bungholes to the more family friendly bunshole in such a way.



---
13.7 HASH TABLES

A hash table offers essentially the same functionality as an association list.

A key is supplied, which may be any sort of object,
  Lisp then gives back the item associated with that key.

The advantage of hash tables is that they are implemented using special hashing
  algorithms that allow Lisp to look things up much faster than it can look them
    up in an association list.

Hashing is fast in part because hash tables are implemented using
  vectors and not cons cell chains.


Association lists still have advantages over hash tables.

They are easier to create and manipulate because they are ordinary list structures.

Hash tables are implementation-dependent representations that are not directly
  visible to the user.

If simplicity is the goal, use an association list.

If we are targeting system efficiency, we should use a hash table.


Hash tables cannot be typed into the keyboard like vectors can.
  They can only be created by the MAKE-HASH-TABLE function.

In the default kind of hash table, EQL is used to compare keys of items that are stored.

It is also possible to create hash tables that use EQ or EQUAL.

Hash table objects are printed in an implementation-dependent manner
   that usually does not show us the elements.

(setf hhh (make-hash-table))
;;#<HASH-TABLE :TEST EQL :COUNT 0 {1005089A33}>

(type-of hhh)
;;HASH-TABLE


The GETHASH function looks up the key in a hash table.

The key can be any sort of object. GETHASH is understood as a place
  specification by SETF, so it can be also used to store into the hash table.

CL-USER> (setf (gethash 'john hhh)
      '(attorney (16 maple drive)))
(ATTORNEY (16 MAPLE DRIVE))
CL-USER> (setf (gethash 'mary hhh)
      '(physician (23 cedar court)))
(PHYSICIAN (23 CEDAR COURT))
CL-USER> (gethash 'john hhh)
(ATTORNEY (16 MAPLE DRIVE))
T
CL-USER> (gethash 'bill hhh)    ;Two return values.
NIL
NIL
CL-USER> hhh
#<HASH-TABLE :TEST EQL :COUNT 2 {1005089A33}>


Notice when we index for BILL in hash table HHH
  that we get two return values instead of one.

The first return value is the item associated with the key,
  or NIL if the key was not found in the hash table.

The second value is T if it was found in the hash table,
  or NIL if it was not found.

The reason for the second value is to distinguish a key that appears
  in the table with an associated item of NIL from a key that does not appear at all.

We can safely ignore the second return value;
  multiple return values are not made of use in this book.


DESCRIBE can tell us useful things about a hash table
  such as the number of buckets it has.

A bucket is a group of entries in a hash table.

The more buckets there are, the fewer entries will be assigned to
  the same bucket, so retrievals will be much faster.

But the price of speed is an increase in the amount of memory that the hash table uses.

INSPECT can be used to look at the entries of a hash table.

CL-USER> (describe hhh)
#<HASH-TABLE :TEST EQL :COUNT 2 {1005089A33}>
  [hash-table]

Occupancy: 0.1
Rehash-threshold: 1.0
Rehash-size: 1.5
Size: 14
Synchronized: no
; No value
CL-USER> (inspect hhh)

The object is a STRUCTURE-OBJECT of type HASH-TABLE.
0. GETHASH-IMPL: #<FUNCTION SB-IMPL::GETHASH/EQL>
1. PUTHASH-IMPL: #<FUNCTION SB-IMPL::PUTHASH/EQL>
2. REMHASH-IMPL: #<FUNCTION SB-IMPL::REMHASH/EQL>
3. CLRHASH-IMPL: #<FUNCTION SB-IMPL::CLRHASH-IMPL>
4. PAIRS: #(2 0 JOHN (ATTORNEY (16 MAPLE DRIVE)) MARY
            (PHYSICIAN (23 CEDAR COURT)) #<unbound> #<unbound> #<unbound>
            #<unbound> #<unbound> #<unbound> #<unbound> #<unbound> #<unbound>
            #<unbound> #<unbound> #<unbound> #<unbound> #<unbound> #<unbound>
            #<unbound> #<unbound> #<unbound> #<unbound> #<unbound> #<unbound>
            #<unbound> #<unbound> #<unbound>
            #(0 786724036 1989986058 0 0 0 0 0 0 0 0 0 0 0 0))
5. CACHE: 2
6. INDEX-VECTOR: #(0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0)
7. NEXT-VECTOR: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
8. HASH-VECTOR: #(0 786724036 1989986058 0 0 0 0 0 0 0 0 0 0 0 0)
9. FLAGS: 0
10. LOCK: #<SB-THREAD:MUTEX "hash-table lock" (free)>
11. TEST-FUN: #<FUNCTION EQL>
12. HASH-FUN: #<FUNCTION SB-IMPL::EQL-HASH>
13. TEST: EQL
14. REHASH-SIZE: 1.5
15. REHASH-THRESHOLD: 1.0
16. %COUNT: 2
17. NEXT-FREE-KV: 3
18. N-REHASH+FIND: 0
19. N-LSEARCH: 0
20. SMASHED-CELLS: NIL
21. NEXT-WEAK-HASH-TABLE: NIL
22. CULLED-VALUES: NIL



---
13.8 PROPERTY LISTS

In Lisp, every symbol has a property list.

Property lists provide basically the same facilities as association lists and hash tables.
  We can store a value in a property list under a given key called an indicator.
   Things can be looked up later within a property list by supplying the indicator.

Property lists are organized as lists of alternating indicators and values:

(indicator-1 value-1 indicator-2 value-2 ..)


Property lists are old and came with Lisp 1.5.

They are included in this text as an exercise of completeness;
  for most applications it is better to use a hash table or an association list.

Many Lisp implementations use the property list of symbols for their own purposes.
  If we took the property list of CONS or COND we may see system-specific information.

Lisp programmers are free to input their own defined properties on the property list,
  but it is a very bad idea to tamper with the built-in properties.


The GET function retrieves a property of a symbol given an indicator.

SETF has a handle on GET as a place description;
  this is how new properties are stored in the property list.

We can give the value FRED a property called SEX with the value of MALE,
  a property called AGE with a value of 23, and a property called SIBLINGS
    with a value (GEORGE WANDA).

CL-USER> (setf (get 'fred 'sex) 'male)

MALE
CL-USER> (setf (get 'fred 'age) 23)
23
CL-USER> (setf (get 'fred 'siblings) '(george wanda))
(GEORGE WANDA)
CL-USER> (describe 'fred)
COMMON-LISP-USER::FRED
  [symbol]

Symbol-plist:
  SIBLINGS -> (GEORGE WANDA)
  AGE -> 23
  SEX -> MALE
; No value


The actual property list of FRED looks like:

(siblings (george wanda) age 23 sex male)


Retrieving one of FREDs properties is easy;
  we just use GET to search the property list.
    *NOTE* GET uses tye EQ function to check for equality,
      so property indicators must not be numbers.
        Normally they are symbols:

CL-USER> (get 'fred 'age)
23
CL-USER> (get 'fred 'bung)
NIL


When a symbol does not have a specified property, GET normally returns NIL.

However, GET also accpets a third argument that it will return instead of NIL
  if it cannot find the property it was asked to look up.

This is one way to distinguish a symbol having a property BUNG with
  the value NIL from a symbol that does not have a BUNG value at all.

CL-USER> (setf (get 'mabel 'siblings) nil)
NIL
CL-USER> (get 'mabel 'siblings 'unknown)
NIL
CL-USER> (get 'clara 'siblings 'unknown)
UNKNOWN


The value of a property can be changed at any time.
  Maybe FRED has a birthday.

CL-USER> (incf (get 'fred 'age))
24
CL-USER> (get 'fred 'age)
24


The SYMBOL-PLIST function returns a symbol's property list

CL-USER> (symbol-plist 'fred)
(SIBLINGS (GEORGE WANDA) AGE 24 SEX MALE)


Properties can be removed entirely with REMPROP.

The value returned by REMPROP is implementation dependant.

It will be non-NIL if the property was found on the property list,
  or NIL if the property was not found.

As a side effect, both the property name and the associated value
  are removed from the property list.

CL-USER> (remprop 'fred 'age)
(AGE 24 SEX MALE)
CL-USER> (get 'fred 'age)
NIL



---
13.9 PROGRAMMING WITH PROPERTY LISTS

Suppose we are building a database about the characters in a story
  and one of the facts we want to include is meetings between characters.

We can store a list of names under the HAS-MET property of each individual.

A name should not appear on the list more than once,
  which would make the list a set.

The easiest way to do this is to write a function called ADDPROP to
  add an element to a set stored under a property name.

(defun addprop (sym e prop)
  (pushnew e (get sym prop)))


PUSHNEW is a generalized assignment operator like PUSH, but it first checks
  to make sure the element is not a member of the list, so it is useful for adding
    an element to a set.


Using our ADDPROP function we can easily write a function to record meetings:

(defun record-meeting (x y)
  (addprop x y 'has-met)
  (addprop y x 'has-met)
  t)


'HAS-MET has a symmetric relation within this function definition.
  If X has met Y, then Y has met X.

The symmetric relationship is taken advantage of by this function.
  If the function were only defined with one side of the relationship,
    the meeting would never be recorded the person input second.



EXERCISES

13.1 Write a function called SUBPROP that deletes an element from a set
       stored under a property name.

(defun subprop (symbol item property)
  (setf (get symbol property)
        (remove item (get symbol property))))

CL-USER> (setf (get 'pirate-ship 'loot) '(gold gems silver))
(GOLD GEMS SILVER)
CL-USER> (setf (get 'pirate-ship 'loot)
               (remove 'gems (get 'pirate-ship 'loot)))
(GOLD SILVER)

CL-USER> (remprop 'pirate-ship 'loot)
(LOOT (GOLD SILVER) CAPTAIN WILLY-GAVELSTON NAME BLOODY-KISSES CANNONS 5 CREW
 25)

CL-USER> (setf (get 'pirate-ship 'loot) '(gold gems silver))
(GOLD GEMS SILVER)
CL-USER> (subprop 'pirate-ship 'gems 'loot)
(GOLD SILVER)


We give SUBPROP a symbol like PIRATE-SHIP the item we want to remove like GEMS
  and a property indicator such as LOOT which has a property value containing the list
    of symbols (GOLD GEMS SILVER).

Our pirates GEMS got seized by the Naval Bungholes.

We want to remove the GEMS item from this list now.

SETF is the engine of the function definition here, the property LOOT is held,
  LOOT contains a value.

With LOOT held to the side, the other part of the form does the work to evaluate our new
  value for the LOOT property.

A REMOVE expression takes one of our inputs GEMS which is an item of the LOOT property,
  then it removes it.

GEMS is removed from that list, the value (GOLD SILVER) us passed to the top of the SETF form.

SETF destructively changes that property value.



13.2 Write a function called FORGET-BATTLE that forgets that two
       particular ships have battled one another.

(setf (get 'pirate-ship 'captain) 'willy-gavelston)

(setf (get 'pirate-ship 'crew) 25)

(setf (get 'pirate-ship 'name) 'bloody-kisses)

(setf (get 'pirate-ship 'cannons) 5)

(setf (get 'pirate-ship 'loot) 'gold-and-silver)


(defun has-battled (ship-1 ship-2)
  (addprop ship-1 ship-2 'has-battled)
  (addprop ship-2 ship-1 'has-battled)
  t)


(setf (get 'naval-vessel 'admiral) 'deushenbag)

(setf (get 'naval-vessel 'crew) 50)

(setf (get 'naval-vessel 'name) 'sandusky)

(setf (get 'naval-vessel 'cannons) 15)

(setf (get 'naval-vessel 'siezed-contraband) '(gems))


(defun forget-battle (ship-1 ship-2)
  (subprop ship-1 ship-2 'has-battled)
  (subprop ship-2 ship-1 'has-battled)
  'history-erased)

CL-USER> (symbol-plist 'pirate-ship)
(HAS-BATTLED (NAVAL-VESSEL) LOOT (GOLD SILVER) CAPTAIN WILLY-GAVELSTON NAME
             BLOODY-KISSES CANNONS 5 CREW 25)
CL-USER> (symbol-plist 'naval-vessel)
(HAS-BATTLED (PIRATE-SHIP) SIEZED-CONTRABAND (GEMS) CANNONS 15 NAME SANDUSKY
             CREW 50 ADMIRAL DEUSHENBAG)
; compiling (DEFUN FORGET-BATTLE ...)
CL-USER> (forget-battle 'pirate-ship 'naval-vessel)

HISTORY-ERASED
CL-USER> (symbol-plist 'pirate-ship)
(HAS-BATTLED NIL LOOT (GOLD SILVER) CAPTAIN WILLY-GAVELSTON NAME BLOODY-KISSES
             CANNONS 5 CREW 25)
CL-USER> (symbol-plist 'naval-vessel)
(HAS-BATTLED NIL SIEZED-CONTRABAND (GEMS) CANNONS 15 NAME SANDUSKY CREW 50
             ADMIRAL DEUSHENBAG)


This is simply the inverse of HAS-BATTLED,
  note that the quoted property HAS-BATTLED adds a new property to
    the input symbols.

If we wanted, we could change HAS-BATTLED to something else after the battle
  has been erased.



13.3 Using SYMBOL-PLIST, write your own version of the GET function.

(defun get-property-value (symbol property)
  (do ((prop (symbol-plist symbol) (cddr prop)))
      ((null prop) nil)
    (if (equal property (first prop))
        (return (second prop)))))


GET-PROPERTY-VALUE imitates GET, it takes a symbol like PIRATE-SHIP and a property like CREW
  and returns the property value like 25.

CL-USER> (symbol-plist 'pirate-ship)
(HAS-BATTLED NIL LOOT (GOLD SILVER) CAPTAIN WILLY-GAVELSTON NAME BLOODY-KISSES
             CANNONS 5 CREW 25)

CL-USER> (get 'pirate-ship 'crew)
25

Var-1: prop
Init-1: (symbol-plist symbol)
Update-1: (cddr prop)
Test: (null prop)
Action: nil
Body: (if (equal property (first prop))
          (return (second prop)))


We create a DO form, meaning we will iteratively step through a thing to find some value.

Our initial variable the DO form works on is the entire property list of the input SYMBOL
  which would look something like:

CL-USER> (symbol-plist 'pirate-ship)
(HAS-BATTLED NIL LOOT (GOLD SILVER) CAPTAIN WILLY-GAVELSTON NAME BLOODY-KISSES
             CANNONS 5 CREW 25)


This list is initially set as PROP.

It isn't empty, so this list is passed to the body of the DO form to be evaluated further.

The body consists of an IF statement, testing if the input PROPERTY is equal
  to the first element in the PROP list from above.

If equality is satisfied, the following element is returned.

Property lists are organized as indicator,value sets. The GET function returns the VALUE portion
  of an indicator,value set of a property list.

(RETURN (SECOND PROP)) returns the indicator value, not the indicator.

CL-USER> (cddr (symbol-plist 'pirate-ship))
(LOOT (GOLD SILVER) CAPTAIN WILLY-GAVELSTON NAME BLOODY-KISSES CANNONS 5 CREW
 25)


So if the equality test is satisfied in this example,
 (GOLD SILVER) would be returned because it is the SECOND element of the list,
   and the indicator value in the property list indicator,value set.

CL-USER> (get-property-value 'pirate-ship 'loot)
(GOLD SILVER)



13.4 Write predicate HASPROP that returns T or NIL to indicate whether
       a symbol has a particular property, independent of the value of that property.

(defun has-property (symbol property)
  (do ((p (symbol-plist symbol) (cddr p)))
      ((null p) nil)
    (if (equal property (first p))
        (return t))))


This function is identical to GET-PROPERTY-VALUE, except that T or NIL
  are returned instead of some property value.



SUMMARY

Like lists, arrays are a kind of sequence.

One-dimensional arrays are called vectors.
  Strings are vectors of characters.

Arrays can be created with MAKE-ARRAY, and array elements accessed with AREF.
  Many functions that work on lists also work on arrays (LENGTH REVERSE FIND-IF).


Hash tables offer essentially the same functionality as association lists.

Hash tables provide for very efficient lookup of items, because they don't
  search the table sequentially the way ASSOC does.

Instead a hashing algorithm is used to compute a subscript,
  which is used to access a vector.


Property lists are attaches to symbols, and are used by some Lisp systems
  to store implementation dependant information.

Property lists are used infrequently in modern Lisp programming.


Hash tables are preferred over both property lists and association lists
  when efficient access is important.



REVIEW EXERCISES

13.5 Give one advantage of arrays over lists.

The contiguous storage in arrays allows us to access one element in the array
  as fast as any other element therein.

To access the element of a list, the chain of pointers all the way to the list
  element need to be followed.

Accessing an element at the end of a very long list may take time when compared to an array.


13.6 Give one advantage of lists over arrays.

Lists of arbitrary length are built up element by element recursively or iteratively.
  Arrays are not as simple to build in this way.


13.7 Which requires more cons cells: a property list or an association list of dotted pairs?

These two datatypes seem to create the same amount of cons cell,
  just in a different structure.

S> (list (cons 'c '3) (cons 'b '2) (cons 'a '1))

[*|*]------->[*|*]------->[*|*]--->NIL
 |            |            |
 v            v            v
[*|*]--->3   [*|*]--->2   [*|*]--->1
 |            |            |
 v            v            v
 C            B            A

Result:  ((C . 3) (B . 2) (A . 1))

S> (symbol-plist 'test-plist)

[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->[*|*]--->NIL
 |        |        |        |        |        |
 v        v        v        v        v        v
 C        3        B        2        A        1

Result:  (C 3 B 2 A 1)



FUNCTIONS COVERED

Array functions: MAKE-ARRAY AREF
Printer-switch: *PRINT-ARRAY*
Hash table functions: MAKE-HASH-TABLE GET-HASH
Property list functions: GET SYMBOL-PLIST REMPROP



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Array Keyboard Exercise
;;
;;

We are going to find out how random our implementations random number generator is.

A histogram plot of two hundred random values between zero and ten.

We will use an array to keep track of how many times a value has been encountered.

CL-USER> (mapcar #'random '(10 10 10 10 10))
(9 5 1 3 5)


The RANDOM function returns a random integer from 0 to n-1.
  So (RANDOM 5) will return any number 0-4.

We are going to use this.


EXERCISE

Use (LENGTH *HIST-ARRAY*) as the constant in our programs so that our program
  will be able to generate histograms of any size.

a. Write expressions to set up global variable *HIST-ARRAY* that holds the array
     of counts, and a global variable *TOTAL-POINTS* that holds the total number
       of points recorded so far.

CL-USER> (setf *hist-array* nil)
NIL
CL-USER> (setf *total-points* 0)
0



b. Write function NEW-HISTOGRAM to initialize these variables appropriately.
     It should take one input, the number of total bins the histogram will have.

(defun new-histogram (bins)
  (setf *total-points* 0)
  (setf *hist-array*
        (make-array bins :initial-element 0))
  t)

NEW-HISTOGRAM takes a number which is how many total bins the array will store.

The purpose of this function is to create an array of n BINS, the return value is T
  which would indicate that the function has evaluated correctly.



c. Write RECORD-VALUE that takes a number as input. If the number is between zero
     and ten, it should increment all of the appropriate elements of the array, and also
       update *TOTAL-POINTS*.

(defun record-value (v)
  (incf *total-points*)
  (if (and (>= v 0)
           (< v (length *hist-array*)))
      (incf (aref  *hist-array* v))
      (error "Value ~S out of bounds." v)))


RECORD-VALUE takes a number.

(INCF *TOTAL-POINTS*) increments the total number of elements in the array.
  This expression evaluates every time RECORD-VALUE is called.


The other portion of the function body is an IF statement.

The test of the IF is a conditional AND.
  AND evaluates each expression one at a time until one returns NIL,
    which and passes up as the return value.

AND evaluates the expression (>= v 0).
  If the input is not greater than or equal to zero
    then return NIL. Keep going for T.

AND then evaluates the expression (< v (length *hist-array*)).
  If the input is less than the length of the array of counts then
    evaluate the THEN expression and increment the input by one.

If our value returns NIL for both of the tests, an error string is returned
  notifying the user that the value is not within the specifications of the function.



d. Write function PRINT-HIST-LINE that takes a value from zero to ten as input,
     looks up that value in the array, and prints the corresponding line of the histogram.
       Directive ~2S must be used for the value and ~3S for the count display.

(defun print-hist-line (i)
  (let ((val (aref *hist-array* i)))
    (format t "~&~2D [~3D] " i val)
    (dotimes (j val)
      (format t "*"))))


This function takes an integer 0-10, let's call it 3.
  So 3 would be looked up in the array *HIST-ARRAY*,
    and its value would be printed on the corresponding line
      of the histogram.

In the book example 3 has a value of 8 instances.

A LET form wraps the function definition.

Var-1: 8
Val-1: (aref *hist-array* 3)
Body:
(format t "~&~2S [~3S] " 3 8)
(dotimes (j 8)
  (format t "*")))


The DOTIMES form is there to print an asterisk as many times as VAL
  on the 3 line of the array.

(defun print-hist-line (3)
  (let ((8 (aref *hist-array* 3)))
    (format t "~&~2D [~3D] " 3 8)
    (dotimes (j 8)
      (format t "*"))))



e. Write function PRINT-HISTOGRAM.

(defun print-histogram ()
  (dotimes (i (length *hist-array*))
    (print-hist-line i))
  (format t "~&    ~3D total" *total-points*))



Here it is in action.
  TIME was added for flavour.

CL-USER> (new-histogram 11)
T
CL-USER> (time (dotimes (i 500)
                 (record-value (random 11))))
Evaluation took:
  0.000 seconds of real time
  0.000000 seconds of total run time (0.000000 user, 0.000000 system)
  100.00% CPU
  80,668 processor cycles
  0 bytes consed
  
NIL
CL-USER> (time (print-histogram))
 0 [ 46] **********************************************
 1 [ 52] ****************************************************
 2 [ 47] ***********************************************
 3 [ 51] ***************************************************
 4 [ 43] *******************************************
 5 [ 38] **************************************
 6 [ 43] *******************************************
 7 [ 41] *****************************************
 8 [ 55] *******************************************************
 9 [ 44] ********************************************
10 [ 40] ****************************************
    500 total
Evaluation took:
  0.000 seconds of real time
  0.000000 seconds of total run time (0.000000 user, 0.000000 system)
  100.00% CPU
  541,741 processor cycles
  65,520 bytes consed
  
NIL



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Hash Table Keyboard Exercise
;;
;;

A cryptogram is a type of puzzle that requires the solver to decode a message.

The code is known as a substitution cipher because it consists of substituting
  one letter for another throughout the message.

zj ze kljjls jf slapzi ezvlij pib kl jufwxuj p hffv jupi jf
enlpo pib slafml pvv bfwkj

The stream of text above is a cryptogram.

Our program will start out by representing our cryptogram as a list of strings
  and store that in some variable.

CL-USER> (setf cryptogram-text '("zj ze kljjls jf slapzi ezvlij pib kl jufwxuj p hffv jupi jf"
"enlpo pib slafml pvv bfwk"))
("zj ze kljjls jf slapzi ezvlij pib kl jufwxuj p hffv jupi jf"
 "enlpo pib slafml pvv bfwk")


When solving cryptograms, it helps to solve the shortest words first.

In English there are only two one-letter words "I" and "a",
  so we know the tenth word of the cryptogram is one of those.

Suppose P deciphered to A, so under each P in the text we would write
  an A to mark the translation.

Sticking to the short word strategy, we could move to two letter words.
  Maybe Z deciphers to I, so mark an I under the Zs.

An important constraint on cryptograms that helps to make them solvable is
  that no letter can decipher to more than one thing, and no two letters can
    decipher to the same thing.

Our program must make this check to ensure a correct solution.

Our program should also allow us to change or decipher choices.



EXERCISE

Set up the global variable CRYPTO-TEXT as shown.

Then build the cryptogram solving tool.

CL-USER> (setf cryptogram-text '("zj ze kljjls jf slapzi ezvlij pib kl jufwxuj p hffv jupi jf"
"enlpo pib slafml pvv bfwk"))
("zj ze kljjls jf slapzi ezvlij pib kl jufwxuj p hffv jupi jf"
 "enlpo pib slafml pvv bfwk")

The crypto

a. Each letter in the alphabet has a corresponding letter to which it deciphers.
     As we solve the cryptogram the data will be stored in two hash tables called
       *ENCIPHER-TABLE* and *DECIPHER-TABLE*.

   We will use *DECIPHER-TABLE* to print out the deciphered cryptogram.
     *ENCIPHER-TABLE* will check that a decipher-token is only assigned to one letter.
       The inverse can also be used with *DECIPHER-TABLE* to check which decipher
         token a letter is assigned to.

   Write expressions to initialize these global variables.

(setf *decipher-table* (make-hash-table))

(setf *encipher-table* (make-hash-table))



b. Write function MAKE-SUBSTITUTION that takes two character objects as input and
     stores the appropriate entries in *DECIPHER-TABLE* and *ENCIPHER-TABLE* so that
       the first letter deciphers to the second, and the second enciphers to the first.
         This function does not need to check if either letter already has a hash table entry.

(defun make-substitution (object-1 object-2)
  (setf (gethash 'object-2 *encipher-table*)
        object-1)
  (setf (gethash 'object-1 *decipher-table*)
        object-2))



c. Write UNDO-SUBSTITUTION that takes one letter as input, setting the *DECIPHER-TABLE*
     entry of that letter, and the *ENCIPHER-TABLE* entry of the letter it deciphered to to NIL.

(defun undo-substitution (code clear)
  (setf (gethash clear *encipher-table*) nil)
  (setf (gethash clear *decipher-table*) nil))



d. Look up the CLRHASH function. Write a function CLEAR that clears the hash
     tables in this exercise.

(defun clear-hash-tables ()
  (clrhash *encipher-table*)
  (clrhash *decipher-table*))



e. Write a function DECIPHER-STRING that takes a single encoded string as input and returns a new,
     partially decoded string.

   It should begin by making a new string the same length as the input, containing all spaces.
     Here is how to do that assuming the variable LEN holds the length:

       (make-string len :initial-element #/Space)

   Next, the function should iterate through the elements of the input string,
     which are character objects. For each character that deciphers to something non-NIL,
       That value should be inserted into the corresponding position into the new string.
         When testing this function, make sure that all of its inputs are lowercase.

(defun decipher-string (string)
  (do* ((length-of-string (length string))
        (new-string (make-string length-of-string
                                 :initial-element #\Space))
        (i 0 (1+ i)))
       ((equal i length-of-string) new-string)
    (let* ((character (aref string i))
           (new-character (gethash character *decipher-table*)))
      (when new-character
        (setf (aref new-string i) new-character)))))


A DO* form wraps the function definition.

Var-1: length-of-string
Init-1: (length string)
Var-2: new-string
Init-2: (make-string length-of-string :initial-element #\Space))
Var-3: i
Init-3: 0
Update-3: (1+ i)
Test: ((equal i length-of-string) new-string)
Body:
(let* ((character (aref string i))
       (new-character (gethash character *decipher-table*)))
  (when new-character
    (setf (aref new-string i) new-character)))

LENGTH-OF-STRING simply stores the length of the input string.
  The expression in Init-1 clarifies this.

Var-2, NEW-STRING is going to store a new string that is LENGTH-OF-STRING but all spaces.
  Init-2's expression uses the keyword argument :initial-element and #/Space.

The third variable i begins at zero, stepping up incrementally by one.

We are testing for EQUALity between the length of the string and the i variable.
  Once the test is satisfied, NEW-STRING is evaluated.

*NOTE* all three variables covered are sequentially evaluated in the DO* down to its body
  meeting the LET* continuing a sequential evaluation process and passing down all of its
    locally defined variables.


The LET* body.

    (let* ((character (aref string i))
           (new-character (gethash character *decipher-table*)))
      (when new-character
        (setf (aref new-string i) new-character)))))


Var-1: character
Value-1: (aref string i)
Var-2: new-character
Value-2: (gethash character *decipher-table*)
Body:
(when new-character
  (setf (aref new-string i) new-character))


CHARACTER is going to be whatever token is located at the number-location i
  in the input string array.

NEW-CHARACTER is whatever the CHARACTER token deciphers to on the *DECIPHER-TABLE*.


The body of this function uses i and NEW-STRING from the DO* as well as the WHEN conditional,
  which will evaluate stopping and returning NIL at a NIL or returning the value of the
    last expression evaluated.

WHEN NEW-CHARACTER happens SETF destructively sets NEW-CHARACTER in the NEW-STRING of
  spaces at location i on that formerly blank string.


When all the combinators accumulate, a new blank string is created to mirror the input string.
  The DO* traces these to strings in the LET* of its body.
    The LET* form references the *DECIPHER-TABLE* hash table and destructively modifies
      the blank string that was initially created with the deciphered characters.



f. Write function SHOW-LINE that displays one line of cryptogram text,
     with the deciphered text displayed beneath it.

(defun show-line (line)
  (format t "~%~A~%~A~%"
          line
          (decipher-string line)))


This is a simple i/o function that creates a new line, prints LINE, creates
  a new line, prints the return value of DECIPHER-STRING, then creates a new line.



g. Write function SHOW-TEXT that takes a cryptogram (list of strings) as input
     and displays the lines as in the examples at the beginning of the exercise.

(defun show-line (line)
  (format t "~%~A~%~A~%"
          line
          (decipher-string line)))

(defun show-text ()
  (format t "~&----------------")
  (dolist (line crypto-text)
    (show-line line))
  (format t "~&----------------"))



h. Type in the definition of GET-FIRST-CHAR, which returns the first character in the
     lowercase printed representation of an object.

       (defun get-first-char (x)
         (char-downcase
           (char (format nil "~A" x) 0)))


CHAR accesses the element of a string at the specified index.
  The index starts at zero.

The input character is accessed and converted downcase.



i. Write a function READ-LETTER that reads an object from the keyboard.
     If the object is the symbol END or UNDO, it should be returned as the value
       of READ-LETTER. Otherwise READ-LETTER should use GET-FIRST-CHAR on the object
         to extract the first character of its printed representation; it should return
           that character as a result.

(defun read-letter ()
  (let ((obj (read)))
    (if (member obj '(end undo))
        obj
        (get-first-char obj))))


LET form with one variable

Var-1: obj
Val-1: read
Body:
(if (member obj '(end undo))
    obj
    (get-first-char obj))


OBJ is the object being READ from the keyboard, whatever READ evaluates to
  is the value of OBJ.


The IF form test whether the object being read from the keyboard is either
  symbols END or UNDO.

For a T test value OBJ is returned.

For NIL GET-FIRST-CHAR is called on the object being read from the keyboard,
  so the first character will be returned in lowercase.



k. Write a function SUB-LETTER that takes a character object as input. If that character
     has been deciphered already, SUB-LETTER should print an error message that tells
       which letter it has been deciphered to. Otherwise SUB-LETTER asks what the user
         think the letter deciphers to, and then read that letter. If the result is a
           character and it hasn't been enciphered, SUB-LETTER should call MAKE-SUBSTITUTION
             to record the substitution. Otherwise an error message should be printed.

(defun sub-letter (code)
  (when (gethash code *decipher-table*)
    (format t "~&'~A' has already been" code)
    (format t "deciphered as '~A'!"
            (gethash code *decipher-table*))
    (return-from sub-letter nil))
  (format t "What does '~A' decipher to? " code)
  (let ((clear (read-letter)))
    (cond ((not (characterp clear))
           (format t "~&Invalid response."))
          ((gethash clear *encipher-table*)
           (format t "But '~A' already"
                   (gethash clear *encipher-table*))
           (format t " deciphers as '~A'!"
                   clear))
          (t (make-substitution code clear)))))


This is really just a bunch of FORMAT T expressions, that's why its looks like that.

We start with a WHEN conditional, then a prompt questioning the user, and lastly a LET
  form with one variable and a COND clause making up the body.


WHEN evaluates all the forms in its body within this function.
  GETHASH will get the hash table value for CODE.
    Then a string is printed to top-level explaining that the character has
      already been deciphered.

If the WHEN comes up NIL, a string prompts the user which letter CODE
  deciphers to.


The LET determines the user response to pass up.

Var-1: clear
Val-1: read-letter
Body:
(cond ((not (characterp clear))
       (format t "~&Invalid response."))
      ((gethash clear *encipher-table*)
       (format t "But '~A' already"
               (gethash clear *encipher-table*))
       (format t " deciphers as '~A'!"
               clear))
      (t (make-substitution code clear)))


CLEAR is going to have the value of READ-LETTER, which reads an object from the keyboard.

Test-1: (not (characterp clear))
Consequent-1: (format t "~&Invalid response.")
Test-2: (gethash clear *encipher-table*)
Consequent-2: (format t "But '~A' already"
                      (gethash clear *encipher-table*)
              (format t " deciphers as '~A'!"
              clear))
Test-3: t
Consequent-3: (make-substitution code clear)

The body of the LET is a COND clause.

The first test/consequent set tests whether CLEAR is not a character.
  If a T is evaluated, a string is returned.

The second test/consequent set checks whether CLEAR is on the *ENCIPHER-TABLE*,
  if it's on the table a string explaining that this input has already been deciphered.

The last test/consequent set is the clause of form, which is the form that is guaranteed
  to be evaluated. If all the previous sets return NIL, MAKE-SUBSTITUTION is called on
    the input CODE and CLEAR is read from the keyboard.

Remember that MAKE-SUBSTITUTION sets the hash value of CODE to the hash value of clear,
  and the hash value of CLEAR if set to the hash value of CODE, creating an entry for both
    on either table.



l. Write the main function SOLVE that takes a cryptogram as input. SOLVE should perform
     the following loop. First it should display the cryptogram. Then it should ask
       "Substitute which letter?"

(defun solve (string-1 string-2)
  (do ((resp nil))
      ((equal resp 'end))
    (show-text)
    (format t "~&Substitute which letter? ")
    (setf resp (read-letter))
    (cond ((characterp resp) (sub-letter resp))
          ((equal resp 'undo) (undo-letter))
          ((equal resp 'end) nil)
          (t (format t "~&Invalid input.")))))


SOLVE consists of a DO form, printed text strings on the REPL and a COND clause.

The DO wraps the entire function body definition. The body of the DO consists
  of multiple Lisp expressions explained below.

Var-1: resp
Init-1:
Update-1: nil
Test: (equal resp 'end)
Body:
(show-text)
(format t "~&Substitute which letter? ")
(setf resp (read-letter))
(cond ((characterp resp) (sub-letter resp))
      ((equal resp 'undo) (undo-letter))
      ((equal resp 'end) nil)
      (t (format t "~&Invalid input.")))


The variable RESP doesn't need to update, it is fed to functions that input it into
  the two hash tables.

To exit the loop an equality test for the symbol END is used.


The body of the DO contains four clauses,

(SHOW-TEXT) which is the function that prints the cryptogram and surrounding characters.

(FORMAT T "~&Substitute which letter? ") a string prompting the user for input.

Lastly the COND clause,

((characterp resp) (sub-letter resp))
Testing whether RESP is a character, if so SUB-LETTER is called on RESP.

((equal resp 'undo) (undo-letter))
If the symbol 'UNDO is equal to RESP then UNDO-LETTER is called on RESP.

((equal resp 'end) nil)
If the symbol 'END is equal to RESP then NIL is returned.

(t (format t "~&Invalid input."))
This is the clause of form for the COND clause, which is guaranteed to evaluate the consequent.
  If all other tests are not satisfied, a prompt explain that the input is incorrect.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Lisp Toolkit: ROOM
;;
;;

CL-USER> (room)
Dynamic space usage is:   59,819,552 bytes.
Read-only space usage is:      6,016 bytes.
Static space usage is:         1,664 bytes.
Control stack usage is:        5,384 bytes.
Binding stack usage is:          736 bytes.
Control and binding stack usage is for the current thread only.
Garbage collection is currently enabled.

Breakdown for dynamic space:
  13,894,816 bytes for  20,180 code objects
  10,450,336 bytes for 145,832 instance objects
   8,224,512 bytes for  62,153 simple-vector objects
   6,957,072 bytes for 434,817 cons objects
   4,149,728 bytes for  11,086 simple-character-string objects
  11,223,136 bytes for 224,518 other objects

  54,899,600 bytes for 898,586 dynamic objects (space total)
; No value


ROOM gives us an overview of our Lisp's memory usage.

CL-USER> (describe 'room)
COMMON-LISP:ROOM
  [symbol]

ROOM names a compiled function:
  Lambda-list: (&OPTIONAL (SB-VM::VERBOSITY :DEFAULT))
  Declared type: (FUNCTION (&OPTIONAL (MEMBER T NIL :DEFAULT))
                  (VALUES &OPTIONAL))
  Derived type: (FUNCTION (&OPTIONAL (MEMBER :DEFAULT NIL T))
                 (VALUES &OPTIONAL))
  Documentation:
    Print to *STANDARD-OUTPUT* information about the state of internal
      storage and its management. The optional argument controls the
      verbosity of output. If it is T, ROOM prints out a maximal amount of
      information. If it is NIL, ROOM prints out a minimal amount of
      information. If it is :DEFAULT or it is not supplied, ROOM prints out
      an intermediate amount of information.
  Known attributes: unwind, any
  Source file: SYS:SRC;CODE;ROOM.LISP
; No value



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 13 Advanced Topics
;;
;;


---
13.10 PROPERTY LIST CELLS

A symbol is composed of five pointers, three of which we have seen so far;
  the symbol-name, the value-cell, and the function-cell.

The property-list-cell is another, fourth pointer of a symbols five pointers.
  Every symbol in Lisp has a property list, it may be NIL.

In contrast, not every symbol has a function definition in its function-cell,
  or a value in its value cell.

CL-USER> (setf (get 'cat-in-the-hat 'bowtie) 'red)
RED
CL-USER> (setf (get 'cat-in-the-hat 'tail) 'long)
LONG
CL-USER> (symbol-plist 'cat-in-the-hat)
(TAIL LONG BOWTIE RED)


SETF understand SYMBOL-PLIST as a placce name, so it is possible to give a
  symbol a new property list using SETF.

Replacing the contents of a symbol's property list could wipe out important
  properties that Lisp uses.

Property lists today are considered archaic because they are global data structures.
  A symbol's property list is accessible anywhere.

If we use hash tables to store our information, we can keep several of them around
  at the same time, representing different sets of facts.

Each hash table is independent, so changes made to one will not affect the other.



---
13.11 MORE ON SEQUENCES

The COERCE function can be used to convert a sequence from one type to another.

If we COERCE a string to a list, we can see the individual character objects.
  Conversely, we can use COERCE to turn a list of characters into a string.

CL-USER> (coerce "Bunghole" 'list)
(#\B #\u #\n #\g #\h #\o #\l #\e)
CL-USER> (coerce '(#\B #\u #\n #\g) 'string)
"Bung"
CL-USER> (describe 'coerce)
COMMON-LISP:COERCE
  [symbol]

COERCE names a compiled function:
  Lambda-list: (SB-IMPL::OBJECT SB-IMPL::OUTPUT-TYPE-SPEC)
  Declared type: (FUNCTION
                  (T (OR CONS SYMBOL SB-KERNEL:CLASSOID CLASS))
                  (VALUES T &OPTIONAL))
  Derived type: (FUNCTION (T T) *)
  Documentation:
    Coerce the Object to an object of type Output-Type-Spec.
  Known attributes: movable
  Source file: SYS:SRC;CODE;COERCE.LISP
; No value
CL-USER> (coerce '(whale dolphin walrus) 'vector)
#(WHALE DOLPHIN WALRUS)


Another way we can make a string is to make a vector with MAKE-ARRAY, using the
  :ELEMENT-TYPE keyword to specify that this vector holds only objects of type STRING-CHAR.
    Vectors of STRING-CHARs are also strings.

*NOTE* STRING-CHARs are a subtype of character.

CL-USER> (make-array 3 :element-type 'string-char
                     :initial-contents '(#\M #\o #\m))
#(#\M #\o #\m)


Most of the applicative operators, such as FIND-IF and REDUCE, work on any type of sequence,
  not just lists.

MAPCAR is specific to lists, but there exists a more general mapping function MAP,
  which works on sequences of any type.

The first input to MAP specifies the type of the result, the second input is the mapping function,
  and the remaining inputs are sequences to be mapped over.

MAP stops when it reaches the end of any of the input sequences.

CL-USER> (map 'list #'list
              '(a b c)
              '(1 2 3)
              "xyz")
((A 1 #\x) (B 2 #\y) (C 3 #\z))


If MAP is given NIL as its first argument, it returns NIL instead of constructing a sequence
  from the results of the mapping. This is useful if you want to apply a function to every element
    of a sequence only for its side effect.

CL-USER> (map nil #'print "a b")

#\a 
#\  
#\b 
NIL



FUNCTIONS COVERED IN ADVANCED TOPICS

Sequence functions: MAP COERCE



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  14 Macros and Compilation
;;
;;

Macro functions are a way to extend the syntax of Lisp.



---
14.2 MACROS AS SHORTHAND

For now we can think of macros as a sort of computer shorthand.
  Anything we can write in shorthand can be written in plain English,
    it would just take longer.

At the same time, Common Lisp macros will not let you say anything that cannot
  be expressed with normal functions, but they do help us say things more concisely.


INCF is a good example.

It is quicker to write (INCF A) than (SETF A (+ A 1)).

CL-USER> (ppmx (incf g))
Macro expansion:
(SETQ G (+ 1 G))

; No value


Macros are clever because they are able to interpret arbitrarily complex
  place descriptions of generalized variables.

(incf (aref (nth array-num *list-of-arrays*)
            (first subscripts)))


Macros can generate complicated programs from simple parameters.

Remember when creating the STARSHIP structure, DEFSTRUCT turned a simple structure
  definition into a long stream of instructions for supporting the newly defined
    STARSHIP datatype.

The MAKE-STARSHIP and STARSHIP-P function definitions were created,
  including all of the accessor functions for all of the STARSHIP data
    structural components.



---
14.3 MACRO EXPANSION

When we write things in shorthand, they would eventually need to be expanded
  to be understood and acted upon.

Lisp automatically expands macro calls for this reason.


A macro is actually a special shorthand expanding function that does not
  evaluate its arguments.

Its job is to look at its arguments and produce an expression
  that Lisp can evaluate.

CL-USER> (ppmx (incf g))
Macro expansion:
(SETQ G (+ 1 G))

; No value


INCF constructs the expression (SETQ G (+ 1 G)) on the unevaluated G.
  After Lisp evaluates the expression, G has been incremented by one.

SETQ performs assignment on ordinary variables.

When we use SETF to assign to an ordinary variable,
  the SETF macro actually expands into a call to SETQ.


In evaltrace notation, macro expansion is shown by a dotted line.
  The expression the macro returns is evaluated normally,
    shown by a thin solid line in the following diagram.

PPMX is a tool that expands macros,
  emacs provides commands that expand macros.


Some implementations expand INCF differently.

INCF may expand into a LET expression that creates a local variable to
  hold the value of (+ A 1), and then stores that value back into A.

> (ppmx (incf a))
Macro expansion:
(LET ((#:G0144 (+ A 1)))
(SETQ A #:G0144))


Using a LET expression may be an indirect way of incrementing G,
  this is because INCF is designed to handle much more complex cases
    involving generalized assignment.

#:G0144 is an internal symbol called a gensym.

It was automatically generated by INCF to serve as a local variable name.

Gensyms are guaranteed to not conflict with the names of any of our variables.

#:G0144 is different than G0144.
  We cannot type this symbol from our keyboard,
    so it will never conflict with any variable in our program
      even if we explicitly choose the name G0144 for a variable.



EXERCISES

14.1 Use PPMX to find the expression to which (POP X) expands.

CL-USER> (ppmx (pop x))
First step of expansion:
(PROG1 (CAR X) (SETQ X (CDR X)))

Final expansion:
(LET ((#:G704 (CAR X)))
  (SETQ X (CDR X))
  #:G704)

; No value


POP expands into two steps:

(PROG1 (CAR X) (SETQ (CDR X)))

PROG1 returns the value of the first argument.

SETQ sets the cdr of X as X, which is NIL in this case.

The car of X is NIL so PROG1 evaluates X to NIL and passed to the
  final expansion.

The function expands into a LET,

(LET ((#:G704 (CAR X)))
  (SETQ X (CDR X))
  #:G704)


Var-1: #:G704
Val-1: (car x)
Body:
(SETQ X (CDR X))
#:G704)

Variable one is the gensym #:G704 being stored as (CAR X) which is NIL.

The body uses the variable X, by setting it to the CDR of X, which is nothing,
  and the gensym #:G704 is evaluated last.



14.2 Use PPMX to see what expression the following DEFSTRUCT expands.

CL-USER> (ppmx (defstruct starship
                 (name nil)
                 (condition 'green)))
Macro expansion:
(PROGN
 (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
   (SB-KERNEL::%DEFSTRUCT-PACKAGE-LOCKS
    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION STARSHIP {1004E630C3}>))
 (SB-KERNEL::%DEFSTRUCT
  '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION STARSHIP {1004E630C3}>
  '#(#<SB-KERNEL:LAYOUT for T {10000733C3}>
     #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {1000073443}>)
  (SB-C:SOURCE-LOCATION))
 (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
   (SB-KERNEL::%COMPILER-DEFSTRUCT
    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION STARSHIP {1004E630C3}>
    '#(#<SB-KERNEL:LAYOUT for T {10000733C3}>
       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {1000073443}>)))
 (SB-C:XDEFUN COPY-STARSHIP
     :COPIER
     (SB-KERNEL:INSTANCE)
   (COPY-STRUCTURE (THE STARSHIP SB-KERNEL:INSTANCE)))
 (SB-C:XDEFUN STARSHIP-P
     :PREDICATE
     (SB-KERNEL::OBJECT)
   (TYPEP SB-KERNEL::OBJECT 'STARSHIP))
 (SB-C:XDEFUN (SETF STARSHIP-NAME)
     :ACCESSOR
     (SB-KERNEL::VALUE SB-KERNEL:INSTANCE)
   (SB-KERNEL:%INSTANCE-SET (THE STARSHIP SB-KERNEL:INSTANCE) 1
                            SB-KERNEL::VALUE))
 (SB-C:XDEFUN STARSHIP-NAME
     :ACCESSOR
     (SB-KERNEL:INSTANCE)
   (SB-KERNEL:%INSTANCE-REF (THE STARSHIP SB-KERNEL:INSTANCE) 1))
 (SB-C:XDEFUN (SETF STARSHIP-CONDITION)
     :ACCESSOR
     (SB-KERNEL::VALUE SB-KERNEL:INSTANCE)
   (SB-KERNEL:%INSTANCE-SET (THE STARSHIP SB-KERNEL:INSTANCE) 2
                            SB-KERNEL::VALUE))
#(SB-C:XDEFUN STARSHIP-CONDITION
     :ACCESSOR
     (SB-KERNEL:INSTANCE)
   (SB-KERNEL:%INSTANCE-REF (THE STARSHIP SB-KERNEL:INSTANCE) 2))
 (SB-C:XDEFUN MAKE-STARSHIP
     :CONSTRUCTOR
     (&KEY ((:NAME #:NAME) NIL)
      ((:CONDITION #:CONDITION)
       (SB-C::WITH-SOURCE-FORM (CONDITION 'GREEN) 'GREEN)))
   (DECLARE (SB-INT:EXPLICIT-CHECK)
            (SB-C::LAMBDA-LIST
             (&KEY ((:NAME #:NAME) NIL)
              ((:CONDITION #:CONDITION) (QUOTE GREEN)))))
   (SB-KERNEL::%MAKE-STRUCTURE-INSTANCE-MACRO
    #<SB-KERNEL:DEFSTRUCT-DESCRIPTION STARSHIP {1004E630C3}>
    '((:SLOT T . 1) (:SLOT T . 2)) #:NAME #:CONDITION))
 (SB-KERNEL::%TARGET-DEFSTRUCT
  '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION STARSHIP {1004E630C3}>))

; No value


PROGN expands the entire macro, EVAL-WHEN and SB-KERNEL kick it off.

The macro then branches of into several DEFUNs to define the supplementary
  functions that come with defining a new structure.

;;The function MAKE-STARSHIP is defined.
 (SB-C:XDEFUN MAKE-STARSHIP
     :CONSTRUCTOR
     (&KEY ((:NAME #:NAME) NIL)
      ((:CONDITION #:CONDITION)
       (SB-C::WITH-SOURCE-FORM (CONDITION 'GREEN) 'GREEN)))


;;An accessor is built.
#(SB-C:XDEFUN STARSHIP-CONDITION
     :ACCESSOR
     (SB-KERNEL:INSTANCE)
   (SB-KERNEL:%INSTANCE-REF (THE STARSHIP SB-KERNEL:INSTANCE) 2))


;;The STARSHIP-NAME accessor function is constructed.
 (SB-C:XDEFUN STARSHIP-NAME
     :ACCESSOR
     (SB-KERNEL:INSTANCE)
   (SB-KERNEL:%INSTANCE-REF (THE STARSHIP SB-KERNEL:INSTANCE) 1))


;;The structures predicate.
 (SB-C:XDEFUN STARSHIP-P
     :PREDICATE
     (SB-KERNEL::OBJECT)
   (TYPEP SB-KERNEL::OBJECT 'STARSHIP))


;;And the copier function.
 (SB-C:XDEFUN COPY-STARSHIP
     :COPIER
     (SB-KERNEL:INSTANCE)
   (COPY-STRUCTURE (THE STARSHIP SB-KERNEL:INSTANCE)))



---
14.4 DEFINING A MACRO

Macros are defined with DEFMACRO, whose syntax is similar to DEFUN.

We can define a SIMP-INCF to increment ordinary variables,
  instead of using the more thorough INCF that may be using a LET
    within the function definition adding to complexity.

CL-USER> (defmacro simp-incf (var)
           (list 'setq var (list '+ var 1)))
SIMP-INCF

CL-USER> (setf a 4)
4

CL-USER> (simp-incf a)
5

CL-USER> (ppmx (simp-incf a))
Macro expansion:
(SETQ A (+ A 1))

; No value


(defmacro simp-incf (var)
  (list 'setq var (list '+ var 1)))


We can also trace SIMP-INCF with DTRACE,
  TRACE may be unsuccessful at tracing macros.

CL-USER> (simp-incf a)
----Enter SIMP-INCF macro
|     Arg-1 = SIMP-INCF
|     Arg-2 = A
 \--SIMP-INCF expanded to (SETQ A (+ A 1))
----Enter SIMP-INCF macro
|     Arg-1 = SIMP-INCF
|     Arg-2 = A
 \--SIMP-INCF expanded to (SETQ A (+ A 1))
6


We shouldn't be tracing built-ins.

The advantage of using PPMX over tracing is that PPMX only prints the macro expansion,
  while TRACE and DTRACE evaluate the expression.



Let's modify SIMP-INCF to accept an optional second argument specifying
  the amount by which to increment the variable.

We do this with the &OPTIONAL lambda-list keyword.

The default amount to increment the variable will be by one.

CL-USER> (ppmx (simp-incf b (* 3 a)))
Macro expansion:
(SETQ B (+ B (* 3 A)))

; No value
CL-USER> b
2
CL-USER> (simp-incf b (* 3 a))
17
CL-USER> b
17


Macros do not evaluate their arguments, so the inputs to SIMP-INCF are the
  symbol B and the list (* 3 A), not the numbers 2 and 15.

An evaltrace diagram outlines how SIMP-INCF computes the macro expansion,
  which Lisp then evaluates.

CL-USER> (simp-incf b (* 3 a))
----Enter SIMP-INCF macro
|     Arg-1 = SIMP-INCF
|     Arg-2 = B
|     Arg-3 = (* 3 A)
 \--SIMP-INCF expanded to (SETQ B (+ B (* 3 A)))
----Enter SIMP-INCF macro
|     Arg-1 = SIMP-INCF
|     Arg-2 = B
|     Arg-3 = (* 3 A)
 \--SIMP-INCF expanded to (SETQ B (+ B (* 3 A))); in: SIMP-INCF B
;     (* 3 A)
; 
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::A

;     (SIMP-INCF B (* 3 A))
; ==>
;   (SETQ B (+ B (* 3 A)))
; 
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::B
; 
; compilation unit finished
;   Undefined variables:
;     A B
;   caught 2 WARNING conditions
17


The expansion happens first by the macro, and then it is given to Lisp.
  Lisp evaluates the expanded arguments and prints the return value on top level.


Let's answer the question "Why does INCF have to be a macro instead of a function?"
  Let's try it:

(defun bad-incf (var)
  (setq var (+ var 1)))

CL-USER> (defun bad-incf (var)
           (setq var (+ var 1)))
BAD-INCF
CL-USER> (bad-incf a)
6
CL-USER> a
5
CL-USER> (bad-incf a)
6
CL-USER> a
5


When BAD-INCF evaluates, the evaltrace reads like this:

(defun bad-incf (var)
  (setq var (+ var 1)))

-> (bad-incf a)
     A evaluates to 5
     Enter BAD-INCF with input 5
       Create variable VAR with value 5
         (setq var (+ var 1))
           (+ var 1)
           6
         Set VAR to 8
         8
     Result of BAD-INCF is 8


Since BAD-INCF is a function, it evaluates its arguments and is not expected to
  return an expression for Lisp to evaluate.

The function goes ahead and does the incrementing itself, but since the
  arguments are evaluated there is a problem.

The input to BAD-INCF is the number five.

BAD-INCF creates a local variable named VAR to hold its input, and then increments
  VAR by one.

It doesn't know anything about the variable A when passing it to the BAD-INCF function.

SIMP-INCF must be written as a macro.


This observation does not invalidate macros being shorthand for functions,
  we are still free to write a SETQ expression instead of using SIMP-INCF.

But remember that SETQ is not a macro, it is a special function.



EXERCISE

14.3 Write a SET-NIL macro that sets a variable to NIL.

(defmacro set-nil (var)
  (list 'setq var ()))


CL-USER> (defmacro set-nil (var)
           (list 'setq var ()))
WARNING: redefining COMMON-LISP-USER::SET-NIL in DEFMACRO
SET-NIL
CL-USER> a
5
CL-USER> (set-nil a)
NIL
CL-USER> a
NIL



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  14.5 MACROS AS SYNTACTIC EXTENSIONS
;;
;;

The purpose of macros is to extend the syntax of the language,
  Lisp does not treat a macro as an ordinary function call.

There are three important differences between ordinary functions and macro functions:

  1) The arguments to ordinary functions are always evaluated.
       The arguments to macro functions are not evaluated.

  2) The result of an ordinary function can be anything at all.
       The result returned by a macro function must be a valid Lisp expression.

  3) After a macro function returns an expression, that expression is immediately evaluated.
       The results returned by ordinary functions do not get evaluated.


In addition to macros, Common Lisp also includes a small number of special functions.
  SETF IF BLOCK and LET and a few examples of special functions.

Special functions are the lowest level building blocks in Common Lisp;
  they are responsible for things like assignment, scoping, and basic control structure
    such as blocks and loops.

Like macros, special functions do not evaluate their arguments, but they also do not
  return expressions to be evaluated.

They are primitives that do very special things.

Only a Lisp implementor may write new special functions.


Long story short, anything that can be done with a macro can also be done without macros
  by using a combination of ordinary Common Lisp functions, special functions, and in some
    cases, implementation dependent functions.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  14.6 THE BACKQUOTE CHARACTER
;;
;;

The backquote character provides us with a way to write templates for the
  expressions to be returned.

Inside of a backquoted list, any expression that is preceded by a comma
  is considered to be unquoted.

This means that the value of the expression is used.

CL-USER> (setf name 'fred)
FRED
CL-USER> `(this is ,name from pittsburgh)
(THIS IS FRED FROM PITTSBURGH)
CL-USER> (defmacro simple-incf (var &optional (amount 1))
           `(setq ,var (+ ,var ,amount)))
SIMPLE-INCF
CL-USER> (ppmx (simple-incf fred-loan (* 25 8)))
Macro expansion:
(SETQ FRED-LOAN (+ FRED-LOAN (* 25 8)))

; No value



EXERCISE

14.4 Write a macro SWITCH-VALUES that switches the value between two variables.

(defmacro switch-values (var1 var2)
  `(let ((temp1 ,var2)
         (temp2 ,var1))
     (setq ,var1 temp2)
     (setq ,var2 temp1)))


Lisp programmers commonly use macros to avoid having to quote arguments.

The macro expands into an ordinary function call with quoted versions of
  the arguments filled in where needed.

We can use backquote to generate expressions with quotes in them by including
  the quotes as part of a template:

`(setf foo 'bar)  =>  (setf foo 'bar)


(defmacro deja-two (func obj)
  `(,func ',obj ',obj))

CL-USER> (deja-two cons uno)
(UNO . UNO)
CL-USER> (ppmx (deja-two cons uno))
Macro expansion:
(CONS 'UNO 'UNO)

; No value


We place a comma before OBJECT because we want the value of that variable to be
  inserted into the list that backquote constructs;
    the quote before the comma also becomes part of the list.

If the quote were left out, the macro would expand to (CONS UNO UNO) which
  would have caused an unassigned variable error.

If we leave out the comma instead of the quote, the macro
  would expand into (CONS 'OBJ 'OBJ).



EXERCISE

14.5 Write a macro SET-MUTUAL that takes two variable names as input and
       expands into an expression that sets each variable to the name
         of the other.

(defmacro set-mutual (var1 var2)
  `(progn
     (setf ,var1 ',var2)
     (setf ,var2 ',var1)))

CL-USER> b
7
CL-USER> a
3
CL-USER> (set-mutual a b)
A
CL-USER> a
B
CL-USER> b
A


Let's try a more complex example of backquote. We will write a macro
  SHOWVAR that displays the value of a variable.

(defun f (x y)
  (showvar x)
  (showvar y)
  (* x y))


(defmacro showvar (var)
  `(format t "~&The value of ~S is ~S"
           ',var
           ,var))


SHOWVAR must be a macro because it needs to know the name of the variable it's
  displaying, not just the value.

Breaking the call to F down, we notice that only the first instance of X is quoted.

(format t "~&The value of ~S is ~S" 'x x)

We can abstract our template around this information.

(defmacro showvar (var)
  `(format t "~&The value of ~S is ~S"
           ',var
           ,var))


The combination of a quote followed by a comma may look strange,
  but we can see in the breakdown where it comes from.



---
14.7 SPLICING WITH BACKQUOTE

CL-USER> `(,producer is the ,occupation that put platinum hit band ,band-name on the map.)
((RICKY-GOLFARTS) IS THE (RECORD-PRODUCER) THAT PUT PLATINUM HIT BAND
 (THE-DINGLE-BROTHERS) ON THE MAP.)

Another feature of backquote is that if a template element is preceded by a comma
  and an at sign (,@) the value of that element is spliced into the result that backquote
    constructs rather than being inserted.

The value of the element must be a list.

If only a comma is used, the element would be inserted as a single object, resulting in
  an extra level of parenthesis.

CL-USER> `(,@producer is the ,@occupation that put platinum hit band ,@band-name on the map.)
(RICKY-GOLFARTS IS THE RECORD-PRODUCER THAT PUT PLATINUM HIT BAND
 THE-DINGLE-BROTHERS ON THE MAP.)


The parenthesis are removed from the input variable values for a more legible
  return value.


Splicing is especially useful for setting multiple inputs to a value.

(reset-counts t1 t2 t3)

(defmacro reset-counts (&rest variables)
  `(progn ,@(mapcar #'(lambda (var)
                        (list 'setf var 0))
                    variables)
          '(Scores for ,@variables have been reset.)))

CL-USER> (list t1 t2 t3)
(8 7 3)
CL-USER> (ppmx (reset-counts t1 t2 t3))
Macro expansion:
(PROGN
 (SETF T1 0)
 (SETF T2 0)
 (SETF T3 0)
 '(SCORES FOR T1 T2 T3 HAS BEEN RESET.))

; No value



EXERCISE

14.6 Write macro called VARIABLE-CHAIN that accepts any number of inputs.

(defmacro variable-chain (&rest vars)
  `(progn
     ,@(do ((v vars (rest v))
            (res nil))
           ((null (rest v)) (reverse res))
         (push `(setf ,(first v)
                 ',(second v))
               res))))

CL-USER> (list a b c d)
(A B C D)
CL-USER> (variable-chain a b c d)
D
CL-USER> (list a b c d)
(B C D D)


This macro takes any number of variables and chains them together.

The &REST allows us to input any number of variables into the variable list.

Remember that if the backquote character envelopes a list,
  anything within the list that is preceded by a comma is considered to be unquoted.
    The value of the expression rather than the expression its self is used.

A backquoted PROGN indicates that anything within the form preceded by
  a comma is considered unquoted.

The DO form is going to be returned as its value and each variable is spliced
  to a list.

Var-1: v
Init-1: vars
Update-1: (rest v)
Var-2: res
Init-2:
Update-2: nil
Test: (null (rest v))
Action-1: (reverse res)
Body:
(push `(setf ,(first v)
        ',(second v))
        res)

The first variable V starts as the list of VARS and updates with the REST of it.

RES represents the result, which doesn't update and will end up being the
  value returned.

The test expression checks whether the list is empty and if it is RES is reveresed.

The body PUSHes a backquoted SETF so:
  SETF V 'V will appear in the macro expansion

CL-USER> (ppmx (variable-chain a b c d))
Macro expansion:
(PROGN (SETF A 'B) (SETF B 'C) (SETF C 'D))

; No value



---
14.8 THE COMPILER

The compiler translates Lisp programs into machine language.
  This makes our programs run faster.

Compilation can relieve some of a Lisp programmers concerns regarding performance
  and memory usage.

Two ways we can use the compiler are by compiling a single function with
  COMPILE, or we can compile an entire file using COMPILE-FILE.

We invoke the compiler in Emacs with C-c immediately following the
  function to be compiled.

We do the whole file with M-x byte-compile-file.


Let's look at COMPILE on the running time of a simple function.

This function returns the smallest integer larger than the square root of its input.
  The result is computed in a very tedious way, but that will help us measure the
    speedup achieved by compilation.

CL-USER> (time (tedious-sqrt 999999999))
Evaluation took:
  0.000 seconds of real time
  0.000000 seconds of total run time (0.000000 user, 0.000000 system)
  100.00% CPU
  504,368 processor cycles
  0 bytes consed
  
31623
CL-USER> (compile 'tedious-sqrt)
TEDIOUS-SQRT
NIL
NIL
CL-USER> (time (tedious-sqrt 999999999))
Evaluation took:
  0.000 seconds of real time
  0.000000 seconds of total run time (0.000000 user, 0.000000 system)
  100.00% CPU
  503,715 processor cycles
  0 bytes consed
  
31623


I don't think this really counts now days, we saved virtually no time
  and only 1,000 processor cycles out of half a million.



---
14.9 COMPILATION AND MACRO EXPANSION

Common Lisp standard permits macro calls to be replaced by
  their expansions at any time.

In some implementations DEFUN does the macro expansion right away,
  in others the macro call gets replaced after the first evaluation,
    and in simple Lisps the macro isn't replaced but expanded with each call.

Since macro expansion can happen at any time,
  writing macros with side-effects is frowned upon.

Macros should not be written for assignment or generating i/o.

Lisp programmers write macros that generate expressions that produce side-effects.

(defmacro bad-announce-macro ()
  (format t "~%Hi mom!"))

(defun say-hi ()
  (bad-announce-macro))

CL-USER> (compile 'say-hi)

SAY-HI
NIL
NIL
CL-USER> (say-hi)
NIL


Here is how we fix the macro and make it a good one:

(defmacro good-announce-macro ()
  (format t "~%Hi mom!"))

CL-USER> (defun say-hi ()
           `(good-announce-macro))
WARNING: redefining COMMON-LISP-USER::SAY-HI in DEFUN
SAY-HI
CL-USER> (compile 'say-hi)
SAY-HI
NIL
NIL
CL-USER> (say-hi)
(GOOD-ANNOUNCE-MACRO)
CL-USER> (ppmx (say-hi))
Macro expansion:
(SAY-HI)

; No value



---
14.10 COMPILING ENTIRE PROGRAMS

In order for the Lisp compiler to work, we have to organize our program a certain way.


First, if our program uses any global variables the compiler may issue
  a warning message saying that the variable was "assumed to be SPECIAL."

We can get rid of those warnings by declaring variables with DEFVAR,
  DEFPARAMETER, or DEFCONSTANT. The declaration should occur early in the file,
    prior to any function that references those variables.
      Or we can just ignore the warnings.


Second, if our program contains macros, the macro definitions must
  be placed earlier in the file than any functions that reference them.

The compiler should eventually work it out, but it may not.


Third, if our program redefines any built-in functions, the compiler may
  not handle it correctly.

Be sure to use names that don't conflict with built-in functions.
  Online documentation can help for this.



---
14.11 CASE STUDY: FINITE STATE MACHINES

State machines are a theoretical computer science method for describing
  how simple devices operate.


A vending machine has two products: gum and mints.

Any combination of nickels and dimes may be used to operate the machine;
  appropriate change will be issued automatically.

If enough money has been input to the machine, pressing the gum or mint
  buttons will deliver their respective products.

Pressing the coin return lever at any time will return an amount equal
  to what has been put in so far.


The machine is initially in a state called START.

If it gets the symbol NICKEL as input, it goes "Clunk!"
  and moves to a state named HAVE-5.

If it is in state HAVE-5 and it gets the symbol DIME as input,
  it goes "Clink!" and moves to state HAVE-15.

In the state HAVE-15, if it gets the input GUM-BUTTON,
  it delivers a pack of gum and transitions to state END.


The machine has a total of six states: START HAVE-5 HAVE-10 HAVE-15 HAVE-20 END.
  States are represented by nodes and transitions represented by arcs.


Constructing the state machine:

We begin construction of the state machine simulator by creating structures for
  nodes and arcs through DEFSTRUCT.

(defstruct (node (:print-function print-node))
  (name nil)
  (inputs nil)
  (outputs nil))

(defun print-node (node stream depth)
  (format stream "#<NODE ~A>"
          (node-name node)))


(defstruct (arc (:print-function print-arc))
  (from nil)
  (to nil)
  (label nil)
  (action nil))

(defun print-arc (arc stream depth)
  (format stream "#<ARC ~A / ~A / ~A>"
          (node-name (arc-from arc))
          (arc-label arc)
          (node-name (arc-to arc))))



Next we can have global variable *NODES* hold the list of nodes comprising the machine,
  and a global variable *ARCS* holding the list of arcs the machine is limited to.
    A third variable, *CURRENT-NODE* will keep a handle on the machines current state.

(defvar *nodes*)
(defvar *arcs*)
(defvar *current-node*)


The INITIALIZE function will set these variables back to NIL.

(defun initialize ()
  (setf *nodes* nil)
  (setf *arcs* nil)
  (setf *current-node* nil))



Let's define a macro DEFNODE for syntactic sugar,
  allowing us to easily add new nodes to the machine.

(defmacro defnode (name)
  `(add-node ',name))



ADD-NODE constructs a new node with the given name and adds it to the list
  kept in the global variable *NODES*.

NCONC is used so that ADD-NODE can destructively append the node to the end of the list.
  Assuring that the nodes in *NODES* will appear in the order in which they were defined
    with DEFNODE, rather than in reverse order.

ADD-NODE also returns a newly created node.

(defun add-node (name)
  (let ((new-node (make-node :name name)))
    (setf *nodes* (nconc *nodes* (list new-node)))    ;Destructively appended.
    new-node))    ;NEW-NODE is returned.


Var-1: new-node
Val-1: (make-node :name name)
Body:
(setf *nodes* (nconc *nodes* (list new- node)))

NEW-NODE is returned.



FIND-NODE takes a node name as input and returns the corresponding node.
  If no node exists, an error is returned.

(defun find-node (name)
  (or (find name *nodes* :key #'node-name)
      (error "No node name ~A exists." name)))
      

CL-USER> (find-node 'have-5)
#<NODE HAVE-5>
CL-USER> (find-node 'bung)
; Evaluation aborted on #<SIMPLE-ERROR "No node name ~A exists." {1004AF2253}>.



The DEFARC macro provides a convenient syntax for defining arcs,
  and the ADD-ARC function does the real work.

(defmacro defarc (from label to &optional action)
  `(add-arc ',from ',label ',to ',action))


When an arc is created, it is added to the NODE-OUTPUTS list of the 'from' node
  and the NODE-INPUTS list of the 'to' node.

It is also added to the list to kept in the global variable *ARCS*.

(defun add-arc (from-name label to-name action)
  (let* ((from (find-node from-name))
         (to (find-node to-name))
         (new-arc (make-arc :from from
                            :label label
                            :to to
                            :action action)))
    (setf *arcs* (nconc *arcs* (list new-arc)))
    (setf (node-outputs from)
          (nconc (node-outputs from)
                 (list new-arc)))
    (setf (node-inputs to)
          (nconc (node-inputs to)
                 (list new-arc))))))


We use it like this,

CL-USER> (defarc start nickel have-5 "Clunk!")
(#<ARC START / NICKEL / HAVE-5>)


Now we write the top-level function FSM. It takes an optional input specifying
  the initial state of the machine.

The default initial state is START.

FSM repeatedly calls the function ONE-TRANSITION to move to the next state.
  When the machine reaches a state with no output arcs (such as END),
    it stops.

Notice that the DO has an empty variable list.

(defun fsm (&optional (starting-point 'start))
  (setf *current-node* (find-node starting-point))
  (do ()
      ((null (node-outputs *current-node*)))
    (one-transition)))


(SETF *CURRENT-NODE* (FIND-NODE STARTING-POINT))

This expression destructively sets the global variable *CURRENT-NODE* to START.
  This is a default parameter. By using the &OPTIONAL in our function definition
    variable list, STARTING-POINT can really be explicitly stated by using input
      names of any other valid node.


(do ()
    ((null (node-outputs *current-node*)))
  (one-transition))

The DO form is really here for repeatedly transitioning node to node.
  If there was an &OPTIONAL it would have already been destructively set and
    stored in *CURRENT-NODE* by the SETF form one level above.

DO is testing for NULL here, NULL in this context is when the output of *CURRENT-NODE*
  is NIL.

If *CURRENT-NODE* returns a value then the function ONE-TRANSITION is called.



Finally, we write ONE-TRANSITION.

(defun one-transition ()
  (format t "~&State ~A.  Input: "
          (node-name *current-node*))
  (let* ((ans (read))
         (arc (find ans
                    (node-outputs *current-node)
                    :key #'arc-label)))
    (unless arc
      (format t "~&No arc from ~A has label ~A.~%"
              (node-name *current-node*) ans)
      (return-from one-transition nil))
    (let ((new (arc-to arc)))
      (format t "~&~A" (arc-action arc))
      (setf *current-node* new))))


We need to add our state machine definition as well.

(defnode start)
(defnode have-5)
(defnode have-10)
(defnode have-15)
(defnode have-20)
(defnode end)


(defarc start nickel have-5 "Clunk!")
(defarc start dime have-10 "Clink!")
(defarc start coin-return start "Nothing to return.")

(defarc have-5 nickel have-10 "Clunk!")
(defarc have-5 dime have-15 "Clink!")
(defarc have-5 coin-return start "Refunded 5 cents.")

(defarc have-10 nickel have-15 "Clunk!")
(defarc have-10 dime have-20 "Clink!")
(defarc have-10 coin-return start "Refunded 10 cents.")

(defarc have-15 nickel have-20 "Clunk!")
(defarc have-15 dime have-20 "Nickel change.")
(defarc have-15 gum-button end "Deliver gum.")
(defarc have-15 coin-return start "Refunded 15 cents.")

(defarc have-20 nickel have-20 "Nickel returned.")
(defarc have-20 dime have-20 "Dime-returned.")
(defarc have-20 gum-button end "Deliver gum, returned a nickel change.")
(defarc have-20 mint-button end "Deliver mints.")
(defarc have-20 coin-return start "Refunded 20 cents.")


CL-USER> (fsm)
State START.  Input: nickel

Clunk!
State HAVE-5.  Input: dime

Clink!
State HAVE-15.  Input: gum-button

Deliver gum.
NIL
CL-USER> (fsm)
State START.  Input: dime

Clink!
State HAVE-10.  Input: dime

Clink!
State HAVE-20.  Input: mint-button

Deliver mints.
NIL
CL-USER> (fsm)
State START.  Input: dime

Clink!
State HAVE-10.  Input: dime

Clink!
State HAVE-20.  Input: gum-button

Deliver gum, returned a nickel change.
NIL


FSM is not only limited to vending machine simulation.

Any system that can be described in a finite number of states and state transitions
  can be simulated by this program.



EXERCISE

14.7 Extend the vending machine example to sell chocolate bars for 25 cents

Just extend the function accordingly, it's all in finite-state-machines.lisp



SUMMARY

Macros are Lisp's version of shorthand, with several uses.

They allow programmers to define syntactic expressions to Lisp and to say things more concisely.
  They also help Lisp implementors hide messy implementation specific details from customers.

Macros do not evaluate their arguments; they return Lisp expressions that are then evaluated.

New macros can be defined with DEFMACRO.


Like macros, special functions do not evaluate their inputs.

But unlike macros, they do not return Lisp expressions that are to be evaluated.
  Special functions provide primitives on which Lisp is built;
    primitives that provide assignment, conditionals, and block structure.


The backquote character constructs a list from a template.

If a template element is preceded by a comma it will be evaluated;
  the value is then inserted into the list being constructed.

Elements preceded by a comma and an @ sign combination are spliced
  into the list rather than inserted.

Backquote is particularly useful in macros that construct complex expressions
  by filling in the blanks of a template.



REVIEW EXERCISES

14.8 Why is it unwise to write macros that have side effects?

The purpose of macros is to extend the syntax of the language.

The Common Lisp standard permits macro calls to be replaced by their
  expansion at any time.

Essentially the expansion gets evaluated by the macro before
  Lisp can evaluate the expression.


14.9 Common Lisp contains exactly 24 built-in special functions.
       What are they?

As of mid-1989, the 24 built-in Common Lisp special functions are:

BLOCK CATCH COMPILER-LET DECLARE EVAL-WHEN FLET FUNCTION GO IF
LABELS LET LET* MACROLET MULTIPLE-VALUE-CALL MULTIPLE-VALUE-PROG1
PROGN PROGV QUOTE RETURN-FROM SETQ TAGBODY THE THROW UNWIND-PROTECT



14.10 How much faster do typical programs run after being compiled?

10 to 100x faster.



